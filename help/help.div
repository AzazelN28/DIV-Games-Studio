
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Ayuda electrónica de DIV Games Studio 2.0 (Castellano)
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

# Los saltos de línea simples son ignorados,
# los saltos de dos o más líneas se interpretan
# como saltos de párrafo.

# Los comentarios sólo pueden comenzar con un
# carácter '#' en la primera columna de una línea.

# Lista de comandos disponibles

# Texto en negrita:
#   {texto a resaltar}

# Definición de un término: (la línea anterior debe estar en blanco)
#   {.N,título}
#   texto ...

# Referencia a un término:
#   {#N,texto}

# Imagen: (N:código dentro de figuras.div (fpg), C:centrado 0, 1 o 2)
#   {+N,C}

# Final de la imagen (se debe indicar para todas las imágenes)
#   {-}

# Carácter '{' o '}':
#   {{} o {}}

# Línea separatoria:
#   {/}

# Salto de línea simple:
#   ú  (shift+3)

# Texto de lenguaje.div:
#   {@N}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Enlace informativo de que una referencia todavía no se ha definido
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.0,Invalid link of the hypertext}

Error: There is no help page associated to this link.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Ayuda sobre como usar el sistema de ayuda
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1,How to use the help system}{+5,1}{-}

The help pages are used with the mouse, but you can also use the following keys.


{Cursor}    - To move the text line per line.ú
{Up/Down.Pg.}  - To go up or down one page.ú
{ESC}         - To quit the help window.ú
{Backspace}      - To return to the last page.ú

These controls can be used only when the help window is selected
(to select a window you just have to click with the mouse over it).

In the lower right part of the screen appears a button that you can use to {modify the
size of the help window}; To do this you must hold the mouse meanwhile you move it
vertically.

The words that appear in {#1,white color} are {referencies to other
help pages} (the mouse cursor will look like a small hand when you are over the words). 
To see the help page you just have to click over these words.

The {examples} are programs or parts of programs that appear in the help
to show the way of use any of the capabilities
of the program language. All of them begin with a white color line, as you can
see right now.

{#9999,Example program:}
PROGRAM example;

BEGIN
    // ...
END
{-}

To take out the example of the help window, just click over the line.
These programs can be run with the {F10} key and to finish the execution must
press the {ALT}+{X} keys.

{/}

In the upper part of the help window can be seen a group of buttons that allow, 
respectively, to see the inside pages ({<<} and {>>}),
show some of the most important indexes ({Index}, {Glossary} and {Functions}),
send the current page to the printer ({Print}), and get help about how to use
this hypertext ({?}, to access to this page).

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Indice general
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.3,General index}{+2,1}{-}

{#2000,Introduction to DIV Games Studio 2.0}ú

{Help about the program language}ú

  {#4,Terms Glossary}ú
  {#1000,Sintaxis of a program}ú
  {#1017,Relation of statements}ú
  {#1032,List of functions}ú

  {#1202,Predefinied constants}ú
  {#1200,Predefinied global data}ú
  {#1201,Predefinied local data}ú

  {#1035,Arithmetic Expresions}ú
  {#1037,Logical conditions}ú

  {#1176,Keyboard Codes}ú

  {#2001,Language News}ú

{Help about keyboard commands}ú

  {#1291,Graphical environment Commands}ú
  {#1292,Normal Commands in the games}ú
  {#1293,Commands in the programs tracer}ú
  {#1294,Commands in the programs editor}ú
  {#1295,Commands in the graphic editor}ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Glosario de términos
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.4,Terms Glossary}{+3,1}{-}

{#1046,!=}ú
{#1045,!}ú
{#1047,"}ú
{#1049,%=}ú
{#1048,%}ú
{#1051,&&}ú
{#1052,&=}ú
{#1050,&}ú
{#1047,'}ú
{#1053,(}ú
{#1053,)}ú
{#1002,*/}ú
{#1055,*=}ú
{#1054,*}ú
{#1057,++}ú
{#1058,+=}ú
{#1056,+}ú
{#1059,,}ú
{#1061,--}ú
{#1062,-=}ú
{#1063,->}ú
{#1060,-}ú
{#1064,..}ú
{#1063,.}ú
{#1002,/*}ú
{#1002,//}ú
{#1066,/=}ú
{#1065,/}ú
{#1067,:}ú
{#1068,;}ú
{#1071,<<=}ú
{#1070,<<}ú
{#1072,<=}ú
{#1046,<>}ú
{#1069,<}ú
{#1072,=<}ú
{#1074,==}ú
{#1075,=>}ú
{#1073,=}ú
{#1075,>=}ú
{#1078,>>=}ú
{#1077,>>}ú
{#1076,>}ú
{#1079,[}ú
{#1079,]}ú
{#1081,^=}ú
{#1082,^^}ú
{#1079,^}ú
{#1084,|=}ú
{#1083,||}ú
{#1083,|}ú
{#1176,_a, _b, _c, ...}ú
{#1400,_case_sensitive}ú
{#1400,_extended_conditions}ú
{#1400,_free_sintax}ú
{#0231,_hidden}ú
{#1400,_ignore_errors}ú
{#1400,_max_process}ú
{#1400,_no_check}ú
{#1400,_no_id_check}ú
{#1400,_no_null_check}ú
{#1400,_no_optimization}ú
{#1400,_no_range_check}ú
{#1400,_no_strfix}ú
{#0231,_normal}ú
{#1400,_simple_conditions}ú
{#0231,_subdir}ú
{#0231,_system}ú
{#0231,_volid}ú
{#0100,abs()}ú
{#0246,acos()}ú
{#0101,advance()}ú
{#0250,all_drawing}ú
{#1162,all_sound}ú
{#1161,all_text}ú
{#1051,and}ú
{#1129,angle}ú
{#1409,argc}ú
{#1409,argv[]}ú
{#1109,ascii}ú
{#0245,asin()}ú
{#0247,atan()}ú
{#0248,atan2()}ú
{#1086,begin}ú
{#1120,bigbro}ú
{#1026,break}ú
{#1404,byte}ú
{#1175,c_0 ... c_9}ú
{#1169,c_m7}ú
{#1412,c_m8}ú
{#1167,c_screen}ú
{#1168,c_scroll}ú
{#0254,calculate()}ú
{#1087,case}ú
{#0256,change_channel()}ú
{#0102,change_sound()}ú
{#1416,channel[]}ú
{#0184,char()}ú
{#0235,chdir()}ú
{#0103,clear_screen()}ú
{#1030,clone}ú
{#1134,cnumber}ú
{#0104,collision()}ú
{#1400,compiler_options}ú
{#1171,complete_dump}ú
{#1174,complete_restore}ú
{#0262,compress_file()}ú
{#1004,const}ú
{#1027,continue}ú
{#0105,convert_palette()}ú
{#0243,cos()}ú
{#1122,ctype}ú
{#1031,debug}ú
{#0261,decode_file()}ú
{#1088,default}ú
{#0106,define_region()}ú
{#0250,delete_draw()}ú
{#0107,delete_text()}ú
{#1413,dirinfo (struct)}ú
{#0238,disk_free()}ú
{#0249,draw()}ú
{#1418,draw_z}ú
{#1114,dump_type}ú
{#1089,dup}ú
{#1090,else}ú
{#0259,encode()}ú
{#0260,encode_file()}ú
{#0108,end_fli()}ú
{#1091,end}ú
{#0109,exit()}ú
{#0110,fade()}ú
{#0111,fade_off()}ú
{#0112,fade_on()}ú
{#1107,fading}ú
{#1152,false}ú
{#1104,fast_mixer}ú
{#1117,father}ú
{#0224,fclose()}ú
{#0113,fget_angle()}ú
{#0114,fget_dist()}ú
{#1414,fileinfo (struct)}ú
{#0229,filelength()}ú
{#1131,file}ú
{#0264,find_color()}ú
{#1127,flags}ú
{#0230,flush()}ú
{#0223,fopen()}ú
{#0266,force_pal()}ú
{#1025,for}ú
{#1426,fps}ú
{#0115,frame_fli()}ú
{#1029,frame}ú
{#0225,fread()}ú
{#0258,free()}ú
{#1043,from}ú
{#0227,fseek()}ú
{#0228,ftell()}ú
{#1408,function}ú
{#0226,fwrite()}ú
{#1164,g_height}ú
{#1163,g_width}ú
{#1165,g_x_center}ú
{#1166,g_y_center}ú
{#0116,get_angle()}ú
{#0231,get_dirinfo()}ú
{#0117,get_dist()}ú
{#0118,get_distx()}ú
{#0119,get_disty()}ú
{#0232,get_fileinfo()}ú
{#0120,get_id()}ú
{#0121,get_joy_button()}ú
{#0122,get_joy_position()}ú
{#0123,get_pixel()}ú
{#0124,get_point()}ú
{#0195,get_point_m8()}ú
{#0125,get_real_point()}ú
{#0193,get_sector_height()}ú
{#0198,get_sector_texture()}ú
{#0220,get_song_line()}ú
{#0219,get_song_pos()}ú
{#0200,get_wall_texture()}ú
{#0233,getdrive()}ú
{#1006,global}ú
{#0191,go_to_flag()}ú
{#0126,graphic_info()}ú
{#1126,graph}ú
{#1133,height}ú
{#1092,id}ú
{#1020,if}ú
{#0240,ignore_error()}ú
{#1014,import}ú
{#1402,int} ú
{#0127,is_playing_cd()}ú
{#0222,is_playing_song()}ú
{#0221,is_playing_sound()}ú
{#0255,itoa()}ú
{#1103,joy (struct)}ú
{#1111,joy_filter}ú
{#1112,joy_state}ú
{#0128,key()}ú
{#0129,let_me_alone()}ú
{#0130,load()}ú
{#0131,load_fnt()}ú
{#0132,load_fpg()}ú
{#0174,load_map()}ú
{#0133,load_pal()}ú
{#0134,load_pcm()}ú
{#0174,load_pcx()}ú
{#0265,load_screen()}ú
{#0214,load_song()}ú
{#0134,load_wav()}ú
{#0189,load_wld()}ú
{#1007,local}ú
{#1024,loop}ú
{#0210,lower()}ú
{#1150,m320x200 ... m1024x768}ú
{#1102,m7 (struct)}ú
{#1411,m8 (struct)}ú
{#1424,m8_nextsector}ú
{#1423,m8_sector}ú
{#1425,m8_step}ú
{#1422,m8_wall}ú
{#0257,malloc()}ú
{#0135,map_block_copy()}ú
{#0136,map_get_pixel()}ú
{#0137,map_put()}ú
{#0138,map_put_pixel()}ú
{#0139,map_xput()}ú
{#1178,max_int}ú
{#1115,max_process_time}ú
{#0239,memory_free()}ú
{#1177,min_int}ú
{#0236,mkdir()}ú
{#1048,mod}ú
{#1100,mouse (struct)}ú
{#0251,move_draw()}ú
{#0140,move_scroll()}ú
{#0141,move_text()}ú
{#0142,near_angle()}ú
{#1410,net (struct)}ú
{#0181,net_get_games()}ú
{#0180,net_join_game()}ú
{#0188,new_map()}ú
{#1172,no_restore}ú
{#1045,not}ú
{#1419,num_video_modes}ú
{#1085,offset}ú
{#1083,or}ú
{#0143,out_region()}ú
{#1170,partial_dump}ú
{#1173,partial_restore}ú
{#0185,path_find()}ú
{#0187,path_free()}ú
{#0186,path_line()}ú
{#1179,pi}ú
{#0144,play_cd()}ú
{#1405,pointer}ú
{#0145,pow()}ú
{#1121,priority}ú
{#1008,private}ú
{#1016,process}ú
{#1003,program}ú
{#0146,put()}ú
{#0147,put_pixel()}ú
{#0148,put_screen()}ú
{#0213,qsort()}ú
{#1104,quality_mixer}ú
{#1421,radius}ú
{#0149,rand()}ú
{#0150,rand_seed()}ú
{#0152,refresh_scroll()}ú
{#1130,region}ú
{#0237,remove()}ú
{#1023,repeat}ú
{#1116,reserved}ú
{#0153,reset_fli()}ú
{#0175,reset_sound()}ú
{#1135,resolution}ú
{#1113,restore_type}ú
{#1028,return}ú
{#0154,roll_palette()}ú
{#1160,s_freeze_tree}ú
{#1156,s_freeze}ú
{#1157,s_kill_tree}ú
{#1153,s_kill}ú
{#1159,s_sleep_tree}ú
{#1155,s_sleep}ú
{#1158,s_wakeup_tree}ú
{#1154,s_wakeup}ú
{#0155,save()}ú
{#0241,save_map()}ú
{#0241,save_pcx()}ú
{#1110,scan_code}ú
{#0212,screen_copy()}ú
{#1101,scroll (struct)}ú
{#0227,seek_cur}ú
{#0227,seek_end}ú
{#0227,seek_set}ú
{#0179,set_color()}ú
{#0201,set_env_color()}ú
{#0196,set_fog()}ú
{#0156,set_fps()}ú
{#0157,set_mode()}ú
{#0194,set_point_m8()}ú
{#0192,set_sector_height()}ú
{#0197,set_sector_texture()}ú
{#0218,set_song_pos()}ú
{#0178,set_volume()}ú
{#0199,set_wall_texture()}ú
{#0234,setdrive()}ú
{#1104,setup (struct)}ú
{#1093,setup_program}ú
{#1108,shift_state}ú
{#0158,signal()}ú
{#0242,sin()}ú
{#1094,sizeof()}ú
{#1128,size}ú
{#1119,smallbro}ú
{#0216,song()}ú
{#1118,son}ú
{#0159,sound()}ú
{#1104,sound_bits_16}ú
{#1104,sound_bits_8}ú
{#0160,sqrt()}ú
{#0161,start_fli()}ú
{#0162,start_mode7()}ú
{#0190,start_mode8()}ú
{#0163,start_scroll()}ú
{#1095,step}ú
{#0164,stop_cd()}ú
{#0165,stop_mode7()}ú
{#0182,stop_mode8()}ú
{#0166,stop_scroll()}ú
{#0217,stop_song()}ú
{#0167,stop_sound()}ú
{#0203,strcat()}ú
{#0206,strchr()}ú
{#0205,strcmp()}ú
{#0202,strcpy()}ú
{#0211,strdel()}ú
{#1406,string}ú
{#0204,strlen()}ú
{#0208,strset()}ú
{#0207,strstr()}ú
{#1012,struct}ú
{#1021,switch}ú
{#0168,system()}ú
{#0244,tan()}ú
{#1106,text_z}ú
{#1105,timer[]}ú
{#1096,to}ú
{#1151,true}ú
{#1042,type}ú
{#0263,uncompress_file()}ú
{#1420,unit_size}ú
{#0177,unload_fnt()}ú
{#0169,unload_fpg()}ú
{#0176,unload_map()}ú
{#0170,unload_pcm()}ú
{#0176,unload_pcx()}ú
{#0215,unload_song()}ú
{#0170,unload_wav()}ú
{#1097,until}ú
{#0209,upper()}ú
{#1415,video_modes (struct)}ú
{#1417,vsync}ú
{#1022,while}ú
{#1403,word}ú
{#0171,write()}ú
{#0253,write_in_map()}ú
{#0172,write_int()}ú
{#0183,xadvance()}ú
{#1132,xgraph}ú
{#1082,xor}ú
{#0173,xput()}ú
{#1123,x}ú
{#1124,y}ú
{#1125,z}ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# funciones
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.100,abs()}

{abs(}<expression>{)}

{Return:}

The {absolute value} of the expression.

{Description:}

calculate the absolute value of the expression given as parameter, so,
if the result of the expression is negative it will change the sign,
if it is positive, it won't do nothing.

{#9999,Example program:}
PROGRAM example_abs;

GLOBAL
    INT values[15];
    INT n;

BEGIN
    FROM n=0 TO 15;
        values[n]=rand(-1000, 1000);
        write_int(0, 0, n*10,0, offset values[n]);
    END
    write(0, 0, 192, 0, "Press [SPACE] to run the function abs()");
    LOOP
        IF (key(_space))
            FROM n=0 TO 15;

                values[n] = abs(values[n]); // We find the absolute value

            END
        END
        FRAME;
    END
END
{-}

This program will print on screen a list of values that can be positive or negative, 
when the space bar is pressed it will apply the function {abs()} to all these values, 
leaving everyone positive.

{/}See: {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.101,advance()}

{advance(}<distance>{)}

{Description:}

Advance the process in it's angle (the one that shows the local variable {#1129,angle})
as many points as shows the {expression} (distance) convert into parameter.

To advance in an angle different to the contained in this variable, the function {#183,xadvance()}
can be used.

The distance can be also a negative number, in that case, the graphic of the 
process will advance (the coordinates {#1123,x} and {#1124,y}) in the opposite 
direction to its angle.

{#9999,Example program:}
PROGRAM example_advance;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=101;
    x=160;
    y=100;
    write(0, 0, 0, 0, "Use the cursors to change the direction.");
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END

        advance(2); // We advance two points the process

        FRAME;
    END
END
{-}

This example will draw a triangle on screen that will advance into the specified
direction with the predefinied local variable {#1129,angle} using this function.

Remember that the angle is especified in thousandths of degree.

The variable will be modified {#1129,angle} using the cursor keys
(adding and deducting 10000, so, 10 degrees).

{/}

This function is always equal to the two following statements:

  {x+=get_distx(angle,} <distance>{);}ú
  {y+=get_disty(angle,} <distance>{);}ú

This function just modify the coordinates of the process.
It is possible to use the two previous statements when is wanted that the
process advance in a different angle that the one which indicate it's variable
{#1129,angle}; this will be useful when is wanted that the graphic of the
process advance into a direction without rotation.

For example, to make a process to advance 8 points into a direction (that could
have it in a private variable like {angle2}) but rotated into another direction,
(the one indicate in {#1129,angle}), the statements used would be:

  {x+=get_distx(angle2, 8);}ú
  {y+=get_disty(angle2, 8);}ú

{/}See: {#183,xadvance()} - {#1044,Use of angles in the language} - {#118,get_distx()} - {#119,get_disty()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.102,change_sound()}

{change_sound(}<canal>{,} <volume>{,} <frecuency>{)}

{Description:}

To use this function is esential to have a sound card installed in the
computer, 100% compatible with the sound cards of the family
{Sound Blaster} (tm) or {Gravis Ultrasound} (tm).

This function only has meaning of use it after the function {#159,sound()}
which is the used to emit sounds.

{Change_sound()} modify one sound that is playing on one of the {channels},
stablishing your {volume} and your {frecuency}.

The {channel} is the {channel code} that gives back the function {#159,sound()}
When it is called; can sound up to 16 channels at the same time, with the same
sound or with different sounds, so, each time a sound plays it will do it
maybe, through a different channel.

Each {channel} has stablished in every moment it's level of volume and of
frecuency.

The {volume} is a value between {0} (minimum volume) and {512} (maximum volume)
which determinate the potence that the sound will be heared through this channel.

The {frecuency} is a value that affects the speed of the sound through the
channel, it controls how deep or sharp is the sound emited.
This value goes between {0} (deep) and {512} (sharp).

{#9999,Example program:}
PROGRAM example_change_sound;

PRIVATE
    frecuencia=256;     // Medium Value (0..512)
    volumen=256;        // Medium Value (0..512)

    id_sonido;
    canal;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    id_sonido = load_pcm("help\help.pcm", 1);
    canal = sound(id_sound, volume, frecuency);

    write(0, 0, 0, 0, "Press right or left to change the frecuency.");
    write_int(0, 0, 10, 0, offset frecuency);
    write(0, 0, 20, 0, "Press up or down to change the volume.");
    write_int(0, 0, 30, 0, offset volume);
    LOOP

        // Change the sound
        change_sound(channel, volume, frecuency);

        IF (key(_right)) frecuency++; END
        IF (key(_left)) frecuency--; END
        IF (key(_up)) volume++; END
        IF (key(_down)) volume--; END
        FRAME;
    END

END
{-}

In the example a sound is loaded and played (contained in the archive
{help.pcm}). Inside the main loop of the program you can change the
frecuency and the volume of this sound with the function {change_sound()};
to modify these values must be used the cursor keys.

{/}See: {#134,load_pcm/wav()} - {#159,sound()} - {#170,unload_pcm/wav()} - {#1104,STRUCT setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.103,clear_screen()}

{clear_screen()}

{Description:}

Delete the screen, the graphics put on it with the functions
{#146,put()}, {#173,xput()}, {#147,put_pixel()} y {#148,put_screen()}.

{#9999,Example program:}
PROGRAM example_clear_screen;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 0, 0, 0, "Press [SPACE] to clear the screen.");
    write(0, 0, 10, 0, "Press [ENTER] to view it again.");
    graph=100;
    x=160;
    y=100;
    LOOP
        IF (key (_space))

            clear_screen(); // Deletes the graphic of the screen

        END
        IF (key (_enter)) put_screen(0, 1); END
        FRAME;
    END
END
{-}

In the example you can see a screen with the function {#148,put_screen()}.
When the space bar is pressed, the screen is deleted.

Pressing the key {Enter}, you can see the screen again.

You can see how the graphic of the process (a ball that appears in the
center) doesn't disappear when you use the function {clear_screen()}, because
the function will just delete the screen.

{/}See: {#146,put()} - {#173,xput()} - {#147,put_pixel()} - {#148,put_screen()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.104,collision()}

{collision(}<type of process>{)}

{Return:}

The {#1039,identifier code} of one process or {0}.

{Description:}

This one is the function of the language {to detect collissions} between graphics.

Check if the current process (the one that executed this function) collides with
one of the indicated type as parameter. It checks if the graphics
of both processes are parcially superimposed.

In case of produce one colission, gives back the {#1039,identifier code}
of the process with which is colliding the current process. In the opposite case,
the function will give back always {0}.

If the current process collides with some process of the specified type, the function
{collision()} will give back the rest of the identifiers in the sucessive calls made
to the same.

To obtain, in this way, every {#1039, identifier code} of the process that
collide with the current one, mustn't use the statement {#1029,FRAME}
between two consecutive calls to the statement {collision()}. In the case of run
a process one statement {#1029,FRAME}, this function will return every
{#1039,identifier code} of collides processes from the first one.

Something similar happens if you run a call to the function especifying a different
type of process; if, after this, collisions are still detected with the previous
type, this function will return every code from the first.

When you want to obtain every {#1039,identifier code} of the processes
of one determinate type although doesn't exist any collision with
them, you must call to the function {#120,get_id()}.

If what you want is to check how near are two processes that their graphics not 
necessary collide, then you must use the function {#117,get_dist()}.

{#9999, Example program:}
PROGRAM example_collision;

PRIVATE
    id2;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;
    mobile_process(80, 50, 101);
    LOOP
        delete_text(all_text);
        write(0, 160, 0, 1, "Use the cursors to move the triangle");

        id2 = collision(TYPE mobile_process); // Collision detected

        IF (id2<>0)
            write(0, 160, 200, 7, "­ COLLISION DETECTED!");
        END
        FRAME;
    END
END

PROCESS mobile_process(x, y, graph);

BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
{-}

In this example you can see a ball in the center of the screen as
graphic of the main program.
After that a process named {mobile_process} is created with the picture of a
controlable triangle with the cursor keys.

The main program will call to the function {collision()} to check if it's graphic
(the circle) collides with the graphic of the process of type {mobile_process}
(the triangle). The result of the function is saved in the private variable
{id2} of the main program; this value will be {0} when the collision doesn't make it
and the {#1039,identifier code} of {mobile_process} does it.

The identifier codes of the processes are always odd numbers,
that in the language are evaluated as truly conditions (and the even numbers are
suitable with the false conditions), then, in the previous program could have change 
the statement:

  {IF (id2<>0)} ... {END}

For the next one:

  {IF (id2)} ... {END}

For further information about this, see: {#1037,Definition of a condition.}

{/}

When in the program you can see the mouse pointer (asigning the code of the
correspondent graphic in the {#1100,mouse estructure}), it is possible to see
if this one collides with the current process using this function,
for example, in the following way:

  {IF (collision(TYPE mouse))}ú
      // The process collides with the mouse pointerú
  {END}ú

When the collision with the mouse pointer is detected, it won't be done with the entire
graphic used as pointer, but only with the main {#1136,checkpoint} (the number 0) 
of the same one, denominated commonly as the "hotspot" ({hotspot}) of the mouse.

{/}

This function is used to detect collisions between graphics of the screen
or of a window with scroll.

It's not possible to use this function to detect collisions with processes 
that don't have a graphic (a valid code allocated to it's variable
{#1126,graph}) or between graphics of a window of mode 7 or mode 8 (with it's variable
{#1122,ctype} allocated to the value {#1169,c_m7} o {#1412,c_m8}).

It is, for that, {essential} that the one of the current process as the one of the 
specified graphic has a definied graphic.

To detect collisions between graphics of a window of mode 7 or mode 8 you must use
the function {#117,get_dist()} to detect, in this way, when the distance between the
two processes is smaller to the estipulated as {collision distance}.

{/}See: {#120,get_id()} - {#117,get_dist()} - {#1042,Types of processes} - {#1038,Ways to obtain the identifier code}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.105,convert_palette()}

{convert_palette(}<file>{,} <graphic>{,} <OFFSET new_palette>{)}

{Description:}

Transform {<graphic's>} map of color of the indicated {<file>}.

The {<}{#1085,offset}{ new_palette>} is the address inside the memory of the computer
of one board of 256 values where will be indicated the new order of the colors of the
graphic.

{Note:} The board must be of simple data (of the type {#1402,INT}, full
of 32 bit with sign).

If the board with the new palette is like the one we show you right now:

  new_palette[255]=0, 1, 2, 3, 4, ... , 254, 255;

The graphic won't be transformed. If, for example, in the position
3 of the previous board (new_palette[3]) there is a 16 (but a 3),
when the function is called with the {#1085,offset} of the board, 
the color 3 will be change for the color 16 in the graphic.


The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or made with {#188,new_map()}) will be used like if they own to the first file
(the file with the code 0).

If a process wants to change the colors of it's graphic, it musts build anyway
a board with the new order of colors and, after that, call to the function with
the parameters:

  {convert_palette(file, graph, }<OFFSET new_palette>{)}

Now will be shown a program that change the colors of it's graphic in this way
using the predefinied local variables {#1131,file} and {#1126,graph}.

{#9999,Example program:}
PROGRAM example_convert_palette;

PRIVATE
    nueva_paleta[255];
    contador;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    FROM contador=1 TO 255;
        nueva_paleta[contador]=(counter+16) MOD 256;
    END

    graph=100;
    x=160;
    y=100;

    write (0, 160, 0, 1, "Press [SPACE] to change the colors of the ball");
    LOOP
        IF (scan_code==_space)

            // We convert the palette of the graphic number 100 (ball)
            convert_palette(file, graph, offset new_palette);

        END
        FRAME;
    END
END
{-}

First, {is made a board with the new order of colors}
of the palette. The color number 0 (transparent) won't be change for anyone
(new_palette[0] will be always 0) and the rest of the colors (from 1 to 255)
will be change for the color that is 16 positions upper in the palette
(the 1 for the 17, the 2 for the 18, etc.). The last 16 colors will be change
for the first 16 (when it is done the operation {MOD 256} the values are truncated, 
256 will be 0, 257 will be 1, etc.).

After that, inside the main loop of the program will run the function
{convert_palette()} so it will change the colors of the program graphic
(a ball) each time that the space bar is pressed.

{/}See: {#133,load_pal()} - {#154,roll_palette()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.106,define_region()}

{define_region(}<region number>{,} <x>{,} <y>{,}<width> {,}<height> {)}

{Description:}

Define a new region of visualization in the screen (something like a window).
The regions are rectangular zones of the screen which inside you will see some kind
of process, scroll windows or mode 7 windows.

The {region number} must be between 1 and 31. Up to 31 different 
regions in the screen can be defined that will be able to asign, after that, to different process
(fixing it's local variable {#1130,region} to the new number) as it's view window
or use it like border for a scroll window or a mode 7 window, indicating it in the  
parameter of the functions {#163,start_scroll()} or {#162,start_mode7()}.

The {region number 0} can't be redifined, because it will be always the entire screen,
a window in the coordinates (0, 0) and as wide and as high as the screen.
This is the region in which will be shown every process,
because it's local variable {#1130,region} always has a value 0.

{#9999,Example program:}
PROGRAM example_define_region;

PRIVATE
    contador;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    define_region(1, 0, 0, 160, 200);   // We define the region 1
    define_region(2, 160, 0, 160, 200); // We define the region 2

    write(0, 0, 0, 0, "Region 1");
    write(0, 320, 0, 2, "Region 2");

    FROM contador=1 TO 20;
        mobile_process(rand(0, 319), rand(0, 159), rand(-8, 8), rand(-8, 8), rand(1, 2));
    END
END

PROCESS mobile_process(x, y, increment_x, increment_y, region);

BEGIN
    graph=100;
    LOOP
        IF (x<0 OR x>320) increment_x=-increment_x; END
        IF (y<0 OR y>200) increment_y=-increment_y; END
        x+=increment_x;
        y+=increment_y;
        FRAME;
    END
END
{-}

First you define two regions as lateral divisions of the screen.
After that, 20 processes of the type {mobile_process} are created with a loop in the random
coordinates and movement, in one of the two regions.

You can see in the execution how each process can be seen only in one of the two halfs
of the screen (just in its region).

{/}See: {#143,out_region()} - {#163,start_scroll()} - {#162,start_mode7()} - {#1130,Variable region}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.107,delete_text()}

{delete_text(}<text identifier>{)}

{Description:}

Delete definitively a text of the screen if it is specified as parameter
the {text identifier}, which is a numeric code given by the functions
{#171,write()} and {#172,write_int()} when they are asked to write a text.

If it is specified as parameter {#1161,all_text} every text on screen will be deleted.

{#9999,Example program:}
PROGRAM example_delete_text;

PRIVATE
    identificador_texto;

BEGIN
    write(0, 160, 10, 1, "Press [ENTER] to make desapear the upper text.");
    LOOP
        identificador_texto=write(0, 160, 0, 1, "Press [SPACE] to delete this text.");
        WHILE (NOT key(_space))
            FRAME;
        END

        delete_text(identificador_texto); // We delete the text

        WHILE (NOT key(_enter))
            FRAME;
        END
    END
END
{-}

In the previous example, two texts are appear on screen. When you press
the space bar, one of these texts ir deleted with the function {delete_text()},
and when you press the Enter key, the text appears again with the function {#171,write()}, 
which gives us back the text identifier.

{/}See: {#171,write()} - {#172,write_int()} - {#141,move_text()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.108,end_fli()}

{end_fli()}

{Description:}

It finish an animation {FLI/FLC} shown on screen and lets free the memory of the
computer, previously ocuppied.

The animations {FLI/FLC} are initiated with the function {#161,start_fli()}.

Just one animation can be loaded in the memory of the computer.

{#9999,Example program:}
PROGRAM example_end_fli;
BEGIN
    LOOP
        start_fli("help\help.fli", 0, 0);
        WHILE (frame_fli()<>0)
            FRAME;
        END

        end_fli(); // We load the animation on memory

    END
END
{-}

First, in the example, the animation is loaded with the function
{#161,start_fli()} and then is shown with {#115,frame_fli()}
until it finish (when this last function gives back a 0). In that moment
is unloaded of the memory using {end_fli()}.

The program does this operation (of load and unload of the 
animation {FLI/FLC}) indefinitely.

It is not necessary that the animation has finished to be unloaded from
the memory.

{/}See: {#161,start_fli()} - {#115,frame_fli()} - {#153,reset_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.109,exit()}

{exit(}<message>{,} <return code>{)}

{Description:}

The game finishes killing all the processes and returning to the operative system
(or to the DIV setting) with a {message} and a {numeric code}
(the one indicated in the expression of the second parameter).

The message is a text between quotation marks which will be shown when the game finish
as farewell to the player.

The {return code} is valid to the use of external programs to
DIV Games Studio (like files BAT), to determine the action
that must be done after run the game.

When it is used the function {exit()} it is not necessary to unload previously
any resort, like files, maps, sounds, etc., because the system finishes
automatically every resort.

{#9999,Example program:}
PROGRAM example_exit;
BEGIN
    write(0, 160, 0, 1, "Press [SPACE] to finish the program.");
    LOOP
        IF (key (_space))
            fade_off();

            exit("Thanks for using me!", 0); // We exit the program

        END
        FRAME;
    END
END
{-}

In the example you can see a message and after that, the program waits to the
space bar for be pressed to exit the program with the function {exit()}.

The use of the function {#111,fade_off()} to turn off the screen is not necessary.

{/}

every program will finish it's execution if it's made the key combination
{[ALT]+[X]} in any moment; this is similar to force the execution of the
function {exit()}, but without message and with return code 0.

{/}See: {#129,let_me_alone()} - {#111,fade_off()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.110,fade()}

{fade(}<% red>{,} <% green>{,} <% blue>{,} <speed>{)}

{Description:}

Begins a fade of the palette colors of the game until the percentages of
visualization are reached (from 0% to 200%) of the components
{red} (red), {green} (green) and {blue} (blue) that are indicated as
parameters.

The last parameter indicates the speed which is going to realize the fading of colors, 
normally is defined a number from 1 (very slowly) to
10 (Very fastly).

If it is indicated as speed a number bigger or equal to 64, the fade will be done
immediately.

The fade will be done gradually in the sucesive visualizations of the game
(in the next photograms).

If three components are 0 you will see a fade to black, if the three components are
a 200 the fade will be to white, if the components are 100 you will recover the 
original colors of the game palette.

A value, inferior to 100 in a component will turn off it's color, meanwhile that a value 
superior to 100, will saturate the color.

Remember that the fade doesn't realize when the function {fade()} runs,
It does it in the next statements {#1029,FRAME}. Meanwhile the program is executing
a fade, the predefinied global variable {#1107,fading} will have a value {true}
(an odd number that in this case will be 1) and when the fade is finished
(finally the established values of visualization of the colors are reached),
this variable will value {false} (an even number, the number 0).

{#9999,Example program:}
PROGRAM example_fade;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write (0, 0, 0, 0, "Press [SPACE] to realize the efects.");
    LOOP
        IF (NOT fading AND key(_space))

            fade(rand(0, 200), rand(0, 200), rand(0, 200), 5);

        END
        FRAME;
    END
END
{-}

In the example a screen is loaded and appears a message; after that,
each time that the space bar is pressed, if it is not fading({IF (NOT fading ...)}) 
will start one with the function {fade()} with the three components of color
chosen between 0% and 200% (with the function {#149,rand()}) at a speed of 5.

{/}See: {#1107,fading} - {#111,fade_off()} - {#112,fade_on()} - {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.111,fade_off()}

{fade_off()}

{Description:}

Realizes a fade to black from the colors on screen. The game stops as it is
until the screen is completely black. To realize a fade to black is also known
as {turn off the screen}.

To turn on again the screen (undo the fade to black) the function used is
{#112,fade_on()}.

{#9999,Example program:}
PROGRAM example_fade_off;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write (0, 0, 0, 0, "Press [SPACE] to turn off and turn on the screen.");
    LOOP
        WHILE (NOT key(_space))
            FRAME;
        END

        fade_off(); // We turn off the screen

        fade_on();
    END
END
{-}

In the example, appears a screen, and after that, the program awaits to the
space bar for be pressed to turn off and turn on the screen.

The function {#110,fade()} can make this function without stopping the program
or with different speeds, besides of realize other palette effects more
advanced.

{/}See: {#110,fade()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.112,fade_on()}

{fade_on()}

{Description:}

Realize a fade of the colors on screen to it's natural situation.
In the sucesive visualizations of the game (when is reached the statement {#1029,FRAME})
the colors will recover it's visibility until they can be seen perfectly.
This action is called {turn on the screen}.

To turn off the screen (to do a fade to black) it is used
the function {#111,fade_off()}.

{#9999,Example program:}
PROGRAM example_fade_off;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write (0, 0, 0, 0, "Press [SPACE] to turn off and turn on the screen.");
    LOOP
        WHILE (NOT key(_space))
            FRAME;
        END
        fade_off();

        fade_on(); // The screen is turned on

    END
END
{-}

In the first example appears a screen, and when the space bar is pressed
the screen turns off and turns on.

The function {#110,fade()} cam make this function with different speeds, 
besides it can does other palette effects more advance.

{/}

every game realizes automatically a {fade_on()} at the beginning
of the execution.

{/}See: {#110,fade()} - {#111,fade_off()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.113,fget_angle()}

{fget_angle(}<x0>{,} <y0>{,} <x1>{,} <y1>{)}

{Return:}

The angle between two points.

{Description:}

Gives back the angle from the {point 0} (x0, y0) to the {point 1}
(x1, y1).

Remember that the angle is specified in thousandths of degree. The function
gives back always a value between { -180000} and {180000} (an  angle between -180
and 180 degrees).

As coordinates of both points (x0, y0, x1, y1) any valid numeric expression
can be specified.

{#9999,Example program:}
PROGRAM example_fget_angle;

PRIVATE
    coordenada_x0, coordenada_y0;
    coordenada_x1, coordenada_y1;
    resultado;
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");
    write(0, 0, 0, 0, "Coordinates point 1");
    write(0, 0, 10, 0, "X:");
    write_int(0, 20, 10, 0, offset coordinate_x0);
    write(0, 0, 20, 0, "Y:");
    write_int(0, 20, 20, 0, offset coordinate_y0);
    write(0, 0, 40, 0, "Coordinates point 2");
    write(0, 0, 50, 0, "X:");
    write_int(0, 20, 50, 0, offset coordinate_x1);
    write(0, 0, 60, 0, "Y:");
    write_int(0, 20, 60, 0, offset coordinate_y1);
    write(0, 0, 80, 0, "Angle from point 1 to point 2:");
    write_int(0, 0, 90, 0, offset result);
    write(0, 0, 200, 6, "Press [SPACE] to get another two points.");
    LOOP
        clear_screen();
        coordenada_x0=rand(0, 319);
        coordenada_y0=rand(0, 199);
        coordenada_x1=rand(0, 319);
        coordenada_y1=rand(0, 199);
        put(file1,200,coordenada_x0, coordenada_y0);
        put(file1,200,coordenada_x1, coordenada_y1);

        //We find the angle between two points
        resultado = fget_angle(coordinate_x0, coordinate_y0, coordinate_x1, coordinate_y1);

        scan_code=0;
        WHILE (scan_code<>_space)
            FRAME;
        END
    END
END
{-}

In the example, after being written the necesary messages, we find the
coordinates {x} and {y} of two points found in a random way and they are saved
in the variables used to it, calculating with the function {fget_angle()}
the angle between these points. Each time that the space bar is pressed
the process will repeat.

The function {#116,get_angle()} is used to obtain the {angle of one process
to another}, instead of between two points.

The function {#114,fget_dist()} is used to obtain the {distance between two
points}, instead of the angle.

{/}See: {#1044,Use of the angles in the language} - {#116,get_angle()} - {#114,fget_dist()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.114,fget_dist()}

{fget_dist(}<x0>{,} <y0>{,} <x1>{,} <y1>{)}

{Return:}

The distance between two points.

{Description:}

Gives back the distance between the {point 0} (x0, y0) and the {point 1}
(x1, y1).

As coordinates of both points (x0, y0, x1, y1) can be specified any
valid numeric expression.

{#9999,Example program:}
PROGRAM example_fget_dist;

PRIVATE
    coordenada_x0, coordenada_y0;
    coordenada_x1, coordenada_y1;
    resultado;
    file1;

BEGIN

    file1=load_fpg("help\help.fpg");
    write(0, 0, 0, 0, "s point 1");
    write(0, 0, 10, 0, "X:")Coordinate;
    write_int(0, 20, 10, 0, offset coordinate_x0);
    write(0, 0, 20, 0, "Y:");
    write_int(0, 20, 20, 0, offset coordinate_y0);
    write(0, 0, 40, 0, "Coordinates point 2");
    write(0, 0, 50, 0, "X:");
    write_int(0, 20, 50, 0, offset coordinate_x1);
    write(0, 0, 60, 0, "Y:");
    write_int(0, 20, 60, 0, offset coordinate_y1);
    write(0, 0, 80, 0, "Distance between point 1 and point 2");
    write_int(0, 0, 90, 0, offset result);
    write(0, 0, 200, 6, "Press [SPACE] to find another distance.");
    LOOP
        clear_screen();
        coordenada_x0=rand(0, 319);
        coordenada_y0=rand(0, 199);
        coordenada_x1=rand(0, 319);
        coordenada_y1=rand(0, 199);
        put(file1,200,coordenada_x0, coordenada_y0);
        put(file1,200,coordenada_x1, coordenada_y1);

        //We find the distance between the two points
        result = fget_dist(coordinate_x0, coordinate_y0, coordinate_x1, coordinate_y1);

        scan_code=0;
        WHILE (scan_code<>_space)
            FRAME;
        END
    END
END
{-}

In the example, after write down the necesary messages, the program saves the
coordinates for two points found in a random way in the definied variables to 
the effect, obtaining the distance between them with the function {fget_dist()}. 
Each time that the space bar is pressed, the process will be repeated.

The function {#116,get_dist()} is used to obtain the {distance from one process
to another}, instead of from one point to another.

The function {#114,fget_angle()} is used to obtain the {angle between two
points}, instead of the distance.

{/}

This function can be used to detect collisions between processes, of course,
for that is used the function {#104,collision()} which detects when two processes 
have their graphics one above the another one.

For example, with the processes visualized inside of a Mode 7 window
(See {#162,start_mode7()}) the function {#104,collision()} can't be used
so must be obtained the distance between the processes (normally with
{#116,get_dist()}) to check if they collide (if their distance is smaller than one
determined).

{/}See: {#117,get_dist} - {#113,fget_angle} - {#104,collision()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.115,frame_fli()}

{frame_fli()}

{Return:}

{True} if the animation continues and {false} if it has finished.

{Description:}

Shows the next image of an animation {FLI/FLC} begun with the function
{#161,start_fli()}. This function gives back {0} if the animation has finished.

During the execution of the program, only will be possible to run an animation
{FLI/FLC} at the same time. Won't be possible to have two animations playing at
the same time.

The image of the animation, just will be seen in the next image of the game
(when we have the statement {#1029,FRAME}), so if a loop is realized, and 
inside of it is called the function {frame_fli()} but no the statement
{#1029,FRAME}, the animation won't be seen on screen.

{#9999,Example program:}
PROGRAM example_frame_fli;
BEGIN
    start_fli("help\help.fli", 0, 0);
    LOOP

        frame_fli(); // We show the image

        FRAME;
    END
END
{-}

In the example, the animation {FLI/FLC} is loaded and then is executed indefinitely
with the function {frame_fli()}.

{/}See: {#161,start_fli()} - {#153,reset_fli()} - {#108,end_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.116,get_angle()}

{get_angle(}<identifier code>{)}

{Return:}

The angle to other process

{Description:}

Gives back the angle from the current process (the one which called to this function) 
to the process which {#1039,identifier code} is give as parameter.

See {#1038,Ways to obtain the identifier code}, to further information.

Remember that the angle is specified in thousandths of degree. The function
gives back always a value between{ -180000} and {180000} (an angle between -180 and
180 degrees).

{#9999,Example program:}
PROGRAM example_get_angle;

PRIVATE
    ángulo_resultante;
    proceso_identifier;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;

    proceso_identifier = mobile_process(80, 50, 101);

    write(0, 160, 200, 7, "Use the cursors to move the triangle.");
    write(0, 0, 0, 0, "Angle from the ball to the triangle:");
    write_int(0, 0, 10, 0, offset resulting_angle);
    LOOP

        // We find the angle between the two processes
        resulting_angle = get_angle(identifier_process);

        FRAME;
    END
END

PROCESS mobile_process(x, y, graph);
BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
{-}

At the beginning appears a screen and the main program defines
it's graphic as a ball positioned in the center of the screen.

After that, is created a process of type {mobile_process} which takes the
{#1039,identifier code}, that can be controlled with the cursor keys.
                
Inside of the main loop, the angle between the two process is calculated and
shown on screen continously.

The function {#113,fget_angle()} is used to obtain the {angle between two
points}, instead of between two processes. If the {#1039,identifier code}
of the process is had, for example, into a denominated variable {id2}, then
the call to the function:

    {get_angle(id2)}

Would be equivalent to:

    {fget_angle(x, y, id2.x, id2.y)}

Obtains the angle from the coordinates (x, y) of the current process, until the
coordinates (x, y) of the process which {#1039,identifier code} is {id2}.

The function {#117,get_dist()} is used to obtain the {distance up to other process} 
instead of the angle.

{/}See: {#1044,Use of angles in  the language} - {#113,fget_angle()} - {#117,get_dist()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.117,get_dist()}

{get_dist(}<identifier code>{)}

{Return:}

The distance up to other process.

{Description:}

Gives back the distance from the current process (one which called to this function) up to
the process which {#1039,identifier code} is given as parameter.

See {#1038,ways to obtain the identifier code}, to further information.

If the process has definied it's local variable {#1135,resolution} is important
that the process which is wanted to obtain the distance, has it defined to the
same value. If both processes have the coordinates in hundredths instead of units
(with {#1135,resolution}=100), the distance between both will come in hundredths too, 
but if the value of this variable is different than both processes, the result of
the function {get_dist()} won't have any sense.

{#9999,Example program:}
PROGRAM example_get_dist;

PRIVATE
    distancia_resultante;
    proceso_identifier;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;

    proceso_identifier = mobile_process (80, 50, 101);

    write(0, 160, 200, 7, "Use the cursors to move the triangle.");
    write(0, 0, 0, 0, "Distance from the ball to the triangle:");
    write_int(0, 0, 10, 0, offset resultant_distance);
    LOOP

        // We find the distance between the two processes
        distancia_resultante = get_dist(identifier_process);

        FRAME;
    END
END

PROCESS mobile_process(x, y, graph)
BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
{-}

At the beginning appears a screen and the main program defines
it's graphic as a ball placed in the center of the screen.

Then a process of type {proceso_movil} is created and from it, is taken
the {#1039,identifier code}, which can be controlled with the cursor keys.

Inside of the main loop the distance between the two processes is 
calculated and shown continuously on screen.

The function {#114,fget_dist()} is used to obtain the {distance between two
points}, instead of between two processes. If the {#1039,identifier code}
of the process is had, for example, in a variable denominated {id2}, then
the call to the function:

    {get_dist(id2)}

Will be equivalent to:

    {fget_dist(x, y, id2.x, id2.y)}

To obtain the distance from the coordinates (x, y) of the current process up to the
coordinates (x, y) of the process which {#1039,identifier code} is {id2}.

The function {#116,get_angle()} is used to obtain the {angle up to the process}
instead of the distance.

{/}

This function can be used to detect collisions between processes, of course,
for that is used the function {#104,collision()} which detects when two processes 
have their graphics one above the another one.

For example, with the processes visualized inside of a Mode 7 window
(See {#162,start_mode7()}) the function {#104,collision()} can't be used
so must be obtained the distance between the processes (normally with
{#116,get_dist()}) to check if they collide (if their distance is smaller than one
determined).

{/}See: {#114,fget_dist()} - {#116,get_angle()} - {#118,get_distx()} - {#119,get_disty()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.118,get_distx()}

{get_distx(}<angle>{,} <distance>{)}

{Return:}

The horizontal movement of the vector (angle, distance).

{Description:}

Gives back the horizontal distance (in the axis of the coordinate {x}) from
the angle and {distance} (upon that angle) given as parameters.
It gives back the distance that the vector moves horizontally, made by the
angle and {length} (distance or module of the vector) indicated.

Remember that the angle is specified in thousandths of degree and as
distance can be specified any valid numeric expression.

The function used to calculate the vertical distance, instead of the
horizontal, is {#119,get_disty()}.

{#9999,Example program:}
PROGRAM example_get_distx;

GLOBAL
    distance;
    distance_horizontal;
    distance_vertical;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 3);
    write(0, 160, 200, 7, "Use the cursors to move the triangle.");
    write(0, 0, 0, 0, "Horizontal distance:");
    write_int(0, 0, 10, 0, offset distance_horizontal);
    graph=101;
    LOOP
        IF (key(_up)) distance+=2; END
        IF (key(_down)) distance-=2; END
        IF (key(_right)) angle-=2000; END
        IF (key(_left)) angle+=2000; END

        // We calculate the horizontal distance
        distance_horizontal = get_distx(angle, distancia);

        distance_vertical = get_disty(angle, distancia);
        x=160+distance_horizontal;
        y=100+distance_vertical;
        FRAME;
    END
END
{-}

In the example, the program uses as background of the screen, a circular graphic,
and on it, a triangle will be manipulated with the cursors
changing it's distance and angle.

The program calculates the horizontal and vertical distances to place the
triangle from the coordinates of the center of the screen
(160, 100), showing in every moment the horizontal distance in the
upper left corner.

{/}

If is wanted to advance the coordinates of the process one {distance} in a
determined angle, can be used the following statements:

  {x+=get_distx(}<angle>{,} <distance>{);}ú
  {y+=get_disty(}<angle>{,} <distance>{);}ú

This would be equivalent to the following statement (using the function {#183,xadvance()}).

  {xadvance(}<angle>{,} <distance>{);}

If the angle in which is wanted to move the process is the one that has in it's
local variable {#1129,angle}, then this operation could be made with the
function {#101,advance()} in the following way:

  {advance(}<distance>{);}

{/}

The function {get_distx()} is the same to calculate the {cos} of the angle and
multiply it with the {distance}.

{/}See: {#1044,Use of angles in the language} - {#119,get_disty()} - {#183,xadvance()} - {#101,advance()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.119,get_disty()}

{get_disty(}<angle>{,} <distance>{)}

{Return:}

The vertical movement of the vector (angle, distance).

{Description:}

Gives back the vertical distance (axis of the coordinate {y}) from the angle
and {distance} (of this angle) given as parameters. Gives back the distance
that moves in vertical the vector made by the angle and {length} (distance) 
indicated.

Remember that the angle is specified in thousandths of degree and as
distance can be specified any valid numeric expression.

The function used to calculate the horizontal distance, instead of the
vertical, is {#119,get_distx()}.

{#9999,Example program:}
PROGRAM example_get_disty;

GLOBAL
    distance;
    distance_horizontal;
    distance_vertical;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 3);
    write(0, 160, 200, 7, "Use the cursors to move the triangle.");
    write(0, 0, 0, 0, "vertical distance:");
    write_int(0, 0, 10, 0, offset distance_vertical);
    graph=101;
    LOOP
        IF (key(_up)) distance+=2; END
        IF (key(_down)) distance-=2; END
        IF (key(_right)) angle-=2000; END
        IF (key(_left)) angle+=2000; END

        // We calculate the vertical distance 
        distance_vertical = get_disty(angle, distance);

        distance_horizontal = get_distx(angle, distance);
        x=160+distance_horizontal;
        y=100+distance_vertical;
        FRAME;
    END
END
{-}

In the example is used as background a circle graphic and on it, 
a triangle can be controlled with the cursors, modifying
it's distance and angle to the center of the graphic.

The program calculates the horizontal and the vertical distances to put the
triangle with the coordinates of the center of the screen
(160, 100), being shown in every moment, the vertical distance in the
upper left corner.

{/}

If it is wanted to advance the coordinates of the process one {distance} in a
determined angle, the following statements can be used:

  {x+=get_distx(}<angle>{,} <distance>{);}ú
  {y+=get_disty(}<angle>{,} <distance>{);}ú

This would be equivalent to the next statement (using the function {#183,xadvance()}).

  {xadvance(}<angle>{,} <distance>{);}

If the angle in which the process is wanted to be move is the one that has
in it's local variable {#1129,angle}, then, this operation could be done with 
the function {#101,advance()} in the following way:

  {advance(}<distance>{);}

{/}

The function {get_disty()} is the same to calculate the {sin} of the angle and multiply it
with the {distance}, changing the sign of the result, due to the
axis {Y} of screen advances downwards (in the opposite way of the sin function).

{/}See: {#1044,Use of the angles in the language} - {#118,get_distx()} - {#183,xadvance()} - {#101,advance()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.120,get_id()}

{get_id(}<type of process>{)}

{Return:}

The {#1039,identifier code} of a process or {0}.

{Description:}

It checks if there are active processes of the specified type. In afirmative case,
this function will give back the {#1039,identifier code} of one of them and, in the
opposite case, will give back a 0.

If there are some processes of the specified type, the function {get_id()} 
will give back the rest of the identifiers in the next calls made to the same.

Once that every {#1039,identifier code}, is given back, the function
will give back 0, until a statement {#1029,FRAME} is run again, in this 
moment, this function will give back, again, every identifier code
of the processes of the specified type.

To obtain in this way, every {#1039,identifier code} of the
processes, you shouldn't use the statement {#1029,FRAME}
between two consecutive calls to the statement {get_id()}. In the case of
execute a statement {#1029,FRAME}, this function will give back
every {#1039,identifier code} of the processes from the first.

Something similar happens if you run a call to the function, specifying
a different type of process; if, after this, the identifiers of the previous process
are asked again, this function will return everyone from the first.

{#9999,Example program:}
PROGRAM example_get_id;

PRIVATE
    proceso_identifier;
    contador;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    FROM contador=1 TO 20;
        process_mobile(rand(0, 319), rand(0, 199), 101);
    END
    LOOP
        FROM contador=1 TO 20;

            // We take the identifiers of the processes
            proceso identifier = get_id(TYPE process_mobile);

            identifier_process.angle+=rand(-5000, 5000);
        END
        FRAME;
    END
END

PROCESS process_mibile(x, y, graph);
BEGIN
    LOOP
        FRAME;
    END
END
{-}

In the example, after the graphic file is loaded, and after the background 
appears, 20 processes of type {mobile_process} are created with their positions
chosen randomly and a triangle as it's graphic.

These processes only will run statements {#1029,FRAME} inside of
a loop, to being seen.

From the main program, the identifiers of the processes of the type
{mobile_process} are taken with the function {get_id()} (saving them in the
variable {identifier_process}) and using them to modify the angle (its
local variable {#1129,angle}).
                                                                 
How is disposed the {#1039,identifier code} of a process, can be consulted or 
modified it's local variables (as {#1129,angle} in this example)
or send signals to the process with the function {#158,signal()}.

{/}

The function {#104,collision()} is used to obtain the {#1039,identifier codes}
of processes of a determinied type that, besides, collide with the current
process.

{/}See: {#1038,Ways to obtain the identifier code} - {#1042,Types of processes} - {#1039,Identifier codes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.121,get_joy_button()}

{get_joy_button(}<button number>{)}

{Return:}

{True} (1) if the button is pressed, {False} (0) if it isn't

{Description:}

This function requires as parameter the button number of the joystick
(from 0 to 3), it gives back {true} (an odd numeric value) if it is 
pressed in that moment.


If the button is not pressed, the function gives back {false}
(an even numeric value).

Some joystick only have two buttons; in this case they will be the buttons 
number 0 and 1. In computers with two joysticks connected, the second one
will have the buttons number 2 and 3.

{#9999,Example program:}
PROGRAM example_get_joy_button;

PRIVATE
    contador;
    botones[3];

BEGIN
    write(0, 160, 200, 7," Press the buttons of the joystick.");
    write(0, 0, 0, 0, "Buttons (0..3):");
    write_int(0, 100, 0, 0, offset buttons[0]);
    write_int(0, 120, 0, 0, offset buttons[1]);
    write_int(0, 140, 0, 0, offset buttons[2]);
    write_int(0, 160, 0, 0, offset buttons[3]);
    LOOP
        FROM contador=0 TO 3;

            // We take the value of the joystick button
            botones[contador] = get_joy_button(counter);

        END
        FRAME;
    END
END
{-}

An explaining message is printed in the lower part of the screen and 
the condition of the four possible buttons in the upper part of the screen; 
after that, the program stays inside of a loop updating continously
the condition of the four buttons with the function {get_joy_button()}.

{/}

There are other ways to use the joystick. The easiest is to use
the estructure {#1103,joy}, because on it there are four registrations that
shows continously the condition of the joystick buttons.

{/}See: {#122,get_joy_position()} - {#1103,Joy estructure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.122,get_joy_position()}

{get_joy_position(}<axis number>{)}

{Return:}

The position of the joystick axis

{Description:}

This function gives back the coordinate in which is found the indicated axis
(with a number from {0} to {3}) of the analogic joystick.

Axis {0} - Axis {X} main.ú
Axis {1} - Axis {Y} main.ú
Axis {2} - Axis {X} secondary.ú
Axis {3} - Axis {Y} secondary.ú

The coordinate of the joystick can change due to the type of joystick and
computer in which is played, anyway it is a number which change between
{4} and {200}, more or less.

The axis {main} and {secondary} can be integrated just in one joystick
in some cases (flight joysticks with a {hat}, {pedals}, etc.). In computers
with two joystick connected, the main axis will be the joystick 1 and the
secondary will be the 2.

{#9999,Example program:}
PROGRAM example_get_joy_position;

PRIVATE
    eje_joystick[3];
    contador;

BEGIN
    write (0, 160, 200, 7, "Move the joystick");
    write (0, 0, 0, 0, "Coordinate X main.");
    write_int(0, 0, 10, 0, offset axis_joystick[0]);
    write (0, 0, 40, 0, "Coordinate Y main.");
    write_int(0, 0, 50, 0, offset axis_joystick[1]);
    write (0, 0, 80, 0, "Coordinate X secondary.");
    write_int(0, 0, 90, 0, offset axis_joystick[2]);
    write (0, 0, 120, 0, "Coordinate Y secondary.");
    write_int(0, 0, 130, 0, offset axis_joystick[3]);
    LOOP
        FROM contador=0 TO 3;

            // We take the value of the joystick axis
            eje_joystick[contador] = get_joy_position(counter);

        END
        FRAME;
    END
END
{-}

First the messages are printed and then, the program stays inside of a
loop, updating continously the condition of the four axis with the
function {get_joy_button()} (which, in this case, are saved in the private
board {axis_joystick}).

{/}

There are other ways to use the joystick. The esaiest is to use
estructure {#1103,joy} when it is not required an analogic reading of
the joystick (its coordinates), when it is enough to know if the
joystick is in the center, to the right, down, etc.

{/}See: {#121,get_joy_button()} - {#1103,Estructure joy}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.123,get_pixel()}

{get_pixel(}<x>{,} <y>{)}

{Return:}

The color of the point (0..255).

{Description:}

Gives back the color that the point has of the {background}
that is in the indicated coordinates as parameters.

The number given is the order inside of the color palette activated in the
program, between 0 and 255, because the palettes have 256 colors.

The point is taken only from the picture of the background, without taking care 
of the graphics of the processes, texts, regions of scroll, etc.,
only will be readen the colors given by the functions {#146,put()},
{#173,xput()}, {#147,put_pixel()} y {#148,put_screen()}.

{#9999,Example program:}
PROGRAM example_get_pixel;

PRIVATE
    color_punto;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 2);
    mouse.graph=200;
    write (0, 0, 190, 0, "color of the point of the background:");
    write_int(0, 256, 190, 0, offset color_point);
    LOOP

        // We take the color of the point of the background
        color_punto = get_pixel(mouse.x, mouse.y);

        FRAME;
    END
END
{-}

In the example, the background is given with the function {#148,put_screen},
as a group of squares of different colors and a cross is asigned as cursor 
or the mouse.

After that, in the lower part of the screen, will be shown the designed color 
in the position signed with the mouse, reading this with the function {get_pixel()}
in each iteration of the main loop of the program.

{/}See: {#147,put_pixel()} - {#136,map_get_pixel()} - {#138,map_put_pixel()} - {#124,get_point()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.124,get_point()}

{get_point(}<file>{,} <graphic>{,} <number>{,} <OFFSET x>{,} <OFFSET y>{)}

{Return:}

The position of the checkpoint (in the variables which {#1085,offset} is
indicated as the two last parameters).

{Description:}

This function gives back were was placed in a {graphic} (of the {file} indicated)
the checkpoint which {number} is indicated as third parameter.

A {#1136,checkpoint} is a point that can be defined in the graphic editor
(draw tool), in the option to this function.

The function needs the {address} (which is obtained with the operator {#1085,offset})
in the computer memory {of two variables} in which will be given back the address
{x} and {y} of the checkpoint.

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the one with the code 0).

{#9999,Programa ejemplo:}
PROGRAM example_get_point;

GLOBAL
    file1;
    punto=1;
    x_punto;
    y_punto;

BEGIN
    file1=load_fpg("help\help.fpg");
    put_screen(0, 4);
    graph=101;
    LOOP
        IF (fget_dist(x, y, x_punto, y_punto)<6)
            IF (punto++==50) punto=1; END
        END

        // We take the checkpoint
        get_point(file1, 4,punto, offset x_punto, offset y_punto);

        angle=fget_angle(x, y, x_punto, y_punto);
        advance(6);
        FRAME;
    END
END
{-}

In the example appears a background with a circuit that travels on the screen; 
this picture (the graphic {4} of the file) has defined 50 {#1136,checkpoints} 
(fron 1 to 50) in the circuit.

The main process appears as a triangle that travels through the circuit.

This can be done having the variable {point} the number of the checkpoint
which must be sent the triangle, at the beginning the point number 1.

The coordinates of each checkpoint, obtained with the function {get_point()},
are saved in the variables {x_point} and {y_point} and are used to make the process
go to that position with the functions {#113,fget_angle()}
(to obtain in the variable {angle} the angle to the point) and
{#101,advance()} (to advance 6 points to that direction).

When the checkpoint is near, what it is checked with the function
{#114,fget_dist()}, is if it is detected the number of point, to
direct the triangle onto the next (when the point number 50 is reached
it will be back to the 1).

{/}

This function gives back the exact coordinates in which were positioned
that checkpoint inside the graphic, without worry about how is the graphic now 
(escalated, rotated, etc.). To obtain the position of one checkpoint
in an escalated graphic, rotated, etc. and relative to the coordinates of
screen (and no of the original graphic) it must be use the 
function {#125,get_real_point()}.

This last function gives back the address where is placed a checkpoint in 
a determined moment, and {get_point()} gives back where it was placed 
originally.

{/}See: {#1136,Checkpoints} - {#125,get_real_point()} - {#123,get_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.125,get_real_point()}

{get_real_point(}<number>{,} <OFFSET x>{,} <OFFSET y>{)}

{Return:}

The current coordinates of the checkpoint (in the variables which
{#1085,offset} is indicated as the two last parameters).

{Description:}

This function gives back where is in that moment a checkpoint
of the main process graphic in the coordinates system used by 
the process (See local variable {#1122,ctype}), evaluating the 
original ubication of the point, the current coordinates of the
process, it's size, angle, etc.

A {#1136,checkpoint} is a point that can be defined in the graphics 
editor (drawing tool), in the option given to the function.

The function needs the {address} (which is obtained with the operator {#1085,offset})
in the computer memory {of two variables} in which will be given back the position
{x} and {y} of the checkpoint.

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as they were from the first file
(the file with the code 0).

{#9999,Example program:}
PROGRAM example_get_real_point;

PRIVATE
    punto;
    x_punto;
    y_punto;

BEGIN
    load_fpg("help\help.fpg");
    graph=4;
    x=160;
    y=100;
    LOOP
        FROM punto=1 TO 50;

            // We take the coordinates where there is at this moment the checkpoint
            get_real_point(point, offset x_point, offset y_point);

            marking_process(x_point, y_point, 200);
        END
        angle+=1000;
        FRAME;
    END
END

PROCESS marking_process(x, y, graph);
BEGIN
    FRAME;
END
{-}

In the example is defined as graphic of the main process a circuit that
travels on the screen. This graphic has defined 50 {#1136,checkpoints}
(from 1 to 50).

The program stays inside of a loop, rotates this graphic
(adding a degree with the statement {angle+=1000;}) and creating 50 processes
in a cross form, one in each one the checkpoints of the graphic.

You can check how the relative position of two points doesn't change
though the graphic of the circuit rotates.

{/}

This function is ussually used to have located some important points of a graphic.
For example, if it is defined a process which graphic is a man with a gun that can
be escalated, rotated o that has some animations, a checkpoint could be defined
in the cannon of the gun to know in each moment where the bullets must go out in case
of being shooted.

If the original graphic was inside of a scroll region 
(See{#163,start_scroll()}) the given coordinates will be relative too
to the scroll region.

{/}

The function {#124,get_point()} gives back the position where it was placed
originally in a checkpoint of the graphic, instead of it's current position
like {get_real_point()}.

{/}See: {#1136,Checkpoints} - {#124,get_point()} - {#123,get_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.126,graphic_info()}

{graphic_info(}<file>{,} <graphic>{,} <information>{)}

{Return:}

The asked information about the graphic

{Description:}

It gives back the information which is asked about a {graphic} of a {file}.

Information:

{g_width} - The function will give back the {original width} of the graphic
if is put as third parameter g_width.
{g_height} - The function will give back the {original high} of the graphic.

{g_x_center} - The function will give back the {coordinate x} of the center of the graphic.

{g_y_center} - The function will give back the {coordinate y} of the center of the graphic.

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the file with the code 0).

{#9999,Example program:}
PROGRAM example_graphic_info;

PRIVATE
    file1;
    alto;
    ancho;
    x_centro;
    y_centro;

BEGIN
    file1=load_fpg("help\help.fpg");
    put_screen(file1, 1);
    graph=100;
    x=160;
    y=100;

    // We take the information about the height of the graphic
    alto = graphic_info(file1, 100, g_height);

    // We take the information about the width of the graphic
    ancho = graphic_info(file1, 100, g_width);

    // We take the information about the coordinate x of the center of the graphic
    x_centro = graphic_info(file1, 100, g_x_center);

    // We take the information about the coordinate y of the center of the graphic
    y_centro = graphic_info(file1, 100, g_y_center);

    write(0, 0, 0, 0, "Height of the graphic:");
    write_int(0, 0, 10, 0, offset alto);
    write(0, 0, 20, 0, "width of the graphic:");
    write_int(0, 0, 30, 0, offset ancho);
    write(0, 0, 40, 0, "Horizontal center of the graphic:");
    write_int(0, 0, 50, 0, offset x_centro);
    write(0, 0, 60, 0, "vertical center of the graphic:");
    write_int(0, 0, 70, 0, offset y_centro);
    LOOP
        FRAME;
    END
END
{-}

In the example, the program asks about the information of the graphic number 100 of the
file {help.fpg}, which is a ball of 32 points per 32 points and with it's center
in (16, 16).

To obtain this information will be necessary to call 4 times to the function
{graphic_info()}, because each time just gives back one value in function
of the third parameter of the call (<information>).

{/}See: {#1163,g_width} - {#1164,g_height} - {#1165,g_x_center} - {#1166,g_y_center}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.127,is_playing_cd()}

{is_playing_cd()}

{Return:}

{True} (1) if the CD is playing, or {false} (0) if it isn't.

{Description:}

This function is used to determinate if the CD is playing a song.
				
Gives back {True} (an odd number) if the CD is playing a song, in the 
opposite case, gives back {False} (an even number).

The most general use is to be able to play a song indefinitely as it is
shown in the following example.

{#9999,Example program:}
PROGRAM example_is_playing_cd;
BEGIN
    play_cd(1, 0);
    LOOP

        IF (NOT is_playing_cd()) // Checks if the song has finished

            play_cd(1, 0);
        END
        FRAME;
    END
END
{-}

The previous example (for which is necessary to have a {Compact disk} of
music in the {CD-ROM}) drive, uses the function {#144,play_cd()} to start the
first song of the CD.

After that,in a loop, is checked if the song has finished to restart it.

{/}

The volume of reproduction of cd-audio can be controlled with the
estructure {#1104,setup} and the function {#178,set_volume()}.
											
{/}See: {#144,play_cd()} - {#164,stop_cd()} - {#178,set_volume()} - {#1104,Setup estructure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.128,key()}

{key(}<key code>{)}

{Return:}

{True} (1) if the key is pressed and {false} (0) if it isn't.

{Description:}

Gives back {true} (an odd number) if the key, indicated as parameter
is pressed in that moment; in the opposite case gives back {false} (an even
number).

Normally the entrance parameter will be the name of the key with
the symbol {_} before; for example, to read the key [{A}] the function 
should be called {key(_a)}.

Access to the {#1176,key codes} to see the complete list of keyboard codes that
can be used as parameter of the function {key()}.

{#9999,Example program:}
PROGRAM example_key;
BEGIN
    LOOP
        delete_text(all_text);

        IF (key(_space)) // We check if the space bar is pressed

            write(0, 0, 0, 0, "You are pressing the [SPACE] key.");
        ELSE
            write(0, 0, 0, 0, "You are not pressing the [SPACE] key.");
        END
        FRAME;
    END
END
{-}

In the example appears one message or another, depending if the space
bar is pressed or not.

{/}

There are three predefinied global variables that can be used too
to the control of the keyboard; these are:

{#1110,scan_code} - Code of the last key that has been pressed; this
is a numeric value that corresponds directly with the constants
of {#1176,key codes} used as parameters of the function {key()}.

{#1109,ascii} - ASCII code of the last key pressed.

{#1108,shift_state} - Variable that indicates a number in function of the 
special keys  (shift, alt, control, ...) which are pressed in that moment.

{/}See: {#1176,key codes} - {#1110,scan_code} - {#1109,ascii} - {#1108,shift_state}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.129,let_me_alone()}

{let_me_alone()}

{Description:}

It sends a signal {#1153,s_kill} to every process, except the one that ran
this function, this will eliminate every process but the current one.

This function is used, normally, from the main process when has finished
a game, to eliminate every process (shots,enemies, etc.) that will remain actived 
and recover the control of the program.

A call to {let_me_alone()} could be changed always for a group of calls to the 
function {#158,signal()} with the signal {#1153,s_kill}, but to do this
should be known the types of the processes that are wanted to be eliminated
or, their {#1039,identifier codes}.

{#9999,Example program:}
PROGRAM example_let_me_alone;
BEGIN
    load_fpg("help\help.fpg");
    process_nule(160, 100, 100);
    write (0, 160, 0, 1, "Press [SPACE] to eliminate the process");
    WHILE (NOT key (_space))
        FRAME;
    END

    let_me_alone(); // The other processes are eliminated

    LOOP
        FRAME;
    END
END

PROCESS process_nule(x, y, graph)
BEGIN
    LOOP
        FRAME;
    END
END
{-}

In the example, after create a process of type {process_nule}, the program waits
to the space bar for be pressed to use the function {let_me_alone()} which eliminates
every process (but the main one, which is the one that called the function);
in this case will be eliminated the process of type {process_nule}.

{/}

To check the processes that there are actived in a program in a determined
moment, the debugger must be accessed pressing the key [{F12}].

{/}

The function {#109,exit()} is used to finish a program instantly, returning to the system.

{/}See: {#109,exit()} - {#158,signal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.130,load()}

{load(}<name of the archive>{,} <OFFSET data>{)}

{Description:}

Loads a group of data of an archive in the disk to the memory of the program.

To do this, the function requires the {name of the archive} and the movement
inside of the computer memory of the variable, board or structure
saved in the disk (the movement of the data can be obtained with the
operator {#1085,OFFSET}).

It must be specified the movement of the same data that was specified
when saved the archive with the function {#155,save()}.

The names of the archive can be done specifying the route of access, {which
must be the same that the used with the function} {#155,save()} to save
the archive. But {it's not necessary} to specify a route.

It's important that the archive that is going to be loaded were created
before, because the program will have an error if you try to load an archive
that doesn't exists (or it can be ignored and continue the execution of the program).

{#9999,Example program:}
PROGRAM example_load;

PRIVATE
    tabla[9];
    contador;

BEGIN
    write (0, 0, 0, 0, "Press [ENTER] to delete the data.");
    write (0, 0, 10, 0, "Press [SPACE] to load the data of the disk");
    write (0, 0, 30, 0, "Current Values of the data:");
    FROM contador=0 TO 9;
        tabla[contador]=rand(0, 100);
        write_int(0, 0, 40+(contador*10), 0, offset tabla[contador]);
    END
    save("help\help.dat", offset tabla, sizeof(tabla));
    LOOP
        IF (key(_enter))
            FROM contador=0 TO 9;
                tabla[contador]=0;
            END
        END
        IF (key(_space))

            load("help\help.dat", offset tabla); // The data of the disk is loaded

        END
        FRAME;
    END
END
{-}

At the beginning of the example a board of 10 positions is created (from 0 to 9)
with random values. This board is saved in the disk with the function
{#155,save()}.

When the ENTER is pressed the values of the board will be deleted (the 10 positions
are put to 0)

When the space bar is press the values of the board are loaded of the disk with the 
function {load()}.

{/}See: {#155,save()} - {#1094,sizeof()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.131,load_fnt()}

{load_fnt(}<name of the archive>{)}

{Return:}

The {code of the font} loaded.

{Description:}

It loads an archive with a new font of symbols (*.FNT) from the disk
(a "font" with a new group of graphic symbols).

The function gives back the {font code} that can be used by the
functions {#171,write()} and {#172,write_int()} to write a text.

It can be specified a route of access to the archive with the font, but
if the archive with the letter font has been generated in the default
directory (\FNT) it won't be necessary.

The archive with the new font must be created with the color palette
of the game to be seen correctly, in the opposite case the colors 
will be changed.

{#9999,Example program:}
PROGRAM example_load_fnt;

PRIVATE
    fuente1;

BEGIN

    fuente1=load_fnt("help\help.fnt"); // A font is loaded for the text

    write(0, 160, 0, 1, "Text written with the system font.");
    write(fuente1, 160, 10, 1, "FONT OF THE ARCHIVE IN DISK");
    LOOP
        FRAME;
    END
END
{-}

In the example, a font is loaded with the function {load_fnt()}, and after that
two texts are written with different fonts. The first one with the system font
and the second one with the font loaded from the archive {help.fnt}.

{/}

To delete from the computer memory the loaded font (letting free
the space of memory occupied by the font) you must use the function
{#177,unload_fnt()}, giving as parameter the {font code}.

{It is not necessary} to delete the font with this last function
if you don't need the space occupied to load more graphics or fonts, because
the system will let free the font automatically when the program finishes.

{/}See: {#177,unload_fnt()} - {#171,write()} - {#171,write_int()} - {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.132,load_fpg()}

{load_fpg(}<name of the archive>{)}

{Return:}

Return the {file code} loaded.

{Description:}

It loads an archive with a file (*.FPG) of the disk. It's understood as a file, 
a collection of graphics
                                                 
An archive FPG with a collection of graphics can contain from no graphics to
999 graphics. Each one of them included in the collection will have a numeric
code, the {graphic code}, which is a number between
{1} and {999} that is used to identify the graphic inside of the file.

Is possible to load as many graphic files as it is necessary, meanwhile there is
free space in memory (to load some files this function must be call some times).

The function gives back the {file code}, which can be used by multiple functions
that require a graphic, to do this you must indicate the {file code} where is the graphic 
and the {graphic code} inside of the file.

The route of access to the archive can be specified with the file of graphics,
but if the file is in the default directory (\FPG) it won't be necessary.

{/}

When you have loaded different files you must know that if these files have different
palettes, you must activate each palette previously with the function {#133,load_pal()}, 
giving the name of the file (FPG) as parameter, before use the graphics of itself.

{#9999,Example program:}
PROGRAM example_load_fpg;

PRIVATE
    file1;

BEGIN

    file1 = load_fpg("help\help.fpg"); // The file of graphics is loaded

    put_screen(file1, 1); // We use the graphic 1 of the file
    write(0, 160, 0, 1, "File of graphics loaded successfully");
    LOOP
        FRAME;
    END
END
{-}

In the example, is loaded the file of graphics which is going to be used is the
program with the function {load_fpg()} and, after that, is used the graphic number 1
of the file to use it as background (with the function {#148,put_screen()}).

{/}

The function {#169,unload_fpg()} allows to set free the computer memory used
by the file of graphics when it's not going to be used anymore and, to do this
it requires too the {file code} to know which file is the one that is wanted to be 
deleted of memory.

{It is not necessary to delete the file from memory} before finish the program,
because the same program will do it itself automatically.

{/}See: {#169,unload_fpg()} - {#174,load_map/pcx()} - {#133,load_pal()} - {#1131,file}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.133,load_pal()}

{load_pal(}<name of the archive>{)}

{Description:}

Loads a color palette of the disk (from an archive PAL, FPG, MAP, PCX or FNT) with
the definition of the {256 colors} which are shown on screen.

At this moment, the game will be shown with the correspondence of colors that 
indicates the palette.

If in the moment of loading the palette, the program has another different, then a 
fade to black of the colors will be done and after that, the new palette will be
introduced in the next frames.

The access to the archive can be specified with the palette;
but, if the file is in the default directory (depending of the type
of archive this will be : \PAL, \FPG, \MAP, \PCX o \FNT) it won't be necessary.

The program will read the palette automatically of the first of these types
of archives loaded in the program, though the function {load_pal()} is not used. 
So, this function is used when the program uses some different palettes to change
from one to another.

{#9999,Example program:}
PROGRAM example_load_pal;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 160, 0, 1, "Press [SPACE] to load a different palette.");
    write(0, 160, 10, 1, "Press [ENTER] to load the original palette.");
    LOOP
        IF (key(_space))

            load_pal("help\help.pal"); // The palette of a file .pal is loaded

        END
        IF (key(_enter))

            load_pal("help\help.fpg");  // The palette of a file .fpg is loaded

        END
        FRAME;
    END
END
{-}

In the example, at the beginning a graphic file is loaded, appears a backgroud
and the necessary messages are printed.

In the main loop of the program is loaded a different palette (of {help.pal})
when is pressed the space bar and the original palette (of {help.fpg})
When is pressed the ENTER key.

{/}

A palette can't be deleteed from the memory of the computer, because this 
doesn't fill memory space.

{/}See: {#174,load_map/pcx()} - {#132,load_fpg()} - {#131,load_fnt()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.134,load_pcm() / load_wav()}

{load_pcm(}<name of the archive>{,} <ciclic>{)}

{load_wav(}<name of the archive>{,} <ciclic>{)}

{Return:}

The {sound code} loaded.

{Description:}

Loads a sound effect of an archive PCM or WAV of the disk. It must be indicated
the name of the archive with the sound effect as first parameter and in
<ciclic>, as second parameter, {1} if it is a sound that must be played
replaying it indefinitely, or {0} if it must be played just one time (when it is
demanded with the function {#159,sound()}).

The function gives back the {sound code} that must be used by
the function {#159,sound()} to make the sound to be played through one channel.

An access route can be specified to the sound archive, but if the sound
is in the default directory (\PCM o \WAV) it won't be necessary.

{#9999,Example program:}
PROGRAM example_load_pcm;

PRIVATE
    id_sonido;

BEGIN

    id_sonido = load_pcm("help\help.pcm", 0); // Loads a sound of the hard disk

    write(0, 160, 0, 1, "Press [SPACE] to play the sound.");
    LOOP
        IF (scan_code==_space)
            sound(id_sonido, 100, 256);
        END
        FRAME;
    END
END
{-}

In the example, first, a sound is loaded with the function {load_pcm()}.
After that, in the main loop, each time that the space bar is pressed
the sound is played with the function {#159,sound()}.

{/}

The functions {#170,unload_pc{code of the sound} to know which sound is the one that is
going to be deleted from memory()} and {#170,unload_wav()} allows to delete the sound 
from the computer memory when it is not going to be used again and, to do this, 
the program requires too the {code of the sound}.

{It is not necessary to delete the sound from memory} before finish the
program, because the system will do it automatically.

{/}See: {#170,unload_pcm/wav()} - {#159,sound()} - {#102,change_sound()} - {#1104,Setup estructure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.135,map_block_copy()}

{map_block_copy(}<file>{,} <graphic destination>{,} <x destination>{,} <y destination>{,}
                 <graphic origin>{,} <x>{,} <y>{,} <width>{,} <high>{)}

{Description:}

The function {map_block_copy()} allows to transfer a rectangular block from
one graphic to another.

The graphic from which is taken the rectangular region will be denominated
<graphic origin> and the {graphic destination} is the one in which is going to be copied
the block, this function allows to copy a part of a graphic
(origin) in other (destination). The parameters are, in order, the following:

{<file>} - Both graphics must come from the same file of graphics.
As first parameter must be specified the {code file} (see
{#132,load_fpg()}). The graphics loaded with the functions {#174,load_map()}
or {#174,load_pcx()} (or created with {#188,new_map()}
will be used as if they were from the first file (the file file with the
code 0).

{<graphic destination>} - {code of the graphic} the block is going to be put inside of it.

{<x destination>, <y destination>} - coordinates ({x}, {y}) in which is going to be put the block, 
inside of the graphic destination.

{<graphic origin>} - {code of the graphic} the one where is going to be taken the block.

{<x>, <y>} - coordinates of {beginning} of the block inside of the graphic origin.

{<width>, <high>} - {dimensions} of the block which is going to be transfered.

This function will modify the indicated graphic, just it's copy which has been
loaded in the computer memory. The graphic origin, which is in the archive 
{FPG}, {MAP} or {PCX} of the disk, {won't be modified).
For that if you want, in a moment of the game, recover the original state of the
graphic, it must be deleted from memory (with {#169,unload_fpg()},
{#176,unload_map()} or {#176,unload_pcx()}) and then, load it again.

{#9999,Example program:}
PROGRAM example_map_block_copy;

PRIVATE
    x_destino, y_destino;
    x_origen, y_origen;
    ancho, alto;
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 320);
        y_destino=rand(0, 200);
        ancho=rand(1, 32);
        alto=rand(1, 32);
        x_origen=rand(0, 32-ancho);
        y_origen=rand(0, 32-alto);

        map_block_copy(file1, 1, x_destination, y_destination, 100, x_origin, y_origin, width, high);

        FRAME;
        angle+=1000;
    END
END
{-}

In the example, after being loaded the file of graphics and being put one
(the graphic number 1) the center of the screen will rotate continously.
In the main loop, will be copied the graphic of a ball (the graphic
number 100) inside of the graphic destination (the number 1) in random coordinates.

{/}

When a graphic is put inside of another that is being used as background
for a region of the scroll, this one won't appear automatically on screen if 
the function {#152,refresh_scroll()} is not used.

{/}See: {#139,map_xput()} - {#137,map_put()} - {#138,map_put_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.136,map_get_pixel()}

{map_get_pixel(}<file>{,} <graphic>{,} <x>{,} <y>{)}

{Return:}

The color of the point (0..255).

{Description:}

Allows to obtain, as return value of the function, the color of a determined 
point of a graphic. To do this, is required the <code of the file> in which
can be found the graphic, the <code of the graphic> inside of the file and the
coordinates ({x}, {y}) of the point of the graphic which color is wanted. 

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the 
first file (the file with the code 0).

{#9999,Example program:}
PROGRAM example_map_get_pixel;

PRIVATE
    file1;
    figura;

BEGIN
    file1=load_fpg("help\help.fpg");
    put_screen(0, 7);
    mouse.graph=200;
    write(0, 0, 0, 0, "FIGURE:");
    write_int(0, 42, 0, 0, offset figure);
    LOOP

        // We take the color of the bitmap point
        figura = map_get_pixel(file1, 8, mouse.x, mouse.y);

        FRAME;
    END
END
{-}

In the example is used as background an image with 6 different geometric figures, 
everyone with the same color, and the graphic of the mouse is defined
as a small cross.

The background image corresponds with other graphic, the number 8 of the
file, which has the same figures, but, each one with a different color
(the first with the color 1, the second with the color 2, etc.).

In the main loop the color of this second graphic will be taken with the
function {map_get_pixel()}, of the coordinates shown by the mouse cursor.

In the upper left corner of the screen the value obtained with the
function, which is a number from 1 to 6 that indicates the number of
figure.

{/}

This function is used to detect zones inside of graphics.
This technic is denominated {maps of hardness} and consists in the use of two
different graphics, one with the picture and the other one with the zones
to be detected, painted with different colors.

For example, in a game of spaceships, the zones of the screen that hurts our spaceship {map of hardness}
could be painted with a color (for example, the color 32); then would be obtained the color of the
{map of hardness} over the zone that is the spaceship, if it is 32, the spaceship will be hurt.

Would be two different pictures: one in colors, which is the background picture
over the spaceship is moving in the game (the visible one), and other,
the {map of hardness} that would be used just to obtain colors of it with the function
{map_get_pixel()} and, in this way, identify the zone of the original picture where is the 
spaceship.

{/}See: {#123,get_pixel()} - {#138,map_put_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.137,map_put()}

{map_put(}<file>{,} <graphic destination>{,} <graphic origin>{,} <x>{,} <y>{)}

{Description:}

Puts a graphic into another. The graphic which is going to be copied is called
<graphic origin> and the {graphic destination} is the one where is going to be copied the
origin. This function allows to copy a graphic (origin) into another (destination).

Both graphics must be in the same file. The parameters are, in order, 
the following:

{<file>} - {code of the file} with the collection of graphics that contains
both. The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the file with the code 0).

{<graphic destination>} - {code of the graphic} here is going to be copied the origin.

{<graphic origin>} - {code of the graphic} which is going to be copied in the destination.

{<x>, <y>} - {coordinates inside of the graphic destination} where is going to be put the
graphic origin. In these coordinates is where is going to be changed the center 
(or {#1136,checkpoint} number 0) of the graphic origin.

This function will modify the indicated graphic, but just the copy of itself
which has been loaded in the computer memory. The graphic original, which
is in the archive {FPG}, {MAP} or {PCX} of the disk, {won't change}.
If you want in a moment of the game, recover the original state of the
graphic it must be deleted from memory (with {#169,unload_fpg()},
{#176,unload_map()} or {#176,unload_pcx()}) and then load it again.

{#9999,Example program:}
PROGRAM example_map_put;

PRIVATE
    x_destino;
    y_destino;
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 320);
        y_destino=rand(0, 200);

        map_put(file1, 1, 100, x_destination, y_destination);

        angle+=1000;
        FRAME;
    END
END
{-}

In the example the graphic number 1 is positioned in the center of the screen.

In each step of the main loop, the graphic rotates and is positioned, with the
function {map_put()}, a graphic number 100 (a ball) inside of the graphic 1
(the central graphic).

{/}

The function {#139,map_xput()} is a version a bit more complicated of the
function {map_put()}, but with many more possibilities, because allows, besides,
to put graphics rotated, escalated, transparent or mirrored.

To put a part of a graphic into another (instead of put the complete graphic) 
the function {#135,map_block_copy()} must be used.

{/}

{Note:} When the function {map_put()} is used (or any other similar)
to modify a graphic that is being used as background of a {scroll} window, 
it could be that the graphic doesn't appear immediately on screen; 
to fix this problem, the function {#152,refresh_scroll()} must be used.

{/}See: {#139,map_xput()} - {#138,map_put_pixel()} - {#152,refresh_scroll()} - {#135,map_block_copy()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.138,map_put_pixel()}

{map_put_pixel(}<file>{,} <graphic>{,} <x>{,} <y>{,} <color>{)}

{Description:}

Allows to modify the color of one determined point of a graphic.
To do this, is required the <code of file> in which is found the coordinate
of the graphic, the <code of the graphic> inside of the file and the 
coordinates ({x}, {y}) of the point which <color> is going to be established.

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the file with the code 0).

This function will modify the indicated graphic, but just the copy of itself
which has been loaded in the computer memory. The original graphic, which
is in the archive {FPG}, {MAP} or {PCX} of the disk, {won't change}.
If you want in a moment of the game recover the original state of the
graphic, you must delete it from memory (with {#169,unload_fpg()},
{#176,unload_map()} or {#176,unload_pcx()}) and after that, load it again.

{#9999,Example program:}
PROGRAM example_map_put_pixel;
PRIVATE
    file1;
    coord_x;
    coord_y;
    color;

BEGIN
    file1=load_fpg("help\help.fpg");
    graph=5;
    x=160;
    y=100;
    size=180;
    LOOP
        coord_x=rand(0, 199);
        coord_y=rand(0, 199);
        color=rand(0, 15);

        // Points are placed in the graphic number 5 of the file1
        map_put_pixel(file1, 5, coord_x, coord_y, color);

        angle+=2000;
        FRAME;
    END
END
{-}

In the example, the graphic number 5 is placed in the center of the screen
rotating continously; this graphic is a background completely black. Due to this,
at the beginning won't appear anything on screen.

But after this, in each step of the loop a random color between 0 and 15 (greys) 
is place in the point, in random coordinates.

These points are placed using the function {map_put_pixel()}.

You can see how looks like that each time appear more and more points rotating
on screen when, actually, the only thing that rotates is the graphic number 5.

{/}

To place a complete graphic inside of another, and not only in one point, you can 
use the functions {#137,map_put()} or {#139,map_xput()}, and to place just a part
of a graphic into another the function used should be {#135,map_block_copy()}.

{/}

{Note:} When the function {map_put_pixel()} is used to placed a point in a 
graphic that is being used as background of a {scroll} window, it could be 
that the point doesn't appear on screen inmediately; to fix the problem
you must use the function {#152,refresh_scroll()}.

{/}See: {#137,map_put()} - {#139,map_xput()} - {#152,refresh_scroll()} - {#135,map_block_copy()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.139,map_xput()}

{map_xput(}<file>{,} <graphic destination>{,} <graphic origin>{,} <x>{,} <y>{,}
           <angle>{,} <size>{,} <flags>{)}

{Description:}

Extended version of the function {#137,map_put()}.

Places a graphic into another. The graphic which is going to be copied is called
<graphic origin> and the {graphic destination} is the one where is going to be copied the
origin. This function allows to copy a graphic (origin) into another (destination).

Both graphics must be in the same file. The parameters are, in order, 
the following:

{<file>} - {code of the file} with the collection of graphics that contains
both. The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the file with the code 0).

{<graphic destination>} - {code of the graphic} here is going to be copied the origin.

{<graphic origin>} - {code of the graphic} which is going to be copied in the destination.

{<x>, <y>} - coordinates inside of the graphic destination where is wanted to place the
graphic origin. In these coordinates is where is going to be copied the graphic origin
from the upper left corner.

{<angle>} - angle (in thousandths of degree) in which can be copied the graphic origin.
The normal angle is {0}.

{<size>} - size (in percentage) in which is wanted to be copied the original graphic, the
normal size is {100}.

{<flags>} - Indicates the mirrors and transparences that will have the original graphic when copied
into destination; the values are:

 {0}-Normal graphic.ú
 {1}-Horizontal mirror.ú
 {2}-vertical mirror.ú
 {3}-Horizontal and vertical mirror (180ø).ú
 {4}-Transparent graphic.ú
 {5}-Horizontal transparence and mirror.ú
 {6}-vertical Transparence and mirror.ú
 {7}-Transparence, horizontal and vertical mirror.ú

This function will modify the indicated graphic, but, just the copy of itself
which has been loaded in the computer memory. The original graphic, which
is in the archive {FPG}, {MAP} or {PCX} of the disk, {won't be change}.
Due to this, if is wanted in a moment of the game to recover the original
state of the graphic it must be deleted from memory (with {#169,unload_fpg()},
{#176,unload_map()} or {#176,unload_pcx()}) and after that load it again.

{#9999,Example program:}
PROGRAM example_map_xput;
PRIVATE
    x_destino;
    y_destino;
    file1;
    ángulo1;
    tamaño1;
    banderas1;

BEGIN
    file1=load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 319);
        y_destino=rand(0, 199);
        ángulo1=rand(-pi, pi);
        tamaño1=rand(10, 200);
        banderas1=rand(0, 7);

        map_xput(file1, 1, 101, x_destination, y_destination, angle1, size1, flags1);

        angle+=2000;
        FRAME;
    END
END
{-}

In the example, the graphic 1 is placed in the center of the screen rotating
continously (this graphic is a decorative background of greys).

In each step of the loop will be placed inside of it another graphic  with a 
triangle shape (with the number 100). This graphic will be placed with coordinates,
angle, size and flags (see variable {#1127,flags}) chosen randomly.

It can be seen how in the background graphic appear continously
brown triangles with different effects on them.

{/}

The function {map_xput()} is a version a bit more complex of the
function {#137,map_put()}, being this one the easiest to use when
is not required to placed graphics rotated, mirrored or transparent.

To place a part of a graphic into another (instead of place the entire
graphic) the function {#135,map_block_copy()} must be used.

{/}
{Note:} When the function {map_put()} (or any other similar) is used to 
modify a graphic that is being used as background of a {scroll} window, it
could be that the graphic doesn't appear inmediately on screen; to fix
this problem, the function {#152,refresh_scroll()} must be used.

{/}See: {#137,map_put()} - {#138,map_put_pixel()} - {#152,refresh_scroll()} - {#135,map_block_copy()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.140,move_scroll()}

{move_scroll(}<number of scroll>{)}

{Description:}

Forces to move an automatic scroll immediately. This function is a bit
advanced and due to that it's purpose could be of difficult learning.

The function requires as parameter the <number of scroll> from 0 to 9 which was
indicated in the function {#163,start_scroll()} as first parameter when the
scroll started.

This function is used when a region of scroll is controlled
automatically, for being defined the field {camera} of the
{#1101,estructure scroll} related with the identifier of a
process.

The purpose is to force the values ({x0}, {y0}, {x1} and {y1}) of the
estructure for being updatad; if the function is not used these values won't
be updated until the next image of the game.

When a scroll is controlled automatically and other process
needs to know before of the next image of the value of coordinates
of the scroll (normally to placed itself in a position keeping with
the movement of the background) what is necessary to do is:

{1} - The scroll is started with {#163,start_scroll()}.

{2} - The process that will be used as camera is created and is given it's
{#1039,identifier code} in the field {camera} of the {#1101,estructure
scroll}.

{3} - This process must has a very high priority, to being executed before
the other processes (placing in it's local variable {#1121,priority} an entire 
positive value, for example, 100).

{4} - Just before of the statement {#1029,FRAME} of the process loop used
as camera the function {move_scroll()} will be called.

In this way will be guarantized that this process will be executed the first
and just at the finish, the values ({x0}, {y0}, {x1} and {y1}) of the
{#1101,estructure scroll} be updated, so, the rest of the processes can
use these variables already updated.

The most generalized use of this function is when in a scroll window is wanted
to have more than two background planes and, to that, a group of processes
that simulate that a third or fourth plane are created, placing their coordinates
depending of the exact position of the scroll in each image. The following program
shows how it is done.

{#9999,Example program:}
PROGRAM example_move_scroll;

PRIVATE
    file1;
    contador;

BEGIN
    set_fps(100, 0);
    file1=load_fpg("help\help.fpg");
    start_scroll(0, file1, 103, 102, 0, 15);
    scroll.camera=id;
    priority=100;
    FROM contador=-2000 TO 2000 step 100;
        process_mobile(counter);
    END
    write(0, 160, 0, 1, "Use the cursor right and left to move");
    graph=101;
    ctype=c_scroll;
    LOOP
        if (key(_right))
            x+=2;
            flags=0;
        END
        if (key(_left))
            x-=2;
            flags=1;
        END

        move_scroll(0); // Actualize the scroll estructure[]

        FRAME;
    END
END

PROCESS process_mobile(x_scroll)
BEGIN
    ctype=c_scroll;
    z=100;
    graph=104;
    LOOP
        x=x_scroll-scroll.x0;
        FRAME;
    END
END
{-}

This example starts a full screen scroll with two planes and then
moves a triangle from right to left with the cursor; this process will be
the scroll camera, centering the vision in the same automatically 
(writing {scroll.camera=}{#1092,id}{;}).

But, besides, it creates a total of 40 processes (from -2000 to 2000, each 100 points)
with the picture of a vertical colored line that will move as it should be
a third scroll plane (processes of type {process_mobile}).

To this, is important for it's {z} to be superior to the rest of the processes
({z=100;}) and that the priority of the process that controls the camera is bigger
({priority=100;}) and this last one uses the function {move_scroll()} before
of each image ({FRAME;}).

The processes that simulate the third plane ({mobile_process}), place their
coordinate {x} in correspondence with the {x of the scroll} and it's original position.

The diference is that if were not used {move_scroll()}, when were used 
the processes, the variable {scroll.x0} without being updated, would move
with a certain delay that wouldn't give realism to the game.

{/}See: {#163,start_scroll()} - {#1101,Estructure scroll} - {#1121,priority} - {#1125,z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.141,move_text()}

{move_text(}<text identifier>{,} <x>{,} <y>{)}

{Description:}

Moves a text to other coordinates of screen. Is specified as parameter
the {text identifier} which is a numeric code that gives back the functions
{#171,write()} and {#172,write_int()} when is asked to write a text
and the coordinates ({x}, {y}) of the screen which are going to move the
text.

The {code of centre} specified in the {#171,write()} or {#172,write_int()}
will stay when this function is used.

The specified coordinates are always relative to the screen and can
stay inside or outside of itself. To modify the {coordinate z of the
texts} (the plane of depth in which the texts appear) the
global variable {#1106,text_z} must be used.

{#9999,Example program:}
PROGRAM example_move_text;

PRIVATE
    id_texto1;
    id_texto2;
    coord_x;
    coord_y;
    ángulo1;

BEGIN
    id_texto1=write(0, 160, 100, 4, "TEXT MOVING");
    id_texto2=write(0, 160, 100, 4, "MOVE THE MOUSE");
    LOOP
        coord_x=160+get_distx(angle1, 100);
        coord_y=100+get_disty(angle1, 90);

        // We move the texts
        move_text(id_texto1, coord_x, coord_y);
        move_text(id_texto2, mouse.x, mouse.y);

        ángulo1+=1000;
        FRAME;
    END
END
{-}

In the example are printed two texts with the function {#171,write()} in
the center of the screen. This function give us back the identifiers
of these texts, which are saved in the variables {id_texto1} and {id_texto2}.

In each step of the loop, the first text moves in a circular way which is done
incrementing an angle ({angulo1}) and using the functions {#118,get_distx()}
and {#119,get_disty()}. The second text will be placed in the coordinates
of the mouse cursor.

Both texts start to move in each image with the function {move_text()}.

{/}

To delete a text definitely is required to the {text identifier}, 
and it must be used to do this the function {#107,delete_text()}.

{/}See: {#171,write()} - {#172,write_int()} - {#107,delete_text()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.142,near_angle()}

{near_angle(}<angle>{,} <final angle>{,} <increment>{)}

{Return:}

A new angle nearer to the final angle.

{Description:}

Approaches an angle up to another in the given increment. The function gives
back the new angle.

This is used when is wanted that an angle (<angle>) change gradually to
change into another (<final angle>); to do this, the function needs the
original angle, the {final angle} and the {increment} which will be
added or substracted from the original angle.

Remember that every angle is specified in thousandths of degree. The
{increment} is a small angle of one degree ({1000}) or five ({5000}).

{#9999,Example program:}
PROGRAM example_near_angle;

PRIVATE
    ángulo2;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    mouse.graph=200;
    graph=101;
    write(0, 160, 200, 7, "Move the cursor of the mouse");
    LOOP
        ángulo2=fget_angle(x, y, mouse.x, mouse.y);

        // Approaches the current angle to the final one in 10 degrees as maximum
        angle = near_angle(angle, ángulo2, 10000);

        advance(6);
        FRAME;
    END
END
{-}

In the example is defined the cursor of the mouse as an small cross that the
user can move.

The main program defines it's graphic as a triangle ({graph=101;})
which, in each iteration of the loop, obtains the angle to the cursor of the mouse
with the function {#113,fget_angle()}; then, modifies it's angle to approach it
to a maximum of 10 degrees (10000) the angle of the cursor
using the function {near_angle()} and, finally, advances 6 points in that
direction using the function {#101,advance()}.

You can see how the triangle chase continously the cursor of the mouse
without turns around (more than 10 degrees).

{/}See: {#1044,Use of the angles in the language} - {#1129,angle} - {#116,get_angle()} - {#113,fget_angle()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.143,out_region()}

{out_region(}<identifier code>{,} <number of region>{)}

{Return:}

{True} if the process is outside of the region or {False} in the opposite case.

{Description:}

This function determines if a process is outside of the screen region, to do this,
the function requires the {#1039,identifier code} of the process and a number of
region.

The screen regions can be defined with the function {#106,define_region()}
and they are rectangular zones of the screen.

The region number {0} can't be defined because it is the entire screen, so, if a
{0} is specified as second parameter, this function finishes if a process is outside
of the screen (if it can't be seen).

In case that the graphic of the process is out of the specified region
the function gives back {True} (an odd number); but if the graphic is seen,
also partially, in the region, the function gives back {False} (any even number).

The process which {#1039,identifier code} is indicated must have defined correctly it's
graphic (normally in it's variable {#1026,graph}) because, if it isn't, the system can
gives an error because if the process hasn't any graphic, the dimensions of itself can't
be calculated.

{#9999,Example program:}
PROGRAM example_out_region;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    y=100;
    x=160;
    graph=101;
    LOOP
        advance(8);

        IF (out_region(id, 0)) // Is checked if it goes out of the screen

            x=160;
            y=100;
            angle=rand(-pi, pi);
        END
        FRAME;
    END
END
{-}

In the example, a background is placed and the main program creates in the center
of the screen a random angle and with a triangle form.

In each step of the loop, the triangle advances and is checked if it has gone out
of the screen (region 0) with the function {out_region()}. If it has gone out
of the screen, is placed again in the center with another angle, chosen randomly.

{/}See: {#106,define_region()} - {#1130,region} - {#1039,codes identifieres}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.144,play_cd()}

{play_cd(}<number of track>{,} <mode>{)}

{Description:}

Starts playing a cd-audio track. The number of track must be indicated (from 1 to the number of songs the cd has) and the mode is at follows:

{Mode:}

 {0} - play a song and stop when finishes.ú
 {1} - play this song and the following.ú

{#9999,Example program:}
PROGRAM example_play_cd;
BEGIN
    write(0, 160, 0, 1, "Press [SPACE] to turn on the CD.");
    LOOP
        IF (scan_code==_space)

            play_cd(1, 1); // play The 1st. song and the rest.

        END
        FRAME;
    END
END
{-}

In the previous example (for which is necessary to have a {Compact disk} of
music in the {CD-ROM} drive) appears an informative message, in each iteration
of the loop is check if the space bar was pressed to play the first song {play_cd()}

{/}

To get that a song plays indefinitely, a loop must be implemented, using the function {#127,is_playing_cd()} to determinate when has finished the song.

The volume of reproduction of the cd-audio can be controlled with the estructure 
{#1104,setup} and the function {#178,set_volume()}.

{/}See: {#127,is_playing_cd()} - {#164,stop_cd()} - {#178,set_volume()} - {#1104,Estructure setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.145,pow()}

{pow(}<expression>{,} <expression>{)}

{Return:}

The first expression {elevated} to the second.

{Description:}

Calculates the result of elevate the first expression to the second.

For example, {pow(3, 2)} will give back {9}, which is {3} elevated to two,
{3ı}, or {3*3}.

{#9999,Example program:}
PROGRAM example_pow;
GLOBAL
    values[15];
    n;
BEGIN
    FROM n=0 TO 15;
        values[n]=rand(-100, 100);
        write_int(0, 0, n*10, 0, offset values[n]);
    END
    write(0, 0, 192, 0, "Press [SPACE] to elevate these numbers to two");
    LOOP
        IF (scan_code==_space)
            FROM n=0 TO 15;

                values[n] = pow(values[n], 2); // It is elevated to two.

            END
        END
        FRAME;
    END
END
{-}

This program will print on screen a list of numbers randomly selected
between -100 and 100. When the space bar is pressed these numbers will be
elevated to two.

It must be known that in the language {only can be handled entire numbers
inside of the rank} ({#1177,min_int} ... {#1178,max_int}) and for that, when
the result of the fuction exceeds the rank, {incorrect results will be shown}.
In this case, the system won't give any error, for which reason, you must be very
careful with it.

{/}See: {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.146,put()}

{put(}<file>{,} <graphic>{,} <x>{,} <y>{)}

{Description:}

Places a graphic on the background of screen. The function requires the {code of
file} in which is the graphic, the {code of the graphic} inside of the same file
and the coordinates ({x}, {y}) in which is desired to place the graphic.

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the file with the code 0).

If the center of the graphic wasn't specified (establishing it's {#1136,checkpoint}
number 0 from the paint tool), the coordinates will refer to the position of screen
in which will be placed {the center} of the graphic.

The graphics printed in that way on the screen background, will be in the visualization
of the game {under every process, regions of scroll, texts, etc.}

If it's wanted for a graphic to be above of others it must be {created as a new 
process} and fix it's variable {#1125,z} with the priority of impression of itself.

To delete the background of screen the function {#103,clear_screen()} must be used.

{#9999,Example program:}
PROGRAM example_put;

PRIVATE
    file1;
    coord_x;
    coord_y;

BEGIN
    file1=load_fpg("help\help.fpg");
    LOOP
        coord_x=rand(0, 319);
        coord_y=rand(0, 199);

        put(file1, 100, coord_x, coord_y); // The graphic 100 is placed.

        FRAME;
    END
END
{-}

In the example the file with the graphics is loaded and in each iteration of the loop 
the graphic 100 (a ball) is placed with the function {put()} in random coordinates
(chosen randomly with the function {#149,rand()}).

{/}

If the graphic which is wanted to be placed is simply a background screen, it is easier to
use the function {#148,put_screen()}, this one doesn't require the coordinates
of screen because it will center the graphic on it automatically.

{/}

The function {#173,xput()} is a bit more complicated version of the function 
{put()} but with a lot more of possibilities, because allows, besides, to place
rotated graphics, escalated, mirrored and transparents.

To place a graphic inside of another (instead of the background)
the functions {#137,map_put()} or {#139,map_xput()} must be used.

{/}See: {#148,put_screen()} - {#173,xput()} - {#137,map_put()} - {#139,map_xput()} - {#147,put_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.147,put_pixel()}

{put_pixel(}<x>{,} <y>{,} <color>{)}

{Description:}

Establishes the {color} of the point placed in the coordinates ({x}, {y})
of the background. place a point of the indicated color in the indicated
coordinates.

The printed points with this function in the background will be in the visualization
of the game {under of every process, regions of scroll, texts, etc.}

If it's wanted to visualize a point above of the other graphics, a new process must be
created and has asigned as graphic the picture of a point (in it's variable {#1126,graph}) 
and fix it's variable {z} with the priority of printing of itself.

To delete the background the function {#103,clear_screen()} must be used.

{#9999,Example program:}
PROGRAM example_put_pixel;

PRIVATE
    x_punto;
    y_punto;
    color;

BEGIN
    LOOP
        x_punto=rand(0, 319);
        y_punto=rand(0, 199);
        color=rand(0, 15);

        // The points are placed on screen randomly
        put_pixel(x_punto, y_punto, color);

        FRAME;
    END
END
{-}

In the example, in each step of the loop points are placed with the function
{put_pixel()} with coordinates and color selected randomly with the function
{#149,rand()}.

{/}

To read the color that has a determined point of the background the function {#123,get_pixel()}must be used, which will give back a number between
0 and 255 correspondent to the order of the color inside of the palette.

To place a grahic on screen, instead of a simple point, the function {#146,put()}
must be used.

Also is possible to establish the color of a point in a determined graphic, instead of
the background, what can be done with {#138,map_put_pixel()}.

{/}See: {#123,get_pixel()} - {#146,put()} - {#138,map_put_pixel()} - {#136,map_get_pixel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.148,put_screen()}

{put_screen(}<file>{,} <graphic>{)}

{Description:}

Establishes the background of screen. The function requires the {code of the
file} in which is the graphic, and the {code of the graphic} which is wanted
to be printed in the background inside of the file.

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the file with the code 0).

The function doesn't require any coordinate as parameter, because if the graphic
is of a size (in points) different to the one of the screen, it simply will be printed
center on it.

To delete the background of screen the function {#103,clear_screen()} must be used.

{#9999,Example program:}
PROGRAM example_put_screen;

PRIVATE
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");

    put_screen(file1, 1); // The graphic1 is placed as background.

    LOOP
        FRAME;
    END
END
{-}

In the example os loaded the file of graphics and a graphic is placed as background
(which is inside of the file with the code of graphic number 1) with the function
{put_screen()}.

{/}

If is wanted to print a graphic in a certain part of the screen or a graphic
{not centered}, the function {#146,put()} can be used. 
The function {#173,xput()} allows, besides, to print graphics rotated, scalated
mirrored and/or transparents in any region of the screen.

{/}See: {#146,put()} - {#173,xput()} - {#147,put_pixel()} - {#103,clear_screen()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.149,rand()}

{rand(}<minimum value>{,} <maximum value>{)}

{Return:}

A random numeric value.

{Description:}

Gives back a random number (chosen randomly) between the {minimum value} and the
{maximum value}, both included.

This function is used to establish every parameter that is wanted to change 
in a game, from one game to another; for example, the coordinates of an 
enemy can be initialized with random numbers, with this, in each game, 
will appear in a different position.

Oher use of this function is when is wanted that an action doesn't happen
always, if there is no probabilities for it; this is implemented with an
statement of the following type:

  {IF (rand(0, 100)<25)}ú
     { // Action ...}ú
  {END}ú

In this case the {action} would be realized with a 25% of posibilities of the
times that would be executed the statement {#1020,IF}, so, when obtain a random 
number between 0 and 100, this only would be a number fewer than 25.


{#9999,Example program:}
PROGRAM example_rand;

PRIVATE
    tabla[15];
    contador;

BEGIN
    write (0, 0, 192, 0, "Press [SPACE] to find random values.");
    FROM contador=0 TO 15;
        write_int(0, 0, contador*10, 0, offset tabla[contador]);
    END
    LOOP
        IF (scan_code==_space)
            FROM contador=0 TO 15;

                // Random values are chosen between -100 and 100
                tabla[contador] = rand(-100, 100);

            END
        END
        FRAME;
    END
END
{-}

In the example is created a board with 16 data (from 0 to 15). In each
iteration of the main loop is checked if the space bar has been pressed,
and if done, the 16 data if the board are filled with random values from 
-100 to 100, chosen with the function {rand()}.

{/}

By default, in each execution of the program, the given values by the function{rand()} 
will be completly differents. If is wanted for the group of numbers to be always
the same, the function {#150,rand_seed()} can be used, specifying a number, after 
which the group of numbers given by the function {rand()} will be always 
predeterminied.

{/}See: {#150,rand_seed()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.150,rand_seed()}

{rand_seed(}<numeric value>{)}

{Description:}

This function establishes a seed for the generator of random numbers
(the numbers generated by the function {#149,rand()}).

If a seed is established, which can be any entire number inside of the rank 
({#1177,min_int} ... {#1178,max_int}), every number generated with the
the function {#149,rand()} will be the same in each execution of the program.
After being established a seed of origin, the function {#149,rand()} will give 
back a group of number predeterminied to the seed.

{#9999,Example program:}
PROGRAM example_rand_seed;

PRIVATE
    tabla[15];
    contador;

BEGIN
    write (0, 0, 184, 0, "Press [ENTER] to introduce 1234 as seed.");
    write (0, 0, 192, 0, "Press [SPACE] to find random values.");
    FROM contador=0 TO 15;
        write_int(0, 0, contador*10, 0, offset tabla[contador]);
    END
    LOOP
        IF (scan_code==_space)
            FROM contador=0 TO 15;
                tabla[contador] = rand(-100, 100);
            END
        END
        IF (scan_code==_enter)

            rand_seed(1234); // A seed to random is introduce.

        END
        FRAME;
    END
END
{-}

In the example is created a board with 16 data (from 0 to 15). In each iteration
of the main loop, each time that the space bar is pressed the data will be filled 
with random values from -100 to 100 (chosen with the function {#149,rand()}).

And when the ENTER key is pressed, then will be defined the seed of the random
numbers with the function {rand_seed()} as 1234.

It can be seen as each time that the ENTER key is pressed, then, when the space
bar is pressed, always is obtained the same group of random numbers
(17, 94, -38, ...). To each possible seed; This group will be different.

{/}See: {#149,rand()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.152,refresh_scroll()}

{refresh_scroll(}<number of scroll>{)}

{Description:}

This function is used when a graphic has been modified with the functions
{#137,map_put()}, {#139,map_xput()}, {#135,map_block_copy()} or {#138,map_put_pixel()} which
is being used as {background of a region of scroll}, to updata it.

The function requires as parameter the <number of scroll> which was specified
when the scroll begun with the function {#163,start_scroll()}.

When a scroll is modified which is being used as background of a scroll it doesn't
appears automaticaly on screen, but the function must be called for this.

Once modified, the graphic will stay like this during the rest of the execution of the
program, meanwhile the graphic is not deleted from memory (with {#169,unload_fpg()}, 
{#176,unload_map()} or {#176,unload_pcx()}) and loaded again, in which case
the graphic will recover it's normal state.

{#9999,Example program:}
PROGRAM example_refresh_scroll;

BEGIN
    load_fpg("help\help.fpg");
    start_scroll(0, 0, 103, 102, 0, 15);
    scroll.camera=id;
    write(0, 160, 192, 7, "Press [ENTER] to place a graphic in the scroll.");
    write(0, 160, 200, 7, "Press [SPACE] to updata the scroll.");
    LOOP
        IF (scan_code==_enter)
           map_put(0, 103, 100, rand(16, 48), rand(16, 48));
        END
        IF (scan_code==_space)

            refresh_scroll(0); // We refresh the scroll 0.

        END
        x+=2;
        y+=1;
        FRAME;
    END
END
{-}

In the example a scroll (number 0) is created as a scroll of two planes:
the first one with the graphic number 103 and the background plane with the
graphic number 102.

Inside of the main loop a ball will be printed above the graphic 103 
(first plane of scroll) when the ENTER is pressed. But this one won't appear
on screen if the scroll doesn't enter little by little on screen
(with the graphic 103 modified), or the space bar is pressed, 
so the call to the function {refresh_scroll()} will updata the window
of the scroll with the graphic modified.

If in the previous example the function {refresh_scroll()} would be called
just after the {#137,map_put()}, the printed graphics over the first plane
would appear instantly by pressing the space bar.

In the example, each time that a ball is printed, then appear a lot of them;
this is due to the graphic 103, used as first plane in the scroll is a small
graphic and is shown several times, in mosaic, to fill the scroll zone.

{/}

{Note:} It can be seen that if the printed graphic in is a coordinate
out of the screen, won't be necessary to call this function because
the parts of the scroll that enter on screen refresh automaticaly.

{/}See: {#163,start_scroll()} - {#140,move_scroll()} - {#1101,Structure scroll}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.153,reset_fli()}

{reset_fli()}

{Description:}

This function {rewinds} up to the beginning of an animation {FLI/FLC} which
was began with the function {#161,start_fli()}.

After being called this function, the animation will be shown from the beginning
(to see each photogram of the animation the function {#115,frame_fli()}) must be
used).

The use of this function is to be able of stop an animation and to delete it
({#108,end_fli()}) and reload it, and repeat it from the beginning.

If an animationis wanted to be played indefinitely, starting again when it 
finishes, then {it is not necesary to use this function}, because this will
be done automaticaly with {#115,frame_fli()}, if it is called after
being finished the animation.

Only it's possible to have an animation at the same time, due to this won't be
necesary to specify any parameter to this function.

{#9999,Example program:}
PROGRAM example_reset_fli;
BEGIN
    start_fli("help\help.fli", 0, 0);
    write(0, 160, 0, 1, "Press [SPACE] to restart the animation.");
    LOOP
        frame_fli();
        IF (scan_code==_space)

            reset_fli(); // The animation begins

        END
        FRAME;
    END
END
{-}

In the example an animation is loaded with the function {#161,start_fli()} and
then in played indefinitely with the function {#115,frame_fli()}.

In the loop is checked if the space bar is pressed and if this one has been
pressed, it will be restart with the function {reset_fli()}.

{/}See: {#161,start_fli()} - {#115,frame_fli()} - {#108,end_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.154,roll_palette()}

{roll_palette(}<initial color>{,} <number of colors>{,} <increment>{)}

{Description:}

Rotates a group of colors of the palette. This function is used to create effects
of movement in static graphics, as the efect of the running water.

To use this function first must be created some graphics that use a group
of consecutive colors of the original palette, in a continous cicle,
for example, the colors from {0} to {15}, painting something with the colors
0, 1, 2, 3, ... , 14, 15, 0, 1, 2, ...

After that, you must be careful that these colors won't be used by other 
graphics that appear on screen at the same time, if you don't want to have
the same effect on them.

The {increment} (third parameter) use to be {1} to realize the rotation
in a direction and{ -1} to realize it in another, but other values can be
used to realize the cicle of values faster.

To realize a cicle of the colors from {0} to {15}, {0}would be specified
as <initial color> and {16} as <number of colors>.

{#9999,Example program:}
PROGRAM example_roll_palette;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 2);
    write(0, 160, 0, 1, "Press [SPACE] to rotate the entire palette.");
    LOOP
        IF (scan_code==_space)

            roll_palette(0, 256, 1); // The 256 colors are rotated.

        END
        FRAME;
    END
END
{-}

In the example is placed as background a multicolor screen and inside of the
main loop of the program the 256 colors of the palette will rotate each time
that the space bar is pressed.

{/}

If is wanted to determinate the palette which is going to realize the cicle
of color, this must be loaded from an archive with the function 
{#133,load_pal()}.

{/}

To realize other effects of palette, without changing one color for another
in cicles, the function {#110,fade()} must be load, which allows to realize
multiple fades and saturations of color at different speeds.

Two simplified versions of this last function exist that allow to realize a 
fade to black ({#111,fade_off()}) and undo it ({#112,fade_on()}).

{/}See: {#179,set_color()} - {#133,load_pal()} - {#110,fade()} - {#111,fade_off()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.155,save()}

{save(}<name of the archive>{,} <OFFSET data>{,} <sizeof(data)>{)}

{Description:}

It saves a block of data from the memory of the program to an archive in the disk
to recover them after, when is required, with the function {#130,load()}.

For that, the function requires the {name of the archive}, the movement inside of the
computer memory of the variable, board or structure saved in the disk
(the movement of the data is obtain with {#1085,OFFSET} {<name of the data>})
and the number of positions of memory that it takes (which can be obtained
with {#1094,sizeof}{(<name of the data>)}).

Is possible to save some data (variables, boards or structures) if these
have been defined inside of the same section ({#1006,GLOBAL}, {#1007,LOCAL}
or {#1008,PRIVATE}) consecutively; in this case it must be indicated as
{second parameter} the {#1085,OFFSET} of the first data, and how {third
parameter} the addition of the {#1094,sizeof()} of every data.

It is not necesary to specify an access route with the name of the archive.

{#9999,Example program:}
PROGRAM example_load;

PRIVATE
    tabla[9];
    contador;

BEGIN
    write (0, 0, 0, 0, "Press [ENTER] to delete the data.");
    write (0, 0, 10, 0, "Press [SPACE] to load the data from disk");
    write (0, 0, 30, 0, "Current values of the data:");
    FROM contador=0 TO 9;
        tabla[contador]=rand(0, 100);
        write_int(0, 0, 40+(contador*10), 0, offset tabla[contador]);
    END

    save("help\help.dat", offset tabla, sizeof(tabla)); // The archive is saved.

    LOOP
        IF (key(_enter))
            FROM contador=0 TO 9;
                tabla[contador]=0;
            END
        END
        IF (key(_space))
            load("help\help.dat", offset tabla);
        END
        FRAME;
    END
END
{-}

At the beginning of the example a board of 10 positions (from 0 to 9) 
is created with random values. This board is saved in the disk with the
function {save()}.

When the ENTER key is pressed every value of the board is deleted (the 10
positions are put to 0).

When the space bar is pressed the values of the board are loaded from the
disk with the function {#130,load()}.

{/}

To save in the same archive {tabla[9]} and the variable {contador} should
called to the function {save()} in the following way:

  {save("help\help.dat", offset tabla, sizeof(tabla)+sizeof(contador));}

Not changing the loading instruction ({load("help\help.dat", offset tabla);}), 
because the list doesn't require the number of data.

The value given back by {#1094,sizeof()} to any variable (as {contador})
will be always 1, and for a board the number of positions for itself, so
the statement of saving could be as following (knowing that are going to be saved
11 data, 10 of the board and 1 of the variable):

  {save("help\help.dat", offset tabla, 11);

{/}See: {#130,load()} - {#1085,OFFSET} - {#1094,sizeof()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.156,set_fps()}

{set_fps(}<number of frames per second>{,} <number of allowed jumps>{)}

{Description:}

This function decides the speed of the games; defines the number of frames
per second of the game that will be shown (the number of photograms per second).

The visualization is of 18 frames per second by default, that means that if
a process moves one point per image ({FRAME}), this will move on screen at a
speed of 18 points per second.

This function can fixes the number of frames per second ({FPS}, Frames
per second) between {4} as minimum to {200} as maximum; no more than
24 frames per second are necessary to get a fluid and smooth movement.

The second parameter, {maximum number of allowed jumps}, is how is wanted that
the program behaves when is run in a computer that is enough quick to calculate
the number of frames per second which are asked. As we show now:

{Number of allowed jumps:}

{0} - The game will run with less speed in a slow computer, as many frames per 
second as the computer allows.

{1} - If the computer can't calculate every frame, the game allows to, sometimes,
to leave some frames to try to maintain the relative speed of the game.
The action will be a bit harder, but faster.

{2 or more} - The program allows the game to leave as many consecutive frames as
it is indicated in this parameter to maintain the relative speed of the game.
For example, if it's fixed the number of allowed jumps to {4} and in the game a
process was moving from point to point, in a very slow computer it would move
up to from 4 to 4 points.

{#9999,Example program:}
PROGRAM example_set_fps;

PRIVATE
    imágenes=24;
    saltos=4;

BEGIN
    load_fpg("help\help.fpg");
    graph=1;
    x=160;
    y=100;
    write(0, 0, 0, 0, "Frames per second: Up(+) / Down(-)");
    write_int(0, 0, 10, 0, offset imágenes);
    write(0, 0, 20, 0, "Allowed jumps: Right(+) / Left(-)");
    write_int(0, 0, 30, 0, offset saltos);
    write(0, 160, 200, 7, "Use the CURSORS to change the values.");
    LOOP

        // Is chosen the number of frames per seconds
        set_fps(imágenes, saltos);

        IF (key(_up) AND imágenes<200) imágenes++; END
        IF (key(_down) AND imágenes>4) imágenes--; END
        IF (key(_right) AND saltos<20) saltos++; END
        IF (key(_left) AND saltos>0) saltos--; END
        angle+=4000;
        FRAME;
    END
END
{-}

In the example are printed on screen the necessary messages and the main process
creates a graphic in the center of the screen which rotates indefinitely.

In each step of the loop the cursor keys are detected, the number of frames per
second ({frames}) in changed with {up/down} and the maximum number of allowed
jumps ({jumps}) with {right/left}.

At the beginning of each iteration of the loop the speed according to the values
of both variables, with the function {set_fps()}.

{/}

{Note:} The global variable {#1426,fps} maintain updated the number of 
frames per second which is being reached in the program.

{/}See: {#1029,FRAME} - {#1115,max_process_time} - {#157,set_mode()} - {#1426,fps}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.157,set_mode()}

{set_mode(}<new video mode>{)}

{Description:}

Fix a new video mode to the execution of the game. The standard video modes
that can be specified as parameters are:

  {m320x200}  - VGA standardú
  {m320x240}  - Mode Xú
  {m320x400}  - Mode Xú
  {m360x240}  - Mode Xú
  {m360x360}  - Mode Xú
  {m376x282}  - Mode Xú
  {m640x400}  - SVGA VESAú
  {m640x480}  - SVGA VESAú
  {m800x600}  - SVGA VESAú
  {m1024x768} - SVGA VESAú

{Note:} Besides of these modes (which are used in a lot of adaptors),
exists a global structure denominated {#1415,video_modes} which contains the list
of the detected VESA modes in the video adaptator of the system. These modes also can
be used with the function {set_mode()}.

When a video mode change is done in the game program, automatically a fade to 
black will be done (the color palette of the program) and in the next visualizations
of the game will update the color palette, {set_mode()} will always do a {#111,fade_off()}
just before of change the video mode and a {#112,fade_on()} just after of change it.

every program starts with the mode of 320 per 200 points 
activated ({set_mode(m320x200)}).

{#9999,Example program:}
PROGRAM example_set_mode;

PRIVATE
    modos[]=
        m320x200, m320x240, m320x400, m360x240, m360x360,
        m376x282, m640x400, m640x480, m800x600, m1024x768;
    modovideo=0;

BEGIN
    load_fpg("help\help.fpg");
    write (0, 0, 0, 0, "Press [SPACE] to change the video mode");
    LOOP
        IF (scan_code==_space)
            modovideo=modovideo+1;
            IF (modovideo==10) modovideo=0; END

            set_mode(modos[modovideo]);

        END
        FRAME;
    END
END
{-}

In the example is placed as background an explicative text.

In the iteration of the main loop, if the space bar is pressed, a new
video mode will be activated with the function {set_mode()}.

{/}

{Important:} When is used the function {set_mode()} every scroll or mode7 window activated 
during the game will be eliminated as well as every process being seen on them.

{/}See: {#156,set_fps()} - {#1115,max_process_time} - {#1150,m320x200 ... m1024x768} - {#1415,STRUCT video_modes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.158,signal()}

{signal(}<id>{,} <signal>{)}

{Description:}

Sends a signal to a process (an object of the game). This function is used mainly to 
destroy (kill) a process from other, sending it a signal {#1153,s_kill}.

If you don't know the meaning of process father, son,
{brother}, of an {orphaned} process, etc., then see {#1041,Hierarchy of processes}.

If you don't know the terms live, {dead}, {slept}, etc., refered to processes
, then see {#1040,Process state}

{#9999,Example:}
PROGRAM my_game;
PRIVATE id2;
BEGIN
    id2=my_process();
    // ...
    signal(id2, s_kill);
END
PROCESS my_process()
BEGIN
    // ...
    LOOP
        FRAME;
    END
END
{-}

This program would create a process of type {my_process} and then would be eliminated
with the statement {signal(id2,s_kill)} (id2 is a variable of the main program which
contains the {#1039,identifier code} of the process which is going to be destroyed).

Any process can send a signal to another, if the process has the 
{#1039,identifier code} of the another, see:

  {#1039,Identifier codes of processes}ú
  {#1038,Ways to obtain the identifier code of a process}ú

There are other {types of signals} that can be send to a process,
and they are the following:

{#1153,s_kill} - Order to {kill} a process, the process won't appear in the next
frames of the game.

{#1155,s_sleep} - Order to {sleep} the process, the process will be paralized without
execute it's code and without being visualized on screen (neither can be detected
for the rest of processes), as it would be killed. But the process still exists
in the computer memory (see {s_wakeup}).

{#1156,s_freeze} - Order to {freeze} the process, the process will stand still
without run it's code, but it will be seen on screen, so it can be detected
(in the colissions) for the rest of the processes. The process will exist in
the computer memory though it's code can't be executed (See {s_wakeup}).

{#1154,s_wakeup} - Order to {wake up} the process, brings back to it's normal state
a process previously {slept} or {frozen}; when it has this signal, the process
will be executed again and will be seen normally. A process previously (killed) can't be
turned back to it's normal state, because it doesn't exist in the computer memory.

A process can send to itself too these signal if the {#1039,identifier code} 
of a process is always {#1092,ID} (reserved word in the language to this).
The statement would be the following:

{signal(}{#1092,id}{,} <signal>{)}

Auto-eliminate a process in this way, sending to itself a signal {#1153,s_kill}, can't
destroy the process inmediately, but in the next visualization ({#1029,FRAME}). 
To eliminate a process in an instant way the statement {#1028,RETURN} can be used.

{every signal sent to processes will have effect just before of the next
visualization of the game}, in the next frame ({#1029,FRAME}) of the game (not
immediately).

Besides of these four signals, there are other four that correspond with the
previous and they are: {#1157,s_kill_tree}, {#1158,s_sleep_tree},
{#1160,s_freeze_tree} and {#1159,s_wakeup_tree}.

These signals are used to send, not only to the indicated process, but, besides,
{to every process that would be created by this one}, if a signal
{#1157,s_kill_tree} is sent to a process, to the processes created by this one will be
destroyed, as well as the processes created by seconds.

An exception to these last four signals is when a {orphan process} exists, 
this is, a process which father is already dead.
The orphan processes won't take the signal of this kind of processes, because it's
process father has disappeared, and this one can't send it the signal.

{#9999,Example program:}
PROGRAM example_signal;
PRIVATE
    id_text;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 0, 0, 0, "1 - create the process");
    write(0, 0, 10, 0, "2 - kill the process");
    write(0, 0, 20, 0, "3 - sleep the process");
    write(0, 0, 30, 0, "4 - freeze the process");
    write(0, 0, 40, 0, "5 - wake up the process");
    id_text=write(0, 0, 190, 0, "There is no process");
    LOOP
        IF (key(_1) AND NOT son)
            delete_text(id_text);
            my_process();
            id_text=write(0, 0, 190, 0, "Process alive");
        END
        IF (key(_2) AND son)
            delete_text(id_text);
            signal(son, s_kill);
            id_text=write(0, 0, 190, 0, "There is no process");
        END
        IF (key(_3) AND son)
            delete_text(id_text);
            signal(son, s_sleep);
            id_text=write(0, 0, 190, 0, "Process slept");
        END
        IF (key(_4) AND son)
            delete_text(id_text);
            signal(son, s_freeze);
            id_text=write(0, 0, 190, 0, "Process frozen");
        END
        IF (key(_5) AND son)
            delete_text(id_text);
            signal(son, s_wakeup);
            id_text=write(0, 0, 190, 0, "Proceso alive");
        END
        FRAME;
    END
END

PROCESS my_process()
BEGIN
    graph=100;
    LOOP
        x=160+get_distx(angle, 140);
        y=100+get_disty(angle, 80);
        angle+=5000;
        FRAME;
    END
END
{-}

This program will create with the key {1} a process ({my_process}) which rotates
on screen; with the keys {2} and {5} different signals will be send to this process
using this function. The {#1039,identifier code} of {my_process} is in the local
variable {son} (son) of the main program by default.

When a process is created, the system defines a variable {#1118,son} of the father with the
{#1039,identifier code} of the son, and the variable {#1117,father} of the son, with the
identifier code of the father.

{/}

{signal(}{#1042,TYPE} <name of the process>{,} <signal>{)}

{Description:}

This second acception of the function {signal} is similar to the previous one, with
the exception that, instead of sends a signal to a process from its
{#1039,identifier code}, allows to send a signal {to every process of the
determined type} or to those and their sons if it's used the 
signals as {s_kill_tree} (see: {#1042,Types of processes}).

For example, if in a game exists, or can exists, some processes of the type
{enemy} and is wanted to freeze these processes (without freeze their sons)
The following statement will be used:

  {signal(TYPE enemy, s_freeze);}

As can be seen, to send a signal to a determined process is necessary it's
{#1039,identifier code} and to destroy a group of processes, for these to be
of the same type, or to know every identifier (to send them the signal one by one).

A signal can be send to a type of processes though no process of this type exists 
executing in the game. But if a signal is sent to a process already dead with it's
{#1039,identifier code} (first acception of the statement {signal}), 
it could be that the {#1039,identifier code} is used now by another process, being
this the one which will take the signal. This if, for example, is wanted to kill a 
process already dead, it could be that you would kill another one.

{/}

{Note:} If is wanted to eliminate every process and leave only to the current process, 
the function {#129,let_me_alone()} can be used. This function sends a signal {s_kill} 
to every process, except the one that executed the function.

{/}See: {#129,let_me_alone()} - {#1039,Identifier codes} - {#1042,Types of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.159,sound()}

{sound(}<code of the sound>{,} <volume>{,} <frecuency>{)}

{Return:}

The {number of channel} through which is going to be played the sound.

{Description:}

It play the effect which {code of sound} is specified as first parameter.
First, the sound must be loaded from an archive PCM or WAV with the functions
{#134,load_pcm()} or {#134,load_wav()} which give back the {code of the sound}
that correspond with the effect.

As second parameter, the {volume} which is going to be played the sound must be selected
being {0} the minimum volume and {256} the maximum volume. 

As third parameter will be specified the {frecuency} (speed) which is going to be
played the sound, being {256} the standard frecuency which will play the original sound; 
to fewer values which will reproduce a lower sound, meanwhile that higher values
will play sharper sounds.

The function gives back the {number of channel} which can be used by the functions
{#167,stop_sound()} to stop the sound and {#102,change_sound()} to modify it's volume or
it's frecuency.

Exist a total of 16 sound channels, so up to 16 sounds can be played at the same time.

{#9999,Example program:}
PROGRAM example_sound;

PRIVATE
    volumen=128;        // Valor medio (0..256)
    frecuencia=256;     // Valor medio (0..512)
    id_sonido, canal;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 0, 0, 0, "Volume: Up(+) / Down(-)");
    write_int(0, 0, 10, 0, offset volumen);
    write(0, 0, 20, 0, "Frecuency: Right(+) / Left(-)");
    write_int(0, 0, 30, 0, offset frecuencia);
    write(0, 160, 180, 1, "Press [SPACE] to emit the sound.");
    write(0, 160, 190, 1, "Use the cursors to change the values.");

    id_sonido = load_pcm("help\help.pcm", 0);

    LOOP
        IF (scan_code==_space)

            // It makes it sound
            canal = sound(id_sonido, volumen, frecuencia);

        END
        IF (key(_up) AND volumen<256) volumen++; END
        IF (key(_down) AND volumen>0) volumen--; END
        IF (key(_right) AND frecuencia<512) frecuencia++; END
        IF (key(_left) AND frecuencia>0) frecuencia--; END
        FRAME;
    END
END
{-}

In the example is placed a background and an explicative text, and a sound is
loaded with the function {#134,load_pcm()}; this gives back the
{identifier of the sound}, which is saved in the variable {id_sonido}.

In the main loop, each time that the space bar is pressed, a sound will be
played with the function {sound()} with the defined parameters in the variables
{volume} and {frecuency}.

With the cursor keys you will be able to manipulate these values to understand
better how does it work.

The {number of channel} given back by {sound()}, which is saved in the variable
{channel}, could be used to modify the sound with {#102,change_sound()}
or stop it with {#167,stop_sound()}.

{/}See: {#134,load_pcm/wav()} - {#102,change_sound()} - {#167,stop_sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.160,sqrt()}

{sqrt(}<expression>{)}

{Return:}

The entire square root of the expression.

{Description:}

Calculates the square root of the expression, given as parameter, {truncated to
an entire number}.

For example, {sqrt(10)} will give back as result {3} and not {3.1623} what is a
real value (aproximately) of the square root of ten.

{#9999,Example program:}
PROGRAM example_sqrt;

GLOBAL
    values[15];
    n;

BEGIN
    FROM n=0 to 15;
        values[n]=rand(0, 100000);
        write_int(0, 0, n*10, 0, offset values[n]);
    END
    write(0, 0, 192, 0, "Press [SPACE] to calculate it's square root");
    LOOP
        IF (scan_code==_space)
            FROM n=0 TO 15;

                values[n] = sqrt(values[n]);

            END
        END
        FRAME;
    END
END
{-}

This program will print on screen a list of random values; 
and when the space bar is pressed, the program makes the square root
with the function {sqrt()} to the values.

{/}See: {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.161,start_fli()}

{start_fli(}<name of the archive>{,} <x>{,} <y>{)}

{Return:}

Number of images of the animation

{Description:}

Starts an animation {FLI/FLC} which is in the specified {archive}, in the
coordinates ({x}, {y}) (the upper left coordinate of the visualization window
must be specialized).

In the <name of the archive> the route of access can be specified, without being
necessary if the archive is in the directory of DIV Games Studio 
or in a subdirectory which name is the same of the archive's extension
(for example, "fli\anima.fli").

The animation must be completely on screen, if the animation fills all the screen, 
first must be fixed the video mode with the function {#157,set_mode()} 
and then starts the animation with {start_fli()} in the coordinates (0, 0).

The function gives back, the number of photograms that has the complete animation.

The system will activate automatically the color palettes which could have the
animation {FLI/FLC}, what can gives problems in the presentation of other graphics
or program fonts, if these would be painted with a different palette.

If is pretended to combine other graphic with the animation on screen, this must has
a unique color palette (what is normally denominated ("{palette low FLI/FLC}")
and the graphics must have been painted with this same palette.

Once begun the animation, it´s frames will be shown with the calls to {#115,frame_fli()}.

{Only is possible to have an animation at the same time}, due to this, after
being started an animation with {start_fli()} and being seen with {#115,frame_fli()}, 
it must be finished with the function {#108,end_fli()} before begin another
animation.

{#9999,Example program:}
PROGRAM example_start_fli;
BEGIN

    start_fli("help\help.fli", 0, 0); // An animation begins.

    LOOP
        frame_fli();
        FRAME;
    END
END
{-}

In the example an animation which is inside of the archive {help\help.fli} begins with
the function {start_fli()} in the coordinates (0, 0) and the animation
is played indefinitely.

{/}

The function {#115,frame_fli()} used to show each frame to gives back 0
when the animation has finished, due to that, for the animation to be shown
just one time, it should be done the following:

{#9999,Example program:}
PROGRAM example_start_fli;

PRIVATE
    valor;

BEGIN
    start_fli("help\help.fli", 0, 0);
    REPEAT
        valor=frame_fli();
        FRAME;
    UNTIL (valor==0);
    end_fli();
END
{-}

The function {#153,reset_fli()} allows {to rewind} the animation, for the
function {#115,frame_fli()} to continue playing it from the beginning.

{/}See: {#108,end_fli()} - {#153,reset_fli()} - {#115,frame_fli()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.162,start_mode7()}

{start_mode7(}<number of m7>{,} <file>{,} <graphic>{,} <exterior graphic>{,}
              <number of region>{,} <height of the horizont>{)}

{Description:}

This is an advance function that requires the user has some control of the language
to use it.

It creates a window of mode7 visualization, it shows a graphic
{three-dimensionally} in a brought down plane; to get this effect this function 
will be called with the following parameters:

{<number of m7>} - Up to 10 mode7 windows can be created on screen with
the numbers from {0} to {9}; if you just want to create one, the best is to define
the window {0}. This number will be necessary after to modify the parameters 
of the window, because the system will need to know which one of the {10} 
possible mode7 windows you want to change.

{<file>} - The graphics that you want to bring down in the window must be
in a file which {file code} must be specified right here, as second parameter of the
function. The graphics loaded with the functions
{#174,load_map()} or {#174,load_pcx()} (or created with {#188,new_map()}) 
will be used as if they were from the first file (the file with the
code 0).

{<graphic>} - The third parameter must be the main {code of the graphic}
which is going to be brought down in the window and must belong to the file
previously indicated.

{<external graphic>} - Here you can indicate a {0} if you don't want to see any graphic
beyond of the graphic brought down in the perspective, or a {code
of graphic} of the same file which will be shown in the perspective beyond of the
{main graphic}, until reaches the horizont. This graphic must have a height and 
width potence of 2, not bigger that {8192} (these potences of two are: 
1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 y 8192),
for example, the graphic could be of 64 points wide per 32 high; this
graphic will be shown brought down too.

{<number of the region>} - Here must be indicated the rectangular region of
the screen in which is going to be shown the mode7. If a {0} is indicated as region
number, it will be shown in the entire screen. The other regions must be defined
previously with the function {#106,define_region()} (a {region} it's a rectangular
zone of the screen).

{<height of the horizont>} - As last parameter must be indicated how many points
from the upper part of the window will be the horizont line.
If the camera is placed above the brought down plane, then won't be shown anything above 
the horizont line (that empty space is filled usually with other scroll or mode7 window);
but if the camera is placed under the plane then won't be shown anything under the 
horizont line.

{/}

{Besides of the call to the function must be initialized some values of
the} {#1102,global estructure m7} {to the correct work of the window}.
This is a structure of 10 records (one to each possible mode7 window)
and each record has the following fields:

  {camera}   - {#1039,Identifier code} of the camera
  {height}   - Height of the camera
  {distance} - Distance of the camera
  {horizon}  - Height of the horizont
  {focus}    - Focus of visionú
  {z}        - Plane of depthú
  {color}    - Color of the exteriorú

{Important:} The field {camera} is {essential} to be initialized to activate the
mode7 window because, without this field, the window can't determinate
where must be {seen} the brought down plane.

The camera will be placed in the brought down plane at the indicated distance ({distance})
of the process which {#1039,identifier code} is in {camera}, and looking in the
same angle (the one indicated by the local variable {#1129,angle}).
The height where is placed the camera will be the one indicated in the
field {height}.

You can see the help about the {#1102,estructure m7} to further information about these
fields, or to know how to access to them.

{/}

{#9999,Example program:}
PROGRAM example_start_mode7;

PRIVATE
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");

    start_mode7(0, file1, 4, 0, 0, 64);

    m7.height = 64;
    m7.distance = 32;
    m7.color = 162;
    m7.camera = id;

    write(0, 160, 0, 1, "Use the cursors to move");
    LOOP
        IF (key(_right)) angle-=8000; END
        IF (key(_left)) angle+=8000; END
        IF (key(_up)) advance(6); END
        FRAME;
    END
END
{-}

In the example is loaded the file of graphics and after that is created a 
three-dimensional mode7 with the function {start_mode7()}. This one will have the
following parameters:

{0} - Number of the mode7 windows (the first, because just one window of this type
can be created).

{file1} - Code of the file from which must be taken the graphics; this
is the code of the archive {help.fpg} that was loaded with the function {#132,load_fpg()}.

{4} - Code of the main graphic to bring down inside of the mode7; to see this
graphic must be loaded the file with the {Menu of files} and that way
see which is the graphic with {code 4}.

{0} - Code of secondary graphic, with a 0 won't be secondary graphic (exterior)
in the mode7, so the exterior will have the color indicated in the
variable {m7[0].color}. To see the effect of put an {exterior graphic} you can
change this parameter, for example,by one {100} (which is the code of a brown ball 
of 32 per 32 points in the file {help.fpg}).

{0} - Number of the region of the screen in which must be {placed} the mode7;
with 0 indicates that must be placed in the entire screen.

{64} - Height of the horizont, with this last parameter it's indicated that the
horizont line will be placed 64 points from the upper beginning of the screen.

After call to the function {start_mode7()} the program defines the next values of the
{#1102,global estructure m7}:

{m7.height=64;} - To indicate which camera must be placed 64 points above
the ground.

{m7.distance=32;} - To indicate that the camera must be placed 32 points behind
of the process camera.

{m7.color=162;} - To indicate that the exterior must be seen of the color
number 162 of the palette.

{m7.camera=}{#1092,id}{;} - To indicate that the process camera will be the current process.

The camera will be placed 32 points behind of the main process, 64 points
of height and seeing in the angle that tells the variable {#1129,angle} of 
itself.

After these initiations, the example program will stay in a loop that simply
controls the cursors of the angle ({#1129,angle}) of the main process
that will be the angle of the camera and the key is pressed {cursor up}
the function {#101,advance()} will be called to make the main process
advance 6 points (and the mode7 camera too).

{/}{How to visualize graphics of processes on the mode7}{/}

To create a process which it's graphic can be seen in the mode7, you must
define it's local variable {#1122,ctype} as {#1169,c_m7} ({type of coordinate}
as {mode7 coordinate}), what will be done with the following statement:

  {ctype=c_m7;}

Once this is done, the process will be seen in the mode7 with it's graphic ({#1126,graph})
escalated respecting the distance which it is. The process just must modify its variables
{#1123,x} and {#1124,y} to move on the brought down plane.

{/}

{When a process belongs to the mode7 (the value c_m7 has been asigned to its
local variable} {#1122,ctype}{):}

  - It's variables {#1123,x} and {#1124,y} will be refered to the point of the main 
graphic brought down above which the graphic of the process will be placed.

  - It's variable {#1125,z} will loose its effect, because the graphics will appear
ordenated by depth order. This variable will be useful just to indicate the priorities
of impression in graphics placed, exactly, in the same depth of the plane.

  - The process will be automatically eliminated when is eliminated the program
of mode7 which the process belongs, with the function {#165,stop_mode7()},
or when the video mode changes with the function {#157,set_mode()}, because
when it is done will be eliminated the mode7 windows too.

{/}

If there are some {mode 7} windows, the process will be seen by default
in every window, if it must be seen just in some of them, the local variable
{#1134,cnumber} should be defined. For example, if there are 6 mode7 windows
(from the number 0 to the 5) and is wanted that for a process to visualize it
just in the windows 0 and 2, what must be included in the following statement is:

  {cnumber=c_0+c_2;}

{/}

For a process to have some graphics (some views), depending
of the angle from it is being seen, it's graphic must be defined with the
local variable {#1132,xgraph} (instead of the variable {#1126,graph}).
To define this variable first a board (of any name) must be created
indicating first the {number of views} of the graphic and then, the
{codes of the graphics} to these views, beginning with the {angle
0} and in the opposite way of the clock direction. For example:

  {GLOBAL}ú
    {car_views[]=4, 100, 101, 102, 103;}ú

The board {car_views} would define 4 views: the graphic 100 to the angles
next to 0 degrees, the graphic 101 to the angles next to 90 degrees,
the 102 to angles next to 180 degrees, etc.

and then, the code of the process would initialized the variable
{#1132,xgraph} with the following statement:

  {xgraph=OFFSET car_views;}

To see an example of this, the best is to examinate any of the examples of
DIV Games Studio which use this technic, for what you can do is to execute 
directly one of this programs (for example see {Speed for dummies}).

{/}See: {#165,stop_mode7()} - {#1102,Estructure m7}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.163,start_scroll()}

{start_scroll(}<number of scroll>{,} <file>{,} <graphic>{,} <background graphic>{,}
               <number of region>{,} <indicator of blocking>{)}

{Description:}

This is a function of certain dificulty, it's required some domination 
(to have done some programs before) to use it.

It creates a scroll window, in which is realized a view over a background graphic
(the game scenario). Using as background of the game a graphic, bigger than the
window of visualization, a part of itself will be shown and you will be able to move
in any direction to see it completely.

To get this effect, the function will be called with the following parameters:

{<number of scroll>} - Up to 10 scroll windows can be created on screen, with
the numbers from {0} to {9}; if just is wanted to create one, the best thing is to define
the number {0}. This number will be necesary after to modify the parameters of the window, 
because the system will need to know which of the {10} possible scroll windows is wanted to
be changed.

{<file>} - The graphics which are wanted to be shown as background or as scenario
in that window must be in a file which {code of file} must be specified here,
as second parameter of the function. The graphics loaded with the functions
{#174,load_map()} or {#174,load_pcx()} (or created with {#188,new_map()}) 
will be used as if they were from the first file (the file with the code 0).

{<graphic>} - The third parameter must be the {code of the main graphic} which is going
to be shown as background of the screen and must belong to the file previously
indicated. This graphic use to be the main scenario of the game over which everything
happens, a graphic bigger than the window of visualization,which will move in one
or some directions and over which will be placed the game's graphics.

The scroll window will be placed at the beginning with the {#1136,checkpoint}
number {0} of this graphic in the upper letf corner, when is defined this point
in the {graphic editor}.

{<background graphic>} - Here will be indicated a {0} if just is wanted a plane of scroll
(just one background graphic), or another {code of graphic} if is wanted for this to
appear as second plane of scroll (deeper), behind of the main plane. For this plane
to be seen is necesary that the {main graphic} (first plane) has some parts drawn
with the color number 0 of the palette, because these transparent zones will be which
allow to see through the {background graphic}.

{<number of region>} - Here will be indicated the rectangular region of the screen
in which is going to be shown the scroll, if a {0} is indicated as number of region,
it will be shown on the entire screen. The other regions must be defined
previously with the function {#106,define_region()} (a {region} is a rectangular
zone of the screen).

{<indicator of blocking>} - Here will be indicated a value which defines if each one
of the two scroll planes is ciclic in horizontal and vertical. For example,
a plane is ciclic in horizontal when it goes out of the screen through the right,
appears the picture through the left. To make this value the following quantities 
must be added:

 { + 1} - If the first plane is ciclic horizontally.ú
 { + 2} - If the first plane ciclic vertically.ú
 { + 4} - If the second plane is ciclic horizontally.ú
 { + 8} - If the second plane is ciclic vertically.ú

So, {0} if any of the two planes must be ciclic, {15} ({1}+{2}+{4}+{8})
if both planes must be ciclic in both axis, {12} ({4}+{8}) if just must be
ciclic the second plane, etc.

When a graphic (main or of background) is smaller than the visualization window,
the system will force the scroll plane to be ciclic, because, in the opposite case,
it couldn't fill the scroll window completely, without repeating {in a c¡clic way}
the graphic (in mosaic).

{/}

{Besides of the call to the function some of the values must be initialized with the} 
{#1101,global scroll structure} {to the correct functioning of the window}.
This is an structure of 10 registers (one for each possible scroll window)
and each register has the following fields:

  {x0, y0}  - Coordinates of the first planeú
  {x1, y1}  - Coordinates of the second planeú
  {z}       - plane of depthú
  {camera}  - {#1039,Identifier code} of the cameraú
  {ratio}   - Relative speed of the second planeú
  {speed}   - Maximum speed of the first planeú
  {region1} - First region of screenú
  {region2} - second region of screenú

There are two ways to program the movement of the scroll windows:

- Manually, modifying in each image of the game the fields {x0}, {y0},
{x1} and {y1} of this structure (the coordinates of the planes of scroll).

- Automaticaly, for which is necesay the {#1038,identifier code}
of a process in the field {camera} of this structure. Being this the system which 
will realize in the scroll window a chase of the graphic of this process.

Go to the help about the {#1101,structure scroll} for further information about these
fields, or to know how to access to them.

{/}

{#9999,Example of AUTOMATIC scroll:}
PROGRAM example_start_scroll;

PRIVATE
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");

    start_scroll(0, file1, 103, 102, 0, 15);

    scroll.camera=id;

    ctype=c_scroll;
    graph=100;
    write(0, 160, 0, 1, "Use the cursors to move yourself");
    LOOP
        IF (key(_right)) x+=2; END
        IF (key(_left)) x-=2; END
        IF (key(_down)) y+=2; END
        IF (key(_up)) y-=2; END
        FRAME;
    END
END
{-}

In the example, first is loaded the file of graphics, and then 
a scroll window is created with the function {start_scroll()}. The following
parameters are given to this last one:

{0} - Number of scroll windows (the first one, because only will be created
a window of this type).

{file1} - Code of the file from which must be take the graphics; this
is the code of the archive {help.fpg} which was loaded with the function 
{#132,load_fpg()}.

{103} - Code of the main graphic (first plane) of the scroll, to see this
graphic, the file must be loaded with the {Menu of files} and with this
observe which is the graphic with {code 103}.

{102} - Code of the secondary graphic (second plane, of background); this is the
graphic that will be shown in the scroll window {behind} of the main graphic.

{0} - Number of screen region in which must be {placed} the scroll;
with 0 what it's indicated is that must be placed in the entire screen.

{15} - Indicator of blocking, with 15 (1+2+4+8) the program indicates that
the first and the second planes can be ciclic in both axis (horizontal and vertical).

After being called the function {start_scroll()} the program defines the field {camera}
of the {#1101,estructure scroll}, giving it the {#1039,identifier code} of the
main process (with the statement {scroll.camera=}{#1092,id}{;}); with this it converts
the scroll in {automatic} following from that momment to the main process graphic.

The program continues defining it's {type of coordinate} as {scroll coordinate} 
(with the statement {ctype=c_scroll;}), defining it's graphic as the number 100
which is a brown ball (with {graph=100;}), printing a message and then it will
stay in a loop in which the coordinates of this process can be changed
(the variables {#1123,x} and {#1124,y}) with the cursor keys.

{/}

{#9999,Example of scroll MANUAL:}
PROGRAM example_start_scroll;

PRIVATE
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");

    start_scroll(0, file1, 103, 102, 0, 15);

    write(0, 160, 0, 1, "Use the cursors to move the scroll");
    LOOP
        IF (key(_right))
            scroll.x0+=2;
            scroll.x1+=1;
        END
        IF (key(_left))
            scroll.x0-=2;
            scroll.x1-=1;
        END
        IF (key(_down))
            scroll.y0+=2;
            scroll.y1+=1;
        END
        IF (key(_up))
            scroll.y0-=2;
            scroll.y1-=1;
        END
        FRAME;
    END
END
{-}

In the example the file of graphics is loaded and then a scroll window
is created with the function {start_scroll()}. The same parameters of the previous
example are given to this last one.

After this, the program will stay in a loop inside of which, when the cursor  
keys are detected, the fields {x0}, {y0}, {x1} and {y1} of the 
{#1101,global scroll estructure} will change, and these define the coordinates of
the two scroll planes ({x0}, {y0} for the first plane and {x1}, {y1}
for the second).

It can be seen the diference between both methods; this last one, as it hasn't
beginning the field {camera} of the structure, will be able to manipulate
the coordinates of both planes.

{/}{How to visualize the process graphics in the scroll}{/}

To create a process which graphic is seen in the scroll window, it's local
variable {#1122,ctype} must be defined as {#1168,c_scroll} ({coordinate of type}
as {coordinate of scroll}), what will be done with the following statement:

  {ctype=c_scroll;}

Once this is done, the process will be seen in the scroll with it's graphic
(defined in the local variable {#1126,graph}). The process just must modify
it's variables {#1123,x} and {#1124,y} to move over the scroll.

{/}

{When a process belongs to the (the value c_scroll has been asigned to it's
local variable} {#1122,ctype}{):}

  - It's variables {#1123,x} and {#1124,y} will be related to the graphic point 
of the first plane, and the graphic of the process will be placed over it.

  - It's variable {#1125,z} know will be relative to the {variables z} of the
processes which belong too to the same scroll window. Each time that the 
scroll window is painted, all the graphics which belongs to the same, will be 
painted next(ordered for it's {z}), and then the processes which {doesn't belong
to this window scroll} will be painted.

  - The process will be eliminated automaticaly when the scroll window is 
eliminated, with the function {#166,stop_scroll()}. Or when the video mode
is changed with the function {#157,set_mode()}, because when it is done
all the scroll windows will be eliminated too.

{/}

If there are some {scroll} windows, the process would be seen by default
in everyone; if is wanted to be seen just in some, it's local variable 
{#1134,cnumber} should be defined. For example, if there are 6 scroll windows
(from the number 0 to the 5) and is wanted for a process to be seen just in the
windows 0 and 2, the following statement should be included:

  {cnumber=c_0+c_2;}

To see an example of this, the best yu can do is to check one of the example
games of DIV Games Studio which uses this technic, due to this, you should 
see the comentaries of these programs (for example {Helioball}).

{/}See: {#166,stop_scroll()} - {#152,refresh_scroll()} - {#140,move_scroll()} - {#1101,Estructure scroll}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.164,stop_cd()}

{stop_cd()}

{Description:}

Stops the CD-Audio reproduction, stopping the song which were playing.
The songs are reproduced with the function {#144,play_cd()}.

{#9999,Example program:}
PROGRAM example_stop_cd;
BEGIN
    write(0, 160, 0, 1, "Press [ENTER] to turn on the CD.");
    write(0, 160, 10, 1, "Press [SPACE] to stop the CD.");
    LOOP
        IF (scan_code==_space)

            stop_cd(); // Para el CD

        END
        IF (scan_code==_enter)
            play_cd(2, 0);
        END
        FRAME;
    END
END
{-}

In the example are placed the necessary messages. In each step of the
loop, if the space bar is pressed, the CD will be stopped with the
function {stop_cd()}.

If the ENTER key is pressed, it will be turned on with the function
{#144,play_cd()}.

The volume of reproduction of cd-audio can be controlled with the
estructure {#1104,setup} and the function {#178,set_volume()}.

{/}See: {#144,play_cd()} - {#127,is_play_cd()} - {#178,set_volume()} - {#1104,Estructure setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.165,stop_mode7()}

{stop_mode7(}<number of m7>{)}

{Description:}

Eliminates the mode 7 window which number (from 0 to 9) is given as parameter.
This <number of m7> is the one indicated as first parameter in the function
{#162,start_mode7()}, is necesary due to that can be up to 10 different mode 7
windows, and the system needs to know which of them is ending.

When a mode 7 window is eliminated, automaticaly will die every process
which belongs exclusively to this window, so, every process which has it's
variable {#1122,ctype} with the value {#1169,c_m7} and they are not being 
seen in any other mode 7 window.

{Important:} When the video mode is changed with the function {#157,set_mode()}
every mode 7 window (and it's processes) will be eliminated, without being in this
case, necesary to use this function ({stop_mode7()}).

{#9999,Example program:}
PROGRAM example_stop_mode7;
BEGIN
    load_fpg("help\help.fpg");
    write(0, 160, 0, 1, "Press [ENTER] to put the mode 7.");
    write(0, 160, 10, 1, "Press [SPACE] to quit the mode 7.");
    write(0, 160, 190, 1, "Use the mouse to move on the mode 7.");
    angle=90000;
    LOOP
        IF (scan_code==_space)

            stop_mode7(0); // The mode 7 si quit.

        END
        IF (scan_code==_enter)
            start_mode7(0, 0, 4, 0, 0, 64);
            m7.camera=id;
        END
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
{-}

In the example a file of graphics is loaded, and the instructions of the program
appear on screen, after this, the coordinates of the main process, which will be
the camera of the mode 7, will be controlled with the mouse (through the
statements {x=mouse.x;} and {y=mouse.y}).

When the ENTER key is pressed, a mode 7 window is created with a graphic
of a brought down dircle, controlled by the main process.

When the space bar is pressed, the function {stop_mode7()} will be called,
eliminating this window of the mode 7 visualization.

{/}

To Create a mode 7 window is a a bit complex procedure and requires to
begin some parameters, as in this case the camera, some of them required
by the function {#162,start_mode7()} and other containeds in the global
structure {#1102,m7} (as the variable {m7.camera} used in the example).

{/}See: {#162,start_mode7()} - {#1102,Estructure m7}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.166,stop_scroll()}

{stop_scroll(}<number of scroll>{)}

{Description:}

Eliminates the scroll window which number (from 0 to 9) is given as parameter.
This <number of scroll> is the one indicated as first parameter in the function
{#163,start_scroll()} and it is necesary due to can be up to 10 different scroll
windows, and the system needs to know which one is ending.

When a scroll window is eliminated, automaticaly will die every process
which belongs exclusively to this window, so, every process which has it's
variable {#1122,ctype} with the value {#1168,c_scroll} and they are not being 
seen in any other scroll window.

{Important:} When the video mode is changed with the function {#157,set_mode()}
every scroll window (and it's processes) will be eliminated, without being in this
case, necesary to use this function ({stop_scroll()}).

{#9999,Example program:}
PROGRAM example_stop_scroll;
BEGIN
    load_fpg("help\help.fpg");
    write(0, 160, 0, 1, "Press [ENTER] to activate the scroll window.");
    write(0, 160, 10, 1, "Press [SPACE] to end the scroll.");
    LOOP
        IF (scan_code==_space)

            stop_scroll(0); // The scroll is quit.

        END
        IF (scan_code==_enter)
            start_scroll(0, 0, 103, 102, 0, 15);
        END
        scroll.x0+=1;
        scroll.y0+=1;
        scroll.x1-=1;
        FRAME;
    END
END
{-}

In the example a file of graphics is loaded and the instructions of the program
appear on screen.

When the ENTER key is pressed, a scroll window will be created and when the
space bar is pressed, the function {stop_scroll()} is called, eliminating
this scroll window.

Inside of the main loop, the coordinates of the scroll are accessed, being contained
in the {#1101,global estructure scroll} to move manually the scroll window
({scroll.x0+=1; ...}).

{/}

To create a scroll window is a bit complex procedure and requires to start some
parameters, some of them, required by the function {#163,start_scroll()} 
and other contained in the {#1101,global estructure scroll}
(as the variable {scroll.x0} used in the example).

{/}See: {#163,start_scroll()} - {#1101,Estructure scroll}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.167,stop_sound()}

{stop_sound(}<number of channel>{)}

{Description:}

For the sound which is being played through the channel, given as parameter.

The <number of channel> required is the value which returns back the function
{#159,sound()} when the reproduction of a sound effect begins.

There are up to 16 sound channels, so a total of 16 sounds can be played at the
same time.

{#9999,Example program:}
PROGRAM example_stop_sound;

PRIVATE
    id_sonido;
    canal;
    sonando=FALSE;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    write(0, 160, 0, 1, "Press [SPACE] to begin the reproduction.");
    write(0, 160, 10, 1, "Press [ENTER] to stop the sound channel.");
    id_sonido = load_pcm("help\help.pcm", 1);
    LOOP
        IF (scan_code==_space AND NOT sonando)
            canal = sound(id_sonido, 128, 256);
            sonando=TRUE;
        END
        IF (scan_code==_enter)

            stop_sound(canal); // The sound stops

            sonando=FALSE;
        END
        FRAME;
    END
END
{-}

In the example, a background graphic is placed as well as the necesary messages,
at the same time that the sound effect, contained in the archive {help.pcm} is 
loaded with the function {#134,load_pcm()}, which gives back the sound identifier
which is saved in the variable {id_sonido}. In this example, a {1} is passed to
this function as second parameter; this is to indicated that the sound effect
loaded, must be repeated indefinitely each time that is started (this is done
to rebound the effect of the function {stop_sound()}).

In each step of the loop is checked if the space bar is pressed, in which case
the reproduction of the sound effect will start with {#159,sound()}, which
will give back the number of channel that will be saved in the variable {canal}.

If the ENTER key is pressed, the sound will be stopped with the function {stop_sound()}.

{/}

To stop the sound gradually, turning off it's volume, several calls must be
made to the function {#102,change_sound()} to decrement lightly the channel volume
until it reaches 0; then, a call can be made to the function {stop_sound()} to stop 
the sound.

{/}See: {#159,sound()} - {#102,change_sound()} - {#134,load_pcm/wav()} - {#170,unload_pcm/wav()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.168,system()}

{system(}<"external command">{)}

{Description:}

Executes the command of operative system, which is given as parameter.

{#9999,Example program:}
PROGRAM example_system;
BEGIN
    write(0, 160, 0, 1, "Press [SPACE] to make a DIR.")
    LOOP
        IF (scan_code==_space)

            system("dir"); // A command of the MS-DOS is executed.

        END
        FRAME;
    END
END
{-}

In the example, after being printed a text, the program gets inside of the main loop
in which will be executed the command {DIR} of the operative system MS-DOS each time
that the space bar is pressed.

{/}

An utility which can has got this command is, for example, to delete a
temporal archive, created in the program, summon the command of system
{DEL <}name of archive{>}.

{/}

{Note:} The system can be hanged up depending of the commands executed, so 
the computer must be restarted in these cases; no guaranty is given about the
functioning of this function, due to the multiple incompatibilities between 
the external commands and the DIV Games Studio's internal manager of processes.

{/}

{system("COMMAND.COM")}

{Description:}

Executes a session of the MS-DOS operative system from the program.
When is introduced EXIT, the program goes back to the moment in which
this statement was executed.

{/}See: {#109,exit()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.169,unload_fpg()}

{unload_fpg(}<code of the file>{)}

{Description:}

Deletes from memory the file of graphics which code is given as parameter.
This <code of file> is the value which returns back the function {#132,load_fpg()}
when a new file of graphics is loaded in the memory.

After being deleted a file of graphics {you must be very cautious} to not
use in the program any graphic of this file.
In this case, the program could crash.

{It is not necessary to delete the file from memory} before finishing the
program, because the system will do it automatically.

For that, a file must be deleted from memory just when it is not going to
be used during a determined time and is wanted to set free the space
ocuppied in the computer memory to load other resorts (other files
of graphics, sounds, fonts, etc.).

{#9999,Example program:}
PROGRAM example_unload_fpg;

PRIVATE
    file1;

BEGIN
    file1=load_fpg("help\help.fpg");
    put_screen(file1, 1);
    write(0, 160, 0, 1, "Press [ENTER] to delete the file and finish");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_fpg(file1); // The file is deleted.

END
{-}

The example loads the file of graphics contained in the archive {help.fpg}
with the function {#132,load_fpg()}, saving the {code of the file} in the 
private variable {file1}.

The program will stay in a loop until the ENTER key is pressed, moment in 
which the file will be deleted from memory with {unload_fpg()}
and the program will finish.

{/}

The graphics loaded in a single way with the functions {#174,load_map()} or 
{#174,load_pcx()} (or created with {#188,new_map()}) won't be deleted when 
the file number 0 (with code 0) is deleted, though these are used as if they
belong to the same, they will be deleted using the functions
{#176,unload_map()} o {#176,unload_pcx()}.

{/}See: {#132,load_fpg()} - {#174,load_map/pcx()} - {#176,unload_map/pcx()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.170,unload_pcm() / unload_wav()}

{unload_pcm(}<code of the sound>{)}

{unload_wav(}<code of the sound>{)}

{Description:}

Deletes from memory the sound which code is given as parameter.
This <code of sound> is the value which gives back the functions
{#132,load_pcm()} and {#132,load_wav()} when a new sound effect is
loaded in the memory.

After being deleted a sound effect {you must be very cautious}
to not continue using in the program this effect (it's code), because
the program could crash.

{It is not necessary to delete the sound of the memory} before finishing the
program, because the system will do it automatically.

For that, a sound must be deleted from memory, just when it is not going to
be used during a determined time and is wanted to set free the space filled
in the computer memory to load another resorts (other files of graphics,
sounds, fonts, etc.), what will have a meaning just with sound effects of 
a certain length, enough big to the need of set free the space that they
are filling.

{#9999,Example program:}
PROGRAM example_unload_pcm;

PRIVATE
    sonido1;

BEGIN
    sonido1=load_pcm("help\help.pcm",0);
    write(0, 160, 0, 1, "Press [ENTER] to delete the sound and finish");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_pcm(sonido1); // The file is deleted.

END
{-}

The example loads the sound effect contained in the archive {help.pcm}
with the function {#134,load_pcm()}, saving the {code of sound} in the
private variable {sonido1}.

The program will stay in a loop until the ENTER key in pressed,
in that moment, the file will be deleted from memory with {unload_pcm()}
and the program will finish.

{/}

To stop a sound effect, but maintain it in memory to play it again, the
function {#167,stop_sound()} must be used.

{/}See: {#134,load_pcm/wav()} - {#159,sound()} - {#102,change_sound()} - {#167,stop_sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.171,write()}

{write(}<font>{,} <x>{,} <y>{,} <code of centre>{,} <text>{)}

{Return:}

The identifier code of the text that has been written.

{Description:}

This function is used to show an alphanumeric text on screen;
to do this, the following parameters are required:

{<font>} - The {code of the font} or {type of letter} which is going to
be used. Here must be put a 0 when is wanted to use the system font.
(font of white color , small, of 6 per 8 points), or the {code of font} 
given back by the function {#131,load_fnt()} when a new font is loaded
in the program.

{<x>}, {<y>} - The coordinates of the screen where is going to be printed
the text, first in the horizontal axis, and the vertical axis.

{<code of centre>} - Is a code which determines the position of the
specified text in the previous coordinates. It's values are:

  {0}-Up left 		{1}-Up 		{2}-Up rightú
  {3}-left        	{4}-Center 	{5}-Rightú
  {6}-Down left  	{7}-Down  	{8}-Down rightú

For example, if a text is written in the coordinates 160, 0 and with
the code of centre 1 (Up), then the text will be centred in the column
160 and will be printed from the line 0 downwards. Or if is wanted a text
in the upper left corner, it must be printed in the coordinates 0, 0 and
with the code of centre 0 (Up left).

{<text>} - As final parameter will be specified the text to be written as
a literal, a text between quotation marks (Go to the {#1047,Delimiter symbols of literals}).

{/}

The text printed will stay on screen until it is deleted with the function
{#107,delete_text()}, which requires as parameter the {identifier code}
which gives back {write()}.

To print the numeric value of a variable (as it could be the
score of the player) the function {#172,write_int()} must be used.

The texts will stay inalterated on screen although graphics of
processes move throught it.

{#9999,Example program:}
PROGRAM example_write;

PRIVATE
    fuente1;

BEGIN
    fuente1 = load_fnt("help\help.fnt");

    write(0, 160, 100, 4, "Example text with the system font.");
    write(fuente1, 0, 0, 0, "UP LEFT");
    write(fuente1, 320, 200, 8, "DOWN RIGHT");

    LOOP
        FRAME;
    END
END
{-}

In the previous example a font contained in the archive {help.fnt}
is loaded with the function {#131,load_fnt()} (which code of font is saved in
the variable {fuente1}), and after that, three texts are written:

The first with the system font (0), being placed it in the coordinates 160, 100
(center of the screen) the {center} of the text (code of centre 4).

The second with the font loaded (which {identifier of font} is saved
in the variable {fuente1}), being placed in the coordinates 0, 0 the
upper left corner of the text (code of centre 0).

And, the third text, also with the font loaded, being placed in the
coordinates 320, 200 the lower right corner of the text (code of
centre 8).

After this, the program will wait indefinitely inside of a loop.

{/}

The plane of depth in which appear the written texts, is controlled
with the global variable {#1106,text_z}, which is used to regulate which
graphics must be seen over the texts and which under the texts.

The texts will move to another position if necessary using the function
{#141,move_text()}, which requires too as parameter the {identifier code}
which gives back {write()}.

{/}

When are used fonts loaded from {archives FNT} the colors palette that has
been used to generate these fonts must be activated (see
{#133,load_pal()}) because, in the opposite case, the colors can be
changed, and the text can be seen incorrectly.

{/}See: {#172,write_int()} - {#141,move_text()} - {#107,delete_text()} - {#131,load_fnt()} - {#1106,text_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.172,write_int()}

{write_int(}<font>{,} <x>{,} <y>{,} <code of centre>{,} <OFFSET variable>{)}

{Return:}

The identifier code of the written text.

{Description:}

This function is used to show the numeric value of a variable on screen;
to do this, the following parameters are required:

{<font>} - The {code of the font} or {type of letter} which is going to
be used. Here must be put a 0 when is wanted to use the system font.
(font of white color , small, of 6 per 8 points), or the {code of font} 
given back by the function {#131,load_fnt()} when a new font is loaded
in the program.

{<x>}, {<y>} - The coordinates of screen in which is going to be printed
the numeric value, first in the horizontal axis, and then y the vertical axis.

{<code of centre>} - Is a code which determinates the position of the
specified text in the previous coordinates. Its values are:

  {0}-Up left 		{1}-Up 		{2}-Up rightú
  {3}-left        	{4}-Center 	{5}-Rightú
  {6}-Down left  	{7}-Down  	{8}-Down rightú

For example, if a numeric value is written in the coordinates 160, 0 and with
the code of centre 1 (Up), then, the numeric value will be centred in the column
160 and will be printed from the line 0 downwards. Or if is wanted a numeric value
in the upper left corner, it must be printed in the coordinates 0, 0 and
with the code of centre 0 (Up left).

{<OFFSET variable>} - As final parameter will be specified the movement inside of
the computer memory of the variable which value is wanted to be seen (the movement
of the data is obtained with the operator {#1085,OFFSET}).

{/}

The numeric value printed will stay until it is deleted with the function
{#107,delete_text()}, which requires as parameter the {identifier code}
which gives back {write_int()}.

{Important:} During the time that the value of the variable, appears on screen
this will actualize automatically each time that the variable is modified,
without being necessary new calls to {write_int()}.

To print an alphanumeric text of any kind (a fixed text)
the function {#171,write()} must be used.

The texts stay on screen without changes although any graphic move
throught the text.

{#9999,Example program:}
PROGRAM example_write_int;

PRIVATE
    variable;

BEGIN
    write(0, 160, 190, 1, "Press [SPACE] to change the value ofthe variable.");

    write_int(0, 160, 100, 4, OFFSET variable); // The variable is printed.

    LOOP
        IF (scan_code==_space) variable=rand(-100, 100); END
        FRAME;
    END
END
{-}

In the example is printed a text using {#171,write()} and the value of a
variable with the function {write_int()}. The following parameters are
given to this last function:

  {0} - As {font} (0 is the system font).ú
  {0, 10} - As coordinates of screen.ú
  {0} - As code of centre (Up/Left).ú
  {OFFSET variable} - As the movement of the variable in memory.ú

On each step of the loop, if the space bar is pressed, the value
of the variable is changed giving it a random one, with the
function {#149,rand()}.

{/}

The plane of depth in which appear the written texts is controlled
with the global variable {#1106,text_z}, which is used to regulate which
graphics must be seen over the texts and which must be seen under the texts.

The texts can move later to another position if it is necessary
using the function {#141,move_text()}, which also requires as
parameter the {identifier code} which gives back {write_int()}.

{/}

When are used fonts loaded from {archives FNT} the colors palette that has
been used to generate these fonts must be activated (see
{#133,load_pal()}) because, in the opposite case, the colors can be
changed, and the text can be seen incorrectly.

{/}

{Warning:}

It is not possible to print an expression, as it's shown know:

  {write_int(0, 0, 0, 0, offset variable + 1);}

To print the value of a variable plus 1, if is wanted to print this value,
an addition of 1 must be made to the variable, or create another
variable and gives it the value of the original variable plus 1, for
example:

  {variable2 = variable + 1;}ú
  {write_int(0, 0, 0, 0, offset variable2);}ú

In this case is necessary to update the value of {variable2} 
at least one time for each frame (for each {#1029,FRAME}) of the game, 
because when the {variable} is changed, it won't update automatically
the value of {variable2} if the statement {variable2 = variable + 1;}
is executed again.

{/}See: {#171,write()} - {#141,move_text()} - {#107,delete_text()} - {#131,load_fnt()} - {#1106,text_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.173,xput()}

{xput(}<file>{,} <graphic>{,} <x>{,} <y>{,} <angle>{,} <size>{,} <flags>{,} <region>{)}

{Description:}

Advanced version of the function {#146,put()} to place a graphic in the background of the
screen. This function requires, per order, the following parameters:

{<file>} - {code of the file} with the library of graphics which contains both.
The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the first
file (the file with the code 0).

{<graphic>} - {code of the graphic} inside of the file which is going to be printed on 
screen.

{<x>, <y>} - coordinates of screen where is wanted to place the graphic.
These coordinates tell where is going to be placed the center of the graphic (or the 
{#1136,checkpoint} number 0, in case of being defined).

{<angle>} - Angle (in thousandths of degree) in which is going to be printed the graphic;
the normal angle is {0}.

{<size>} - Size (in percentage) in which is going to be printed the graphic; the normal
size is {100}.

{<flags>} - Indicates the mirrors and transparencies of the graphic impression; 
the possible values are:

 {0}-Normal graphic.ú
 {1}-Horizontal mirrored.ú
 {2}-vertical mirrored.ú
 {3}-Horizontal and vertical mirrored (180º).ú
 {4}-Transparent graphic.ú
 {5}-Transparent and horizontal mirrored.ú
 {6}-Transparent and vertical mirrored.ú
 {7}-Transparent, horizontal and vertical mirrored.ú

{<region>} - Number of region (window inside of the screen) in which
must be printed the graphic; normally this value will be {0} to
print the graphic in any position of the screen. To define a region
the function {#106,define_region()} must be used.

{/}

The graphics printed in this way, in the background of screen will be in the
visualization of the game {under of every process, scroll regions,
texts, etc.}

If is wanted fro a graphic to be over other graphics it must be {created
as a new process} and fix its variable {#1125,z} with the priority of
impression of the same one.

To delete the background of the screen the function {#103,clear_screen()}
must be used.

{#9999,Example program:}
PROGRAM example_put;

PRIVATE
    file1;
    coord_x;
    coord_y;
    ángulo1;
    tamaño1;
    flags1;

BEGIN
    file1=load_fpg("help\help.fpg");
    LOOP
        coord_x=rand(0, 319);
        coord_y=rand(0, 199);
         ngulo1=rand(-pi, pi);
        tamaño1=rand(10, 200);
        flags1=rand(0, 7);

        // The graphic 101 is placed
        xput(file1, 101, coord_x, coord_y, ángulo1, tamaño1, flags1, 0);

        FRAME;
    END
END
{-}

In the example the file with the graphics is loaded and in each iteration of
loop is placed the graphic number 101 (a triangle) with the function {xput()} in
random coordinates (chosen with the function {#149,rand()}), with an angle and
size also random, with the value of {flags} random and in the region number 0
(entire screen).

{/}

The function {#146,put()} is a simplified version of the function {xput()} 
useful when the graphic is not going to be printed with rotation, escalation, 
or transparencies.

To put a graphic into another (instead of the background of screen)
the functions {#137,map_put()} or {#139,map_xput()} must be used.

{/}

If the graphic which is wanted to place is simply a background screen.
It is easier to use the function {#148,put_screen()}, because this doesn't
requires the coordinates of screen, because it will centre the graphic
on screen automatically.

{/}See: {#146,put()} - {#137,map_put()} - {#139,map_xput()} - {#148,put_screen()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.174,load_map() / load_pcx()}

{load_map(}<name of archive>{)}

{load_pcx(}<name of archive>{)}

{Return:}

The {code of the graphic} loaded.

{Description:}

Loads an {archive MAP or PCX} with a graphic in the computer memory. Is required
the name of the archive as parameter, between quotation marks.

As return value is given back the {code of the graphic}, which is a numeric value
which must be specified to use the graphic, in the variable {#1126,graph} or, 
in every function that requires a {code of graphic} among its parameters.

Is posible to load as many graphics as it is necessary; each time that one
is loaded, the function will give back the correspondent code (the first graphic
loaded will have the code {1000}, the next one the {1001}, etc.)

A route of access to the archive can be specified with the file of graphics,
but, if the file is in the default directory (\MAP or \PCX) this won't be 
necessary.

{/}

{Important:}

When inside of a function is required the {code of file} which belongs
this graphic, the code {0} must be indicated (which is the code of the 
first {file FPG} that is loaded in the program).

{/}

When different graphics have been loaded, if this have different palettes, each
one of them must be activated with the function {#133,load_pal()}, indicating 
the name of the file as parameter, before using the graphic.

Graphics created with different palettes can't be used at the same time.

{#9999,Example program:}
PROGRAM example_load_map;

PRIVATE
    map1;

BEGIN

    map1 = load_map("help\help.map"); // A file of graphic map is loaded.

    put_screen(0, map1);
    LOOP
        FRAME;
    END
END
{-}

In the example a graphic map is loaded with the function {load_map()} saving
the {code of the graphic} which returns back in the private variable {map1}.

This code is used then as parameter of the function {#148,put_screen()}
to put the graphic in the background.

{/}

The functions {#176,unload_map()} and {#176,unload_pcx()} allows to set free the 
computer memory used by the graphic when it is not going to be used during a time, 
and, for that, is required too the {code of the graphic}, to know which graphic
is the one to be deleted from memory.

{It is not necessary to delete the graphic from memory} before finishing the
program, because the system will do it automatically.

{/}

To load some graphics at a same time in a program, These must be included inside
of a file of graphics (FPG) and being loaded with the function {#132,load_fpg()}.

{/}

The function {#188,new_map()} allows to create in memory a graphic map of
any size and color, without loading it from an archive of the disk.

{/}See: {#188,new_map()} - {#176,unload_map/pcx()} - {#132,load_fpg()} - {#133,load_pal()} - {#1126,graph}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.175,reset_sound()}

{reset_sound(}{)}

{Description:}

Advanced function, just for very experienced users. It restarts the
sound system.

This function is used to activate new parameters of the sound hardware.

The following values of the {#1104,global setup estructure} must be established: 

    {setup.card}ú
    {setup.port}ú
    {setup.irq}ú
    {setup.dma}ú
    {setup.dma2}ú

This function is used inside of the sound system configuration programs
(see {#1093,setup_program}).

{/}

To activate the rest of the setup structure values, the refered to the
volume of the mixer, the function {#178,set_volume()} must be called. The values
to establish the volume are:
    {setup.master}ú
    {setup.sound_fx}ú
    {setup.cd_audio}ú

{/}See: {#178,set_volume()} - {#1104,Setup estructure} - {#1093,setup_program}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.176,unload_map() / unload_pcx()}

{unload_map(}<code of the graphic>{)}

{unload_pcx(}<code of the graphic>{)}

{Description:}

Deletes from memory the graphic which code is given as parameter.
This <code of graphic> is the value given back by the functions {#174,load_map()},
{#174,load_pcx()} or {#188,new_map()} when a file is loaded or created.

After being deleted a graphic {you must be very cautious} to not use
in the program this graphic, because the program could crash.

{It is not necessary to delete the graphic} before finishing the
program, because the system will do it automatically.

Then, a graphic just must be deleted from memory when it is not going to be used
in a determined time and is wanted to set free the space ocuppied in the 
computer memory, to load another resorts (other files of graphics, sounds,
fonts, etc.), which will be useful just with graphics of a certain size,
enough bigs to be profitable to liberate the space.

{#9999,Example program:}
PROGRAM example_unload_map;

PRIVATE
    mapa1;

BEGIN
    mapa1=load_map("help\help.map");
    put_screen(0, mapa1);
    write(0, 160, 0, 1, "Press [ENTER] to delete the graphic and finish");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_map(mapa1); // The graphic is deleted.

END
{-}

In the example a graphic map is loaded with the function {#174,load_map()} saving
the {code of the graphic} which returns in the private variable {mapa1}.

This code is used, as parameter of the function {#148,put_screen()} to put the
graphic in the background.

Then, the program will print a message and will wait in a loop the ENTER key for be pressed, 
and at that moment, the graphic will be deleted using the function {unload_map()}.

{/}

The graphics loaded in a single form with the functions {#174,load_map()} or {#174,load_pcx()}
(or creater with {#188,new_map()}) won't be deleted when the file number 0 (with code 0) is deleted
with the function {#169,unload_fpg()}, although these graphics are used as if they were
from the same one.

{/}See: {#174,load_map/pcx()} - {#169,unload_fpg()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.177,unload_fnt()}

{unload_fnt(}<code de the fuente>{)}

{Description:}

Deletes from memory the {font} (the {type of letter} or the {group of graphic 
characters}) which code is given as parameter.

This <code of font> is the value which returns back the function {#131,load_fnt()}
when a new font contained in an {archive FNT} is loaded in the computer memory.

After being deleted a font {you must be cautious} to not use in the program this font;
if this is done, the program could crahs.

{It is not necessary to delete the font} before finishing the program, because the 
system will do it automatically.

After that, a font must be deleted from memory just when it is not going to be
used in a certain time and is wanted to set free the space that ocuppied in the
computer memory to load another resorts (other files of graphics, sounds, fonts, etc.).

{#9999,Example program:}
PROGRAM example_unload_fnt;

PRIVATE
    fuente1;

BEGIN
    fuente1=load_fnt("help\help.fnt");
    write(fuente1, 160, 0, 1, "FONT OF THE ARCHIVE IN DISK");
    write(0, 160, 190, 1, "Press [ENTER] to delete the font and finish.");
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_fnt(fuente1); // The font is deleted
END
{-}

In the example the font contained in the archive {help.fnt} is loaded with
the function {#131,load_fnt()} saving the {code of font} which returns in the
private variable {fuente1}.

This code is used as parameter of the function {#171,write()} to put a text
on screen with this font.

Then, the program will wait in a loop until the ENTER key is pressed, and at
that moment, the font will be deleted using the function {unload_fnt()},
and the program will finish.

{/}

The font number 0, (the font of the system must be 0 as font code),
{it can't be deleted}.

{/}See: {#131,load_fnt()} - {#171,write()} - {#172,write_int()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.178,set_volume()}

{set_volume(}{)}

{Description:}

Function advanced, just for very experienced users.
It fixes the different volume controls, managed by the mixer of the
sound system.

The following values of the {#1104,global setup structure} must be established
to adjust the volume:

    {setup.master}   - General volumeú
    {setup.sound_fx} - Volume of the sound effectsú
    {setup.cd_audio} - Volume of the cd-audio musicú

This function is used inside of the system sound configuration programs 
(see {#1093,setup_program}), or in the rest of the programs, normally
to fix the volume of the CD-Audio music.

{/}

To activate the rest of the setup estructure values (of the soundcard parameters),
the function {#175,reset_sound()} must be called with the following structure values
defined:

    {setup.card}ú
    {setup.port}ú
    {setup.irq}ú
    {setup.dma}ú
    {setup.dma2}ú

{/}See: {#175,reset_sound()} - {#1104,Setup estructure} - {#1093,setup_program}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.179,set_color()}

{set_volume(}<color>{,} <red>{,} <green>{,} <blue>{)}

{Description:}

Redefine a color of the palette. This function is used to modify the components
of a concrete color of the game palette.

You must be very cautious with it, because all the graphics of the screen
that use this color will be affected, to modify the colors of just one graphic
the function {#105,convert_palette()} must be used.

The <color> must be a number between {0} and {255}. The {components of the color}
will be specified as number between {0} (m¡nimum) and {63} (maximum).

  {<red>}   - Component red of the color.ú
  {<green>} - Component green of the color.ú
  {<blue>}  - Component blue of the color.ú

Now a program is shown which modifies randomly the colors of the palette.

{#9999,Example program:}
PROGRAM example_set_color;
GLOBAL color,r,g,b;
BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 2);
    LOOP
        color=rand(1,255);
        r=rand(0,63);
        g=rand(0,63);
        b=rand(0,63);

        set_color(color, r, g, b); // A color of the palette is redefinied.

        FRAME;
    END
END
{-}

In the example is placed as background a multicolor screen and inside of the program 
main loop, the components of any color of the palette are modified randomly when the
space bar is pressed. To obtain random numbers the function {#149,rand()}.

{/}

To modify the entire palette, is better to load this one of an archive with the
function {#133,load_pal()}.
{/}

To realize other palette effects, the function {#154,roll_palette()} can be used, which 
allows make loops of color, or the function {#110,fade()} which allows to realize
multiple fades and saturations of color in different speeds.

{/}See: {#154,roll_palette()} - {#133,load_pal()} - {#110,fade()} - {#111,fade_off()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.180,net_join_game()}

{net_join_game(}<name of the game>{,} <OFFSET estructure>{,} <SIZEOF(estructure)>{)}

{Return:}

Number of player in the game (0, 1, 2, ...). If there is an error, a negative
number is given back, being these the codes of error:

 { -1} : Connection aborted by the user.ú
 { -2} : Can't start the connection.ú
 { -3} : The number of players doesn't fit.ú
 { -4} : There were errors of sincronization.ú

{Description:}

The net functions are of an extremate advanced level, so can be very complicated of understanding
to users with not enough experience in programation.

First must be initialized the predefinied global structure {#1410,net} with the parameters
that define the type of connection which is going to be established.

Then, a call to the function {net_join_game()} will be enough to create a new game or to join
the same (if it is already created).

The name of the game (a literal, as {"MyGame"}), is used to just a game executes some games at
the same time in just one local net. Differing each one of them this way.

>From that moment, every computer connected to the game will send and receive data from 
the others automatically, through the structure, indicated as parameter.

{The structure of data.}

This must be a global structure of the program with as many registers, as players
must be connected at the same time.

In the fields of the structure the sent data can be read and written; each player
must introduce its values in its own register. The number which correspond
to each player is given back by this function.

The system will send automatically its register to the other players, and the registers
of the others players to him.

{#1410,The predefinied structure net}

In this structure are established the parameters which define the type of connection. The fields
of this structure are resumed now:

{net.device} - Connection dispositive (1-IPX, 2-Serial link or 3-Modem).

{net.com} - Nº of dispositive COM, from 1 to 4 (just for serie and modem).

{net.speed} - Speed (in bauds), up to 115000 (just for serie and modem).

{net.number} - Telephone number (just modem), for example {net.number="913040622";}.

{net.init} - Init string of the modem, for example {net.init="ATZ";}.

{net.mode} - 0 or 1 depending if it's pulses or tones (only for modem).

{net.server} - Indicates if it is the server (just reading, can't be modified).

{net.max_players} - Maximum number of player, from 2 to 16 (it must be the same of the number of registers of the global structure).

{net.num_players} - Current number of player, from 1 to 16 (players can connect and disconnect in every moment).

When the connection is realized by serial link or modem just can connect {2 players}.

{/}

It's important that the register number of the structure used to the data transfer
has as many registers as the indicated in {net.max_players}.

For example, if a game is created in the maximum number of players is 8,
and the information which must be given to the players are just their coordinates (x,y),
then it could be done as is shown in the following program (supossing a IPX connection
for a local net).

{#9999,Example program:}
PROGRAM example_net_join_game;

GLOBAL
  STRUCT player[7] // 8 players as maximum (from 0 to 7).
    x,y;
  END

  id_red;

BEGIN

  net.device=1;
  net.max_players=8; // Here, the number of registers is indicated.

  // ...

  id_red=net_join_game("xxx",OFFSET player, sizeof(player));

  IF (id_red<0)

    // An error has been produced ...

  END

  // The register of this player is "player[id_red]"

  player[id_red].x=x; // I Define my fields
  player[id_red].y=y;

  FRAME; // Sending / Reception of data

  // Now there are connected "net.num_players", and their data are in
  // the other registers of the structure player[].

  // ...

END
{-}

{Note:} Further information can be found about how to structure a game over net in
the user's manual of DIV Games Studio.

{/}See: {#181,net_get_games()} - {#1410,STRUCT net}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.181,net_get_games()}

{net_get_games()}

{Return:}

Activated games to this game.

{Description:}

Gives back the number of active games to this game (to connections over local net).
This function is used to see if there is any active game in a determined moment.

To establish a connection, the function {#180,net_join_game()} is used, to create
games or to connect to them.

{#9999,Example program:}
PROGRAM example_net_get_games;

GLOBAL
  n;  // Active games.

BEGIN

  // ...

  n=net_get_games();

  IF (n>0)
    // ...
  END

  //...

END
{-}

Just is useful to IPX connections, it has no meaning in serial link or modem connections  
(because in these cases just can be a game).

{/}See: {#180,net_join_game()} - {#1410,,STRUCT net}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.182,stop_mode8()}

{stop_mode8(}<number of m8>{)}

{Description:}

Eliminates the mode 8 window which number (from 0 to 9) is given as parameter.
This <number of m8> is the one indicated as first parameter in the function
{#190,start_mode8()}, is necessary due to can be up to 10 different
mode 8 windows, and the system needs to know which of them is being finished.

{/}

{Note:} To create a mode 8 window is an advanced procedure and requires
to start some parameters, as in this case the camera, some of them required
by the function {#190,start_mode8()} and other containeds in the
{#1411,global m8 estructure} (as the variable {m8.camera}).

{/}

{#9999,Example program:}
PROGRAM example_stop_mode8;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  write(0,0,0,0,"Press ESC to finish ...");
  REPEAT
      FRAME;
  UNTIL (key(_esc));

  stop_mode8(0); // Eliminates the region number 0 of mode 8

END
{-}

This program shows an initiation example of a mode 8 region,
loading the map contained in the archive {wld_view.prg}, and starting a
region (the number {0}) with {#190,start_mode8()}.

This program waits in a loop until detect the {ESC} key, moment in which
the one that goes out and eliminates this region with {stop_mode8()}.

{/}See: {#190,start_mode8()} - {1411,STRUCT m8} - {#189,load_wld()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.183,xadvance()}

{xadvance(}<angle>{,} <distance>{)}

{Description:}

Advances the process {in the indicated angle} as many points as shows {the indicated distance} as parameter.

This function is equivalent to the function {#101,advance()}, if the {#1129,angle} is used as first
parameter.

The distance can be a negative number too, so the graphic of the process
will advance  (it's coordinates {#1123,x} and {#1124,y}) in the opposite direction
to this angle.

{#9999,Example program:}
PROGRAM example_xadvance;

PRIVATE
  angle2;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=101;
    x=160;
    y=100;
    write(0, 0, 0, 0, "Use the cursors to change the direction.");
    LOOP
        angle+=5000;
        IF (key(_right)) angle2-=10000; END
        IF (key(_left)) angle2+=10000; END

        advance(angle2,4); // We advance the process to points

        FRAME;
    END
END
{-}

This example will draw a triangle on screen which will advance in the selected direction
with the cursors, independent in any moment of the orientation of the graphic on screen
(of tne angle of visualization).

Remember that the angle is specified in thousandths of degree.

{/}See: {#1044,Use of the angles in the language} - {#101,advance()} - {#118,get_distx()} - {#119,get_disty()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.184,char()}

{char(}<literal>{)}

{Return:}

The value {ASCII} of the (first) character containte in the literal.

{Description:}

This function {char()} is used to obtain the ordinal value of a character.

{#9999,Example program:}
PROGRAM example_char;
PRIVATE valor;
BEGIN
  // ..
  valor="A";       // The address of the literal "A" is asigned in memory.
  // ..
  valor=char("A"); // The ASCII value of "A" is asigned (65 in decimal).
  // ..
END
{-}

In a program, the literals (texs between quotation marks) are transaled as the
memory address in which has been almacenated them. To asign to one variable
a character (it's ordinal value), instead of the address of the string,
must be used this function.

See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.185,path_find()}

{path_find(}<mode>{,} <file>{,} <graphic>{,} <square size>{,} <x>{,} <y>, <OFFSET estructure>{,} <sizeof(estructura)>{)}

{Return:}

Number of route points, or 0 if it's not find any.

{Description:}

Finds a route from the current coordinates of the process to a determined
point, dodging the definied obstacles in a searching map
(in the user's manual, can be found information about these maps).

{The mode.}

Can be realized a searching in a different way, depending of the {<mode>} indicated
as first parameter of the function.

  {0} - Searching less precised and faster.ú
  {1} - Searching more precised, but slower.ú

{The searching map.}

The codes of {<file>} and {<graphic>} ,relates to the searching map. This
is an smaller version of the real scenario, where appears in {black color}
(the number 0 of the palette) the free zones and with {white color} the obstacles
of itself.

As {<square size>} is indicated the reduction factor of the searching map,
how much must be multiplied the width and height of itself to being shown 
at a real size. For example, if for a 320x200 screen is generated
a searching map of 160x100, then, the square size will be 2.

{The route points.}

Now must be indicated the coordinates {<x>} and {<y>} where the process must
go (as origin of the are taken the current coordinates of the process which
executes the function {path_find()}).

This functions returns a group of an structure points, these are the
points which from the route from the origin to the destination point.

Due to that, must be declared an structure which containeds two fields (x,y),
and as many registers as points can conform the calculated route.

To the function must be passed, as the two last parameters, the address ({#1085,OFFSET}) of
this structure and it's size ({#1094,SIZEOF()}), so it can gives back the result
on itself.

{/}

{#9999,Example program:}
PROGRAM example_path_find;

GLOBAL
    num_points;
    STRUCT points[100]
      x,y;
    END
    index;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 7);
    graph=200;
    mouse.graph=200;
    LOOP

        // Obtains the route to the mouse's coordinates

        num_points=path_find(0,0,201,2,mouse.x,mouse.y,OFFSET points,sizeof(points));

        // If was obtained a route, is shows and advances to the destination

        IF (num_points>0)
            FOR (index=0;index<num_points-1;index++)
                draw(1,24,15,0,points[index].x,points[index].y,points[index+1].x,points[index+1].y);
            END
            IF (fget_dist(x,y,points[0].x,points[0].y)>4)
                xadvance(fget_angle(x,y,points[0].x,points[0].y),4);
            ELSE
                x=points[0].x;
                y=points[0].y;
            END
            draw(1,24,15,0,x,y,points[0].x,points[0].y);
        END

        FRAME;
        delete_draw(all_drawing);
    END
END
{-}

In this example is used the {graphic number 7} of the file {help.fpg} as 
scenario, and the {graphic number 201} of the same as it's {searching map}.

The size of the squares is the searching map is {2}

The main process is obtaining continously a route to the mouse cursor
with the function {path_find()}.

The different segments of this route are represented with lines using the
function {#249,draw()}, and the increment of the coordinates is realized 
with the function {#183,xadvance()}.

To obtain the distance and the angle to the next point of the route the 
functions {#114,fget_dist()} and {#113,fget_angle()} are used.

{/}

To see if can go directly in a straight line between two points (without
pass through any obstacle) the function {#186,path_line()} can be used.

The function {#187,path_free()} determines if a determined point of the map
is an obstacle or if it is a free point (accessible).

{/}See: {#186,path_line()} - {#187,path_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.186,path_line()}

{path_line(}<file>{,} <graphic>{,} <square size>{,} <x>{,} <y>{)}

{Return:}

{#1151,True (1)}, if it can goes from one point to another without going through
any obstacle, or {#1152,false (0)} in the other case.

{Description:}

It determines if, inside of a searching map, can go in a straight line up to a point
(starting in the current coordinates of the process), without passing through any 
obstacle of the searching map (in the user's handbook you can find information about
these maps).

In case of want to obtain a path to dodge the obstacles between two points,
it must been used the function {#185,path_find()}, and to see if the destination point
is inside of an obstacle, the function {#187,path_free()}.

{The searching map}

The codes of {<file>} and {<graphic>} are related to the searching map. This is a
smaller version of the real scenario, where appear in {black color}
(the number 0 of the palette) the free zones and with {white color} the obstacles
of the same.

As {<square size>} is indicated the factor of reduction of the searching map,
for how much must be multiplied the width and the height of the same to
being shown at real size. For example, if for a 320x200 screen is generated
a searching map of 160x100, then, the square size will be 2.

Now must be indicated the coordinates {<x>} and {<y>} where must go the process
(as origin of the route are taken the current coordinates of the process which
executes the function {path_find()}).

{/}

{#9999,Example program:}
PROGRAM example_path_line;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 7);
    graph=200;
    mouse.graph=200;
    LOOP

        // It checks if can go in a straight line to the mouse

        IF (path_line(0,201,2,mouse.x,mouse.y))

            IF (fget_dist(x,y,mouse.x,mouse.y)>4)
                xadvance(fget_angle(x,y,mouse.x,mouse.y),4);
                draw(1,24,15,0,x,y,mouse.x,mouse.y);
            ELSE
                x=mouse.x;
                y=mouse.y;
            END
        END

        FRAME;
        delete_draw(all_drawing);
    END
END
{-}

In this example is used the {graphic number 7} of the file {help.fpg} as
scenario, and the {graphic number 201} of the same as its {searching map}. The
cell size in the searching map is {2}.

The main process is continously checking if can go in a straight line
to the mouse coordinates with the function {path_line()}. When this is
possible, a line is trazed with the function {#249,draw()}, and the process 
coordinates advance with the function {#183,xadvance()}.

To obtain the distance and the angle to the mouse cursor the
functions {#114,fget_dist()} and {#113,fget_angle()} are used.

{/}See: {#185,path_find()} - {#187,path_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.187,path_free()}

{path_free(}<file>{,} <graphic>{,} <square size>{,} <x>{,} <y>{)}

{Return:}

{#1151,True (1)}, if point is free (is not an obstacle) in a searching map, or
{#1152,false (0)} in the opposite case.

{Description:}

Determine if, inside of a searching map, the coordinates are placed
in an accesible zone, out of any obstacle (in the user's manual
can be found information about these searching maps).

In case of want to obtain a route to dodge the obstacles between two points
the function {#185,path_find()} must be used, and to see if it can go to a
point in a straight line without pass through any obstacle with the function {#186,path_line()}.

{The searching map.}

The codes of {<file>} and {<graphic>} are related to the searching map. This is a
smaller version of the real scenario, where appear in {black color}
(the number 0 of the palette) the free zones and with {white color} the obstacles
of the same.

As {<square size>} is indicated the factor of reduction of the searching map,
for how much must be multiplied the width and the height of the same to
being shown at real size. For example, if for a 320x200 screen is generated
a searching map of 160x100, then, the cell size will be 2.

Now must be indicated the coordinates {<x>} and {<y>} to be consultated.

{/}

{#9999,Example program:}
PROGRAM example_path_free;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 7);
    mouse.graph=200;
    mouse.size=400;
    LOOP

        // Checks if the mouse is in an accessible zone

        IF (path_free(0,201,2,mouse.x,mouse.y))
            mouse.angle+=5000;
        END

        FRAME;
    END
END
{-}

In this example the {graphic number 7} of the file {help.fpg} is used as
scenario, and the {graphic number 201} of the same as its {searching map}.
the square size in the searching map is {2}

The main process is continuously checking, with the function {path_free()},
if the mouse cursor is in a free zone, or over an obstacle.

When the cursor is in a free zone, out of any obstacle, its graphic
will rotate.

{/}See: {#185,path_find()} - {#186,path_find()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.188,new_map()}

{new_map(}<width>{,} <height>{,} <center x>{,} <center y>{,} <color>{)}

{Return:}

The {code of the graphic} created.

{Description:}

Creates a new map in memory (without loading it from an archive of the disk).

To that, the function requires the {<width>} and {<height>} (in points) of the map
that must be created, a central point (inside of the same) in {<center x>} and {<center y>},
and the color with which is going to fill up initially the map (the number of the color
inside of the active palette, from 0 to 255).

This function acts equal than {#174,load_map()}, except that an archive of the disk
is not readen with the graphic, if it is not created as solid graphic of just one
color.

As return value is given back the {code of the graphic}, which is a numeric value
which must be specified to use the graphic, in the variable
{#1126,graph} or, in general, in every function which requires a {code of graphic}
between its parameters.

{/}

{Important:}

When, inside of a function, is required the {code of file} which belongs
to the graphic, must be indicated the code {0} (which is the code of the
first {file FPG} that is loaded in the program).

{/}

{#9999,Example program:}
PROGRAM example_new_map;

BEGIN

    // Is created a map of 16x32 points
    // with it's center in the point (0,0)
    // and with the color 15 of the palette

    mouse.graph = new_map(16,32,0,0,15); // Is asigned as mouse cursor

    REPEAT
        FRAME;
    UNTIL (key(_esc));

    unload_map(mouse.graph); // And finally is liberated or deleted the graphic
END
{-}

In the example is created a map with the function {new_map()} saving
the {code of the graphic} which returns in the variable {#1100,mouse.graph}, to
be as mouse cursor.

Pressing the {ESC} key it will go out of the visualization loop of the program and
the graphic will be deleted with the function {#176,unload_map()} (exactly the same
as it were loaded from an archive of the disk).

{/}

The function {#176,unload_map()} allows to liberate the computer memory used
by the graphic when it is no more used in a certain time, and due to that
is require too the {code of the graphic} to know which graphic is the one
that is wanted to be deleted from memory.

{It is not necessary to delete the graphic from memory} before finishing the
program, because the system will do it automatically.

{/}See: {#174,load_map/pcx()} - {#176,unload_map/pcx()} - {#1126,graph}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.189,load_wld()}

{load_wld(}<nombre de archivo>{,} <file>{)}

{Description:}

It loades a {mode 8 map} in a program. These maps are saved in the archives
with the extension WLD, and are created with the maps 3D menu (in the user's manual
can be found further information how to costruct these maps).

As parameters, are required the {<name of archive>} which contains the map in
WLD format, and the code of the {<file>} which contains the textures of the same.
This file with the textures of the map must have been loaded previously in 
the program with the function {#132,load_fpg()}.

Once the map is loaded, a region of mode 8 screen must be initiated with
the function {#190,start_mode8()}. The functioning is quite similar to the mode 7
which show a brought down plane (see {#162,start_mode7()}).

{#9999,Example program:}
PROGRAM example_load_wld;

GLOBAL
    file;

BEGIN
  set_mode(m640x480);
  set_fps(70,0);
  file = load_fpg("HELP\WLD_VIEW.FPG");

  load_wld("HELP\WLD_VIEW.WLD",file); // Loads a file WLD

  start_mode8(id,0,0);
  ctype=c_m8;
  height=64;
  radius=64;
  m8.height=32;
  go_to_flag(0);
  LOOP
    IF (key(_right)) angle-=5000; END
    IF (key(_left))  angle+=5000; END
    IF (key(_up))    advance(24); END
    IF (key(_down))  advance(-9); END
    IF (key(_q))     z+=16;       END
    IF (key(_a))     z-=16;       END
    IF (key(_w))     m8.angle+=8; END
    IF (key(_s))     m8.angle-=8; END
    FRAME;
  END
END
{-}

This program shows an initiation example of a mode 8 region,
loading the map contained in the archive {wld_view.prg}, and which texture is
found in the file {wld_view.fpg}.

{/}See: {#190,start_mode8()} - {#191,go_to_flag()} - {#132,load_fpg()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.190,start_mode8()}

{start_mode8(}<camera identifier>{,} <number of m8>{,} <number of region>{)}

{Description:}

This is an advanced function that requires for the user to have certain
experience to can use it.

Creates a visualization window with a mode 8, visualizes a map of
three-dimensional sector; {first must be loaded the map with the
function} {#189,load_wld()}, and then, this function with following
parameters:

{<camera identifier>} - {#1039,Identifier code} of the process
in which position must be placed the mode 8 camera, the camera will be placed
in the coordinates {(x,y)}, at the height {(z)} and looking the indicated
address for {(angle)} (every are {#1201,local data predefinied} of the
process).

{<number of m8>} - Up to 10 mode 8 windows can be created on screen, with the
number from {0} to {9}; if just can be created one, the best that can be done,
is to define the number {0}. This number will be necessary then to modify
the parameters of the window, because the system needs to know which one
of the {10} possible mode 8 windows is wanted to be changed.

{<number of region>} - Here will be indicated the rectangular region of the screen
in which is going to be shown the mode 8. If the {0} is indicated as number of
region, it will be shown in the whole screen. The others regions must be defined
previously with the function {#106,define_region()} (one {region} is just a
rectangular zone of the screen).

{Note:} The functioning is very similar to the mode 7 which shows a brought down
plane (see {#162,start_mode7()}).

{/}

{Besides of the call to the function, some values of the} {#1411,global m8 structure} 
must be initiated {for the correct functioning of the window}.
This is a structure of 10 registers (one for each possible mode 8 window)
and each register has the following fields:

  {camera}   - {#1039,Identifier code} of the cameraú
  {height}   - Height of the camera related to the processú
  {angle}    - Vertical angle of the camera (-128,128)ú
  {z}        - Plane of depth (priority of impression of the region)ú

The field {camera} is {essential}, due to that is asked as one of the calling parameters
of the function {start_mode8()} because, without this field, the window can't be 
determined from which must be {seen} the map.

{/}

{#9999,Example program:}
PROGRAM example_start_mode8;

GLOBAL
    file;

BEGIN
  set_mode(m640x480);
  set_fps(70,0);
  file = load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",file);

  start_mode8(id,0,0); // Starts a mode 8 region

  ctype=c_m8;
  height=64;
  radius=64;
  m8.height=32;
  go_to_flag(0);
  LOOP
      IF (key(_right)) angle-=5000; END
      IF (key(_left))  angle+=5000; END
      IF (key(_up))    advance(24); END
      IF (key(_down))  advance(-9); END
      IF (key(_q))     z+=16;       END
      IF (key(_a))     z-=16;       END
      IF (key(_w))     m8.angle+=8; END
      IF (key(_s))     m8.angle-=8; END
      FRAME;
  END
END
{-}

This program shows an initiation example of a mode 8 region, loading
the contained of the archive {wld_view.prg}, and which textures are found in the
file {wld_view.fpg}.

{/}

To create a process which graphic is visualizated in the mode 8, must be
defined its local variable {#1122,ctype} as {#1412,c_m8} ({type of coordinate}
as {coordinate of mode 8}).

When a process belongs to the mode 8 its variables {#1123,x} and {#1124,y}
will be related to the point inside of the map of sectors (WLD), and its variable
{#1125,z} will indicate the height.

If there are some {mode 8} windows, the process will be seen by default
in everyone, if just is wanted to be seen in some of them, its local
variable {#1134,cnumber} must be defined.

For a process to have some graphics (some views), depending of the
angle from which is going to be seen, its graphic must be defined
with local variable {#1132,xgraph} (instead of the variable {#1126,graph}).

{/}

{Note:} To eliminate a mode 8 region must be used the function
{#182,stop_mode8()}, which must be indicated the {number of m8}.

{/}See: {#1411,STRUCT m8} - {#189,load_wld()} - {#191,go_to_flag()} - {#182,stop_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.191,go_to_flag()}

{go_to_flag(}<number of flags>{)}

{Description:}

Places a process of a mode 8 in a flag, the process which wants to be placed
in that position is which is going to call the function, and as only parameter
must be indicated the {<number of flag>}.

After being called to the function, the process will be placed in the next {#1029,FRAME},
in the flag coordinates. The height of the flag always will be understood
as the minimum height of the sector in which is going to be found.

The flags are placed in the editor of three-dimensional maps, which control
is explained in the user's manual of the program.

{Note:} This function is equivalent to give to the process the coordinates
of this flag its coordinates ({x},{y},{z}). The window which
gives, is to place directly in the editor, the position
of determined objects.

{#9999,Example program:}
PROGRAM example_go_to_flag;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;

  go_to_flag(0); // Places the process camera in the flag 0

  LOOP
      FRAME;
  END
END
{-}

This example program initializes a mode 8 region, loading the map contained in the
archive {wld_view.prg} with the function {#189,load_wld()}, and starts a region 
with {#190,start_mode8()}.

Then, places the process (which acts as camera of the window) in the
indicated position by the flag number 0 of the map of sectors.

{/}See: {#190,start_mode8()} - {#1411,STRUCT m8} - {#189,load_wld()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.192,set_sector_height()}

{set_sector_height(}<number of sector>{,} <height of the ground>{,} <height of the ceiling>{)}

{Description:}

Modifies the height of the {ground} or {ceiling} of a mode 8 sector. The following
parameters are required:

{<number of sector>} - Number of sector of the map which height is wanted
to be modified. This number can be obtained in the editor of three-dimensional maps,
which control is explained in the user's manual of the program.

{<height of the ground>} - The new sector height of the ground must be indicated
(a value from 0 to 4096), if it is indicated{ -1} as parameter, the current sector 
height of the ground will remain (useful to modify just the height of the ground).

{<height of the ceiling>} - The new sector height of the ceiling must be indicated
(a value from 0 to 4096), if it is indicated{ -1} as parameter, the current sector 
height of the ceiling will remain (useful to modify just the height of the ceiling).

To starts a mode 8 region, the function {#190,start_mode8()} must be called.

{/}

{Note:} If the height of the ceiling is the same as the ground's height this
sector won't be accessible (if this one is inside of another, it will appear as a
column). The height of the ceiling must be smaller than the height of the ground.

{/}

{#9999,Example program:}
PROGRAM example_set_sector_height;

GLOBAL
    sector=255;
    altura;
    ángulo1;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=64;
    LOOP
        altura=1000+get_distx(ángulo1,64);
        ángulo1+=5000;

        set_sector_height(sector,altura,-1);

        FRAME;
    END
END
{-}

This small example starts a mode 8 region, loading the map
{wld_view.wld}, and it is placed in the predeterminied coordinates with
the function {#191,go_to_flag()}.

Then, inside of the program main loop, height of the ground of the
sector {255} is fixed with the function {set_sector_height()}.

{/}

The function {#193,get_sector_height()} allows to find the heights of ground
and ceiling in a mode 8 sector.

{/}See: {#193,get_sector_height()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.193,get_sector_height()}

{get_sector_height(}<number of sector>{,} <OFFSET ground>{,} <OFFSET ceiling>{)}

{Return:}

The {height of the ground and ceiling} of a mode 8 sector (in the variables which
{#1085,offset} is indicated as the two last parameters).

{Description:}

This function allows to determine inside of a program, the height of the ground
and ceiling of a determined sector, inside of a mode 8.

To do this, is required the {<number of sector>}, and the {#1085,OFFSET} (address
of memory) of the two variables in which is going to be given back the result.

This information also can be obtained inside of the editor of three-dimensional maps
which control is explained in the user's manual of the program.

#9999,Example program:}
PROGRAM example_get_sector_height;

GLOBAL
    altura_techo;
    altura_suelo;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtains the heightnesses of a sector

    get_sector_height(255,OFFSET altura_suelo,OFFSET altura_techo);

    // ...
END
{-}

This small example shows how must be call the function {get_sector_height()}
to obtain the heights of a sector (in this case, in the variables {altura_techo}
and {altura_suelo} these values are obtained for the sector number {255}).

{/}

To establish the height of a sector, the function {#192,set_sector_height()} must
be used.

{/}See: {#192,set_sector_height()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.194,set_point_m8()}

{set_point_m8(}<number of vertex>{,} <x>{,} <y>{)}

{Description:}

Modifies the coordinates of a three-dimensional map's vertex of a mode 8.
The following parameters are required:

{<number of vertex>} - Number of vertex of the map which position is wanted to
modified. This number can be obtained in the editor of three-dimensional maps,
which control is explained in de user's manual of the program.

{<x>}, {<y>} - The new coordinates of the vertex must be indicated. The
coordinates inside of a three-dimensional map are placed inside of the rank ({0} ..
{30200}).

To begins a mode 8 region, the function {#190,start_mode8()} must be called.

{/}

{Note:} This is a function which use can flow in multiple
{errors of visibility}. For that, is not recommended it's use by the user
with little experience.

The vertex just can move {inside of the sector} in which are found,
{can't be crossed} (not the vertex, not the lines which these make) and, besides,
the sectors which cannot contain processes mustn't be move.

{/}

{#9999,Example program:}
PROGRAM example_set_point_m8;

GLOBAL
    posición1;
    posición2;
    ángulo1;
    ángulo2;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=64;
    LOOP
        posición1=3400+get_distx(ángulo1,150);
        ángulo1+=5000;
        posición2=3400+get_distx(ángulo2,150);
        ángulo2+=7000;

        set_point_m8(1620,posición1,9280); // Fixes the vertex 1620

        set_point_m8(1621,posición2,9456); // Fixes the vertex 1621

        FRAME;
    END
END
{-}

This small example initializes a mode 8 region, loading the map
{wld_view.wld}, and it is placed in the predetermined coordinates with
the function {#191,go_to_flag()}.

Then, inside of the program's main loop, the position of the vertex
{1620} and {1621} is fixed with the function {set_point_m8()}.

{/}

The function {#195,get_point_m8()} allows to find the coordinates of a vertex
of a three-dimensional map to mode 8.

{/}See: {#195,get_point_m8()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.195,get_point_m8()}

{get_point_m8(}<number of vertex>{,} <OFFSET x>{,} <OFFSET y>{)}

{Returns:}

The {coordinates of a vertex} of a mode 8 map (in the variables which
{#1085,offset} is indicated as the two last parameters).

{Description:}

This function allows to determine inside of a program, the coordinates of
a determined vertex, inside of a mode 8.

To do this, is required the {<number of vertex>}, and the {#1085,OFFSET} (address
of memory) of the two variables in which must be given back the result.

This information also can be obtained inside of the editor of three-dimensional
maps, which control is explained in the user's manual of the program.

{#9999,Example program:}
PROGRAM example_get_point_m8;

GLOBAL
    posición_x;
    posición_y;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtains a vertex's coordinates

    get_point_m8(1620,OFFSET posición_x,OFFSET posición_y);

    // ...
END
{-}

This small example shows how must be called the function {get_point_m8()}
to obtain the height of a sector (in this case, in the variables {posición_x}
and {posición_y}).

{/}

To establishes the positions of a vertex, the function {#194,set_point_m8()} must
be used.

{/}See: {#194,set_point_m8()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.196,set_fog()}

{set_fog(}<Initial position>{,} <Final position>{)}

{Description:}

Modifies the fog of a mode 8 initiated with the function {#190,start_mode8()},
to do this, the following parameters are required:

{<Initial position>} - Percentage or initial distance of the fog (from 0 to 100),
in this way, is determined from which point the effect is applicated.

{<Final position>} - Percentage or final distance of the fog (from 0 to 100),
in this way, is determined from which point the fog is solid.

Normally the position or final percentage is established as the double
of the initial, as much distanced are the values, the more slowly the fog
will introduce.

{#9999,Example program:}
PROGRAM example_set_fog;

GLOBAL
    niebla;
    ángulo1;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  FRAME;
  z+=128;
  LOOP
      niebla=25+get_distx(ángulo1,20);
       ngulo1+=5000;

      set_fog(niebla,niebla*2); // Establishes the fog level of the mode 8

      FRAME;
  END
END
{-}

This small example shows how must be called the function {set_fog()}
to modify the fog of a mode 8 region.

The variable {niebla} varies from {5} to {45} (using the function
{#118,get_distx()}), this will be the initial position, the final one
will be fixed at the double of the initial one.

{/}

{Note:} The function {#201,set_env_color()} allows to fix the ambience color
or the fog color of a mode 8 region.

{/}See: {#201,set_env_color()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.197,set_sector_texture()}

{set_sector_texture(}<number of sector>{,} <ground texture>{,} <ceiling texture>{,} <luminosity>{)}

{Description:}

Modifies the {textures of ground and ceiling} of a mode 8 sector. The following
parameters are required:

{<number of sector>} - Number of map sector which textures are wanted to be
modified. This number can be obtained in the editor of three-dimensional maps,
which control is explained in the user's manual of the program.

{<ground texture>} - The code of the graphic must be indicated if is wanted
to asign as new {ground texture} of the sector (the number of the graphic
inside of the FPG which contains every texture of the mode 8). If a { -1} is
indicated as parameter the current texture will remain (to modify just
the ceiling texture).

{<ceiling texture>} - The code of the graphic must be indicated if is wanted
to asign as new {ceiling texture} of the sector (the number of the graphic
inside of the FPG which contains every texture of the mode 8). If a { -1} is
indicated as parameter the current texture will remain (to modify just
the ground texture).

{<luminosity>} - Luminosity of the texture, of {0} (ambience color, which
is normally black) up to {15} (texture with the original colors).
If a { -1} is indicated, the current level of luminosity in the sector will remain.

{/}

{Note:} every texture must be contained in a same archive FPG,
this is the archive which is loaded with {#132,load_fpg()} and which number is
given as parameter of the function {#189,load_wld()}.

{/}

{#9999,Example program:}
PROGRAM example_set_sector_texture;

GLOBAL
    textura=94;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=128;
    m8.angle=-64;
    LOOP
        IF (textura++==103) textura=94; END

        set_sector_texture(255,textura,-1,15);

        FRAME;
    END
END
{-}

This small example starts a mode 8 region, loading the map
{wld_view.wld}, and the predetermined coordinates are placed with
the function {#191,go_to_flag()}.

Then, inside of the program main loop, the ground texture of the sector
{255} is fixed with the function {set_sector_texture()}.

{/}

The function {#198,get_sector_texture()} allows to find which are the textures
(and luminosity) that has a mode 8 sector.

The function {#199,set_wall_texture()} allows to establish the texture of a wall.

{/}See: {#198,get_sector_texture()} - {#199,set_wall_texture()} - {#192,set_sector_height()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.198,get_sector_texture()}

{get_sector_texture(}<number of sector>{,} <OFFSET ground texture>{,} <OFFSET ceiling texture>{,} <OFFSET luminosity>{)}

{Return:}

The {luminosity, and the textures of ground and ceiling} of a mode 8 sector
(in the variables which {#1085,offset} is indicated as the parameters).

{Description:}

This function allows to determine inside of a program which are the textures
of the ground and the ceiling or the luminosity of a determined sector, inside of a
mode 8.

To do this, is required the {<number of sector>}, and the {#1085,OFFSET} (address
of memory) of the variables in which is going to be given back the result.

{#9999,Example program:}
PROGRAM example_get_sector_texture;

GLOBAL
    textura_suelo;
    textura_techo;
    luminosidad;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtains the luminosity and textures of a sector

    get_sector_texture(255,OFFSET textura_suelo,OFFSET textura_techo,OFFSET luminosidad);

    // ...
END
{-}

This small example shows how must be called the function {get_sector_texture()}
to obtain the textures and the luminosity of a sector (in this case, in the variables
{textura_techo}, {textura_suelo} and {luminosidad} these values are obtained to the
sector number {255}).

{/}

The function {#197,set_sector_texture()} allows to establish the textures and luminosity
of a mode 8 sector dinamically.

The function {#200,get_wall_texture()} allows to find which is the texture of a mode 8
wall.

{/}See: {#197,set_sector_texture()} - {#200,get_wall_texture()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.199,set_wall_texture()}

{set_wall_texture(}<number of sector>{,} <texture>{,} <luminosity>{)}

{Description:}

Modifies the {wall texture} of a mode 8. The following parameters are
required:

{<number of wall>} - Number of wall of the map which texture is wanted to be 
modified. This number can be obtained in the editor of three-dimensional maps,
which control is explained in the user's manual of the program.

{<texture>} - The code of the graphic which is wanted to be asigned as a new wall
texture (the number of the graphic inside of the FPG which contains every mode 8 texture) 
must be indicated. If a { -1} is indicated as parameter, the current texture will remain.

{<luminosity>} - Luminosity of the texture, of {0} (ambience color, which is
normally black) up to {15} (texture with the original colors).
If a { -1} is indicated, the current level of luminosity will remain.

{/}

{Note:} every texture must be contained in the same archive FPG,
this is the archive which is loaded with {#132,load_fpg()} and which number is given
as parameter to the function {#189,load_wld()}.

{/}

{#9999,Example program:}
PROGRAM example_set_wall_texture;

GLOBAL
    textura=104;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=128;
    LOOP
        IF (textura++==113) textura=104; END

        set_wall_texture(511,textura,15); // Modifies a wall texture

        FRAME;
    END
END
{-}

This small example starts a mode 8 region, loading the map
{wld_view.wld}, and it is placed in the predetermined coordinates with the
function {#191,go_to_flag()}.

Then, inside the program main loop, the texture of the wall number {255} 
is fixed with the function {set_wall_texture()}.

{/}

The function {#200,get_wall_texture()} allows to find which is the texture
of a wall.

The function {#197,set_sector_texture()} allows to establish the {textures of
ground and ceiling} of a mode 8 sector.

{/}See: {#200,get_wall_texture()} - {#197,set_sector_texture()} - {#192,set_sector_height()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.200,get_wall_texture()}

{get_wall_texture(}<number of wall>{,} <OFFSET texture>{,} <OFFSET luminosity>{)}

{Return:}

The {luminosity and the texture} of a mode 8 wall (in the variables
which {#1085,offset} is indicated in the parameters).

{Description:}

This function allows to determine inside of a program, which is the texture
and the luminosity of a determined wall, inside of a mode 8.

To that, is required the {<number of wall>}, and the {#1085,OFFSET} (memory
address) of the variables in which is going to be given back the result.

{#9999,Example program:}
PROGRAM example_get_wall_texture;

GLOBAL
    texture;
    luminosity;

BEGIN
    load_fpg("HELP\WLD_VIEW.FPG");
    load_wld("HELP\WLD_VIEW.WLD",0);
    // ...

    // Obtains the luminosity and texture of a wall

    get_wall_texture(255,OFFSET texture,OFFSET luminosity);

    // ...
END
{-}

This small example shows how must be called the function {get_wall_texture()}
to obtain the texture and the luminosity of a sector (in this case, in the variables
{texture} and {luminosity} this values are obtained to the wall number {255}).

{/}

The function {#199,set_wall_texture()} allows to establish the texture and luminosity
of a mode 8 wall dynamically.

The function {#198,get_sector_texture()} let us know which are the textures of floor
and ceiling of a mode 8 sector.

{/}See: {#199,set_wall_texture()} - {#198,get_sector_texture()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.201,set_env_color()}

{set_env_color(}<% red>{,} <% green>{,} <% blue>{)}

{Descripction:}

Modify the color of the ambience or fog of a mode 8, to do this are required
the components {<red>} (red), {<green>} (green) and {<blue>} (blue) of itself.

The three components must be specified as percentage, from {0} to {100}.

By default, the fog is established of black color (0,0,0), but this color can
be modified to create different ambience.

{#9999,Example program:}
PROGRAM example_set_env_color;

GLOBAL
    light;
    angle1;

BEGIN
  load_fpg("HELP\WLD_VIEW.FPG");
  load_wld("HELP\WLD_VIEW.WLD",0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  FRAME;
  set_fog(30,90);
  z+=128;
  LOOP
      light=50+get_distx(angle1,50);
      angle1+=5000;

      set_env_color(light,light,light); // establishes the ambience color

      FRAME;
  END
END
{-}

This small example shows how must be called the function {set_env_color()}
to modify the fog color of a mode 8 region.

The variable {light} varies from {0} to {100} (using the function {#118,get_distx()}), 
and this percentage is fixed for the three components of the color, so this will
appear from {black} to {white}, going through all the gray scale.

{/}

{Note:} The function {#196,set_fog()} allows to fix the density of the fog or ambience
of a mode 8 region.

{/}See: {#196,set_fog()} - {#190,start_mode8()} - {#1411,STRUCT m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.202,strcpy()}

{strcpy(}<string destination>{,} <string origin>{)}

{Return:}

Copies a string and returns to the address of the string destination.

{Description:}

Copies the {<string origin>} over the {<string destination>}, from its beginning
(the content of this last one will be lost).

The {<string destination>} must be a data of the type {#1406,STRING}, of a length
enough to contain the text of the {<string origin>}.

{#9999,Example program:}
PROGRAM example_strcpy;

GLOBAL
    STRING string1="Initial text";

BEGIN
    write(0,0,0,0,"Text contained in <string1>:");
    write(0,0,10,0,string1);
    write(0,0,192,0,"Press [SPACE] to copy another text in <string1>");
    LOOP
        IF (key(_space))

            strcpy(string1,"Final text"); // Modifies string1

        END
        FRAME;
   END
END
{-}

{/}

When the length of the copied string is smaller than 1024 characters, this
same operation can be done with a statement as the following one:
(continuing with the previous example):

  {string1 = "Final text";}

With a generic statement of {#1019,asignation} as the following:

  {<string destination> = <string origin> ;}

Being always {<string destination>} of a data of type {#1406,STRING}. To join some
text strings in one the function {#203,strcat()} must be used.

{/}See: {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.203,strcat()}

{strcat(}<string destination>{,} <string origin>{)}

{Return:}

Joins two strings and returns the address of the string destination.

{Description:}

Joins two text strings, copying the {<string origin>} after the text contained
in the {<string destination>}.

The {<string destination>} must be a data of type {#1406,STRING}, of a length
enough to contain both strings.

{#9999,Example program:}
PROGRAM example_strcat;

GLOBAL
    STRING string1="Begining ";

BEGIN
    write(0,0,0,0,"Text contained in <string1>:");
    write(0,0,10,0,string1);
    write(0,0,192,0,"Press [SPACE] to add a text to <string1>");
    LOOP
        IF (key(_space))

            strcat(string1,"Final"); // Adds a text to string1

        END
        FRAME;
   END
END
{-}

{/}

When the length of the resultant string is smaller than 1024 characters, this same
operation can be done with a statement as the following:
(continuing with the previous example):

  {string1 = string1 + "Final";}

  (or)

  {string1 += "Final";}

With a generic statement of {#1019,asignation} (or with the symbol
{#1058,+=}, of operative asignation) as the following:

  {<string destination> = <string destination> + <string origin> ;}

  (or)

  {<string destination> += <string origin> ;}

Being always {<string destination>} a data of type {#1406,STRING}.

{/}

To copy text strings, the function {#202,strcpy()} must be used.

To separate (or substrate) text strings, the function {#211,strdel()}
must be used.

{/}See: {#202,strcpy()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.204,strlen()}

{strlen(}<text string>{)}

{Return:}

The length of the string, in characters (with spaces included).

{Description:}

Counts the number of characters of the text given as parameter, or contained
currently in the passed string.

The {<text string>} can be a literal (text between quotation marks) or a data of
any other type.

{#9999,Example program:}
PROGRAM example_strlen;

GLOBAL
    STRING string1="Text example";
    length_string1;

BEGIN
    write(0,0,0,0,"Text contained in <string1>:");
    write(0,0,10,0,string1);
    write(0,0,20,0,"Length of <string1>:");

    length_string1=strlen(string1); // calculates the length

    write_int(0,0,30,0,OFFSET length_string1);
    LOOP
        FRAME;
    END
END
{-}

{/}

A charater can be added to a string with the function {#203,strcat()}, or
with a statement of {#1019,asignation} as the following:

  {string1+="a";}

To quit characters of a string must be used {#211,strdel()}, although
is possible to eliminate characters of the end of a string with statements
as the following:

  {string1--;}ú
  {string1-=1;}ú
  {string1=string1-1;}ú

{/}See: {#202,strcpy()} - {#203,strcat()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.205,strcmp()}

{strcmp(}<string1>{,} <string2>{)}

{Return:}

{ +n} - If the first string is bigger than the second.ú
{  0} - If the strings are equivalent.ú
{ -n} - If the first string is smaller than the second.ú

{Description:}

Compares two text strings, character per character, giving back {0} when
both strings are equivalent.

{#9999,Example program:}
PROGRAM example_strcmp;

GLOBAL
    STRING mystring;

BEGIN
    // ...

    IF (strcmp(mystring,"abc")==0)

        // The two strings are equivalent ...

    END

    // ...
END
{-}

{/}

The comparison of strings can be done, only if the strings have less than 
1024 characters, with the typical operators of comparison of the language.

For example, the comparison of the previous example could be done with the
following statement:

  {IF (mystring=="abc")}ú
  {//...}ú
  {END}ú

In the same way, the symbol {#1046,<>} can be compared if the two strings
are different, with the symbols {#1069,<} or {#1072,<=} if a string is smaller,
or equivalent to another, etc.

{/}

To search for a string inside another (to see if it is contained in it), the 
function {#207,strstr()}, must be used, and to see if a string contains any character
the function {#206,strchr()} must be used.

{/}See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.206,strchr()}

{strchr(}<text string>{,} <characters>{)}

{Return:}

 { -1} If no character was found inside of the string.ú
 { +n} If one of the characters was found in the position {n} of the string.

{Description:}

Searches one or some {<characters>} in a {<text string>}. If it receives the
string as first parameter and, as second, one or some characters in a 
literal (between quotation marks).

This function will determinate if the string contains any of the characters and,
in afirmative case, will indicate in which position appears the character inside the
string (from 0). In case of appear the character in more than one ocassion, the function
will return always to the first position.

{#9999,Example program:}
PROGRAM example_strchr;

GLOBAL
    STRING mystring="FGHIJK";
    position;

BEGIN
    write(0,0,0,0,"First vocal of <mystring> in the position:");

    position=strchr(mystring,"AEIOU");

    write_int(0,0,10,0,OFFSET position);
    LOOP
        FRAME;
    END
END
{-}

In this example the function {strchr()} is used to determinate the first vocal
of {mystring} is the position {3} of the string.

{/}

The characters of a data of {#1406,STRING} can be accessed always as if this would
be a board of characters. For example, to change in the data {mystring} of the
previous example, the character "I" for a character "-" the following statement
could be used:

  {mystring[3]=char("-");}

To convert a charater, contained in a literal, in its ordinal value (ASCII)
the function {#184,char()} is used.

{/}

To determinate if a string is completely contained in another (if appears as
a substring inside of the same), the function {#207,strstr()} must be used.

{/}See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.207,strstr()}

{strstr(}<string of text>{,} <substring>{)}

{Return:}

 { -1} If the substring wasn't found inside of the string.ú
 { +n} If it was found in the position {n} of the text string.

{Description:}

Searches the sequence of characters contained in the {<substring>} in a
{<text string>}.

This function will determinate if the string contains the substring (as "HOUSE"
contains "USE") and, in afirmative case, will indicate in which position appears
the substring inside of the string (from 0, 1 in the previous example).
In case of appear the substring in more than one ocassion, the function will return
always to the first position.

{#9999,Example program:}
PROGRAM example_strstr;

GLOBAL
    STRING mystring="This is an example string.";
    position;

BEGIN

    position=strstr(mystring,"is");

    write_int(0,0,10,0,OFFSET position);
    LOOP
        FRAME;
    END
END
{-}

In this example is used the function {strstr()} to determinate where is found
the substring {"is"} inside {mystring}, it will return the position {5}.

{/}

To realize changes from capital letters to small letters
the functions {#209,upper()} and {#210,lower()} can be used.

{/}

To determine if a string contains a concrete character, the function
{#206,strchr()} must be used, which, besides, allows to search in just one
action any character inside the specified group.

{/}See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#208,strset()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.208,strset()}

{strset(}<text string>{,} <character>{)}

{Description:}

Asigns to every position of the {<string>} the {<character>} indicated as
second parameter.

The function can receive the {<character>} in two ways; as a literal (the
character between quotation marks), or as its ordinal (its ASCII value) which must be
a value between {0} and {255}.

The complete string will be started with this character. The length of the string
depends of the indicated value between "[]" in its initiation, in case of
don't have the length of the data of type {#1406,STRING}, a string of
{256} characters will be created (from the position 0 to 255).

{#9999,Example program:}
PROGRAM example_strset;

GLOBAL
    STRING mystring="This is an example string.";

BEGIN
    write(0,0,0,0,"content of <mystring> (press space to change it):");
    write(0,0,10,0,mystring);
    LOOP
        IF (key(_space))

            strset(mystring,"*"); // Fills up the string with "*"

        END
        FRAME;
    END
END
{-}

{/}

To calculate the current length of a string, the function {#204,strlen()} will be used.

To delete characters of a string (from the beginning and from the end) the function
{#211,strdel()} must be used.

{/}See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#209,upper()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.209,upper()}

{upper(}<string or character>{)}

{Return:}

If a character correspondent to a small letter is receipt, gives back the
same character but as capital letter.

{Description:}

converts a string (or just a character) to capital letters, including the special
characters, like the letter "ñ" or the acentuated vocals.

This function can works in two ways, depending of the parameter which receives:

- If it receives a text string (or literal between quotation marks), will convert to
capital letters every contained character in the string and won't give back
any significant value (just the cursor of the receipt string).

- If it receives just one character (its ordinal value or ASCII), will give back the
character converted in capital letter (but just its ordinal value), and the function
won't change any data in memory.

{#9999,Example program:}
PROGRAM example_upper;

GLOBAL
    STRING mystring="This is an example string.";
    BYTE   mylettter="a";

BEGIN

    upper(mystring); // converts a string to capital letters
    upper(myletter);  // converts a character to capital letters

    write(0,0,0,0,mystring);
    write(0,0,10,0,OFFSET myletter);
    LOOP
        FRAME;
    END
END
{-}

This example has defined two global data ({mystring} and {myletter}), the
function {upper()} will be used to convert it to capital letters, and then
will be shown on screen.

{/}

This function won't modify those characters which are not small letters.

{/}

The function {#210,lower()} is the opposite to {upper()}, because it can coverts
a string (or a character) to small letters.

{/}See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#210,lower()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.210,lower()}

{lower(}<string or character>{)}

{Return:}

If a character is given to a capital letter, it returns the
character changed to small letter.

{Description:}

Converts a string (or a simple character) into small letters, including the
special characters, like the letter "ñ" or the stressed vocals.

This function can works in two modes, depending of the parameter given:

- If it receives a text string (or literal between quotation marks), will change into
small letters every character contained in the string and won't return any
significative value (just the cursor of the string given).

- If it receives just a character (its ordinal value or ASCII), will give back
the character changed into small letter (its ordinal value), and the
function won't change any data in memory.

{#9999,Example program:}
PROGRAM example_lower;

GLOBAL
    STRING mystring="THIS IS AN EXAMPLE STRING";
    BYTE   myletter="A";

BEGIN

    lower(mystring); // Changes a string into small letters
    lower(myletter);  // Changes a character into small letters

    write(0,0,0,0,mystring);
    write(0,0,10,0,OFFSET myletter);
    LOOP
        FRAME;
    END
END
{-}

This example has defined two global data ({mystring} and {myletter}), the 
function {lower()} will be used to convert them into small letters, and
then will be shown on screen.

{/}

This function won't modify those character which are not capital letters.

{/}

The function {#209,upper()} is the opposite to {lower()}, because it can changes
a string (or a character) into capital letters.

{/}See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#211,strdel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.211,strdel()}

{strdel(}<string of text>{,} <initial substraction>{,} <final substraction>{)}

{Description:}

This function deletes character of a {<string of text>}. Will be eliminated
{<initial substraction>} characters from the beginning of the string and {<final substraction>}
characters from the end of it.

To eliminate just characters from the beginning of the string must be indicated
{0} as {<final substraction>}, and to eliminate just the end, {0} as {<initial
substraction>}.

{#9999,Example program:}
PROGRAM example_strdel;

GLOBAL
    STRING mystring="This is an example string.";

BEGIN

    strdel(mystring,5,9);

    write(0,0,0,0,mystring);
    LOOP
        FRAME;
    END
END
{-}

This example uses the function {strdel()} to eliminate the first {5}
characters of {<mystring>} and the last {9}, to, then, show the resultant string
on screen ("is an examp").

{/}

{Note:} If a quantity of characters is negative (for the beginning or
for the end), the function will add spaces to the string.

{/}

Also is possible to eliminate characters from the end of a string with statements
as the following:

  {string1--;}ú
  {string1-=1;}ú
  {string1=string1-1;}ú

{/}See: {#202,strcpy()} - {#203,strcat()} - {#204,strlen()} - {#205,strcmp()} - {#206,strchr()}
- {#207,strstr()} - {#208,strset()} - {#209,upper()} - {#210,lower()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.212,screen_copy()}

{screen_copy(}<region>{,} <file>{,} <graphic>{,} <x>{,} <y>{,} <width>{,} <height>{)}

{Description:}

Copies a screen region to a region of any graphic.

This is a potent function that can be very useful, because it gives
"feedback" of the computer screen, can send an image of the screen to a graphic
(opposite operation to the normal).

First must be define the number of rectangular {<region>} which is going to be
copied of the screen (of the previous image of the program), these regions are defined
with the function {#106,define_region()}. The {region number 0} always is related to
the entire screen.

Then, must be indicated the graphic where is going to be transfered the image
with the parameters {<file>} and {<graphic>} (the file will be the number 0, if the
graphic belongs to the first FPG loaded, or if it has been loaded in a separated
way).

Finally, will be indicated {the zone inside the graphic} to which must be
transfered the image. This will be defined as {<x>}, {<y>}, {<width>} and {<height>}, related
to the coordinates inside of the graphic (being the coordinates [0,0] its upper left
corner).

{#9999,Example program:}
PROGRAM example_screen_copy;

GLOBAL
    ángulo;
    ángulo2;

BEGIN
    load_fpg("help\help.fpg");
    graph=2;
    x=160;
    y=100;
    put(0,graph,x,y);
    LOOP

        // Copies the screen (region 0) to the graphic 2

        screen_copy(0,0,2,0,0,320,200);

        ángulo+=1000;
        ángulo2+=1971;
        angle=get_distx(ángulo,25000);
        size=95+get_disty(ángulo2,30);
        FRAME;
    END
END
{-}

In this example the file of graphics is loaded, in which the {graphic number 2} is
a cell of different colors, to place it on screen and define it as graphic
of the main process, which will rotate and change its size
(depending of the {angle} and {angle2}, respectively).

Then is when is used the function {screen_copy()} to send again the
image of screen to this graphic, so this effect happens.

{/}

{Note:} The {size} of the screen region (the transfered zone) and the one of the
graphic region (where is transfered) {doesn't have to match}. The function
{screen_copy()} will do a {reduction} or {ampliation} when it is needed to adjust
the size of the transfered zone.

{/}See: {#106,define_region()} - {#103,clear_screen()} - {#1126,graph}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.213,qsort()}

{qsort(}<estructure name>{,} <field name>{,} <mode>{)}

{Description:}

Orders or desorders a program structure for one of its fields.

It is a simple but useful function which allows the quick
order and desorder of data structures.

Its use is very simple, just is required the {<name of the structure>},
the one of the {<field which is going to be used as index>}, and the {<ordenation mode>};
one of the indicated now:

{0} - Ascendent ordenation (from min to max).

{1} - Descendent ordenation (from max to min).

{2} - Random desordenation

Any of the data contained in the structure can be used as index field, without
depending if it is a numeric data or a string of text (in which case will be
ordenated alphabetically)

{#9999,Example program:}
PROGRAM example_qsort;

GLOBAL

  STRUCT mystructure[9];
    STRING name[32];
    points;
    x,y;
  END

BEGIN

  //...

  // Orders the registers of mystructure, to being placed the one
  // of biggest score at the beginning

  qsort(mystructure,points1);

  //...

END
{-}

This example shows the easy use of the function {qsort()} to order
a structure, that can represent any type of object inside of a
program.

It is not necessary that the field used as index ({points} in this case)
be the first of the structure.

{/}

{Note:} The desorder of a structure requires a field which makes 
differences between the different registers of the same. This operation can be
useful to give "randomness" to a program (for example, to "mix"
a deck of cards).

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.214,load_song()}

{load_song(}<name of archive>{,} <replay>{)}

{Return:}

Identifier of the loaded song, or -1 if happens an error.

{Description:}

Loads a song from an archive MOD, S3M or XM, to its later reproduction.

The function requires the name of the archive which contains the music module,
and if this one must be reproduced just one time (indicating {0} in {<replay>}) or
indefinitely (indicating {1}).

These music modules can be composed with multiple shareware programs
or freeware programs. In DIV Games Studio can be reproduced, in the created programs,
but cannot be created new modules.

{#9999,Example program:}
PROGRAM example_load_song;

GLOBAL
    id_canción;

BEGIN

    load_song("help\help.xm",1); // Loads a XM module, with replay

    song(id_canción);
    write(0,0,0,0,"Press ESC to finish");
    REPEAT
        FRAME;
    UNTIL (key(_ESC));
    unload_song(id_canción);
END
{-}

This example loads the module contained in the archive {help.xm} with the
function {load_song()}, indicating that this one must be reproduced indefinitely.
The reproduction of the archive is begun with a call to the function {#216,song()}.

To delete a song from memory, the function {#215,unload_song()} must be used, 
if every program created in DIV Games Studio will liberate all the occupied memory
automatically when the program finishes.

The volume of reproduction can be controled with the function {#178,set_volume()} 
and the data contained in the {#1104,setup structure}.

{/}

{Note:} With this version of DIV Games Studio comes included some archives of freeware 
music modules in the directory {MOD}.

{/}

{Note:} To reproduce songs contained in a track of CD-Audio the functions
{#144,play_cd()} and {#164,stop_cd()} must be used.

{/}See: {#215,unload_song()} - {#216,song()} - {#144,play_cd()} - {#1104,Setup estructure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.215,unload_song()}

{unload_song(}<identifier of the module>{)}

{Description:}

Deletes from memory the music module which identifier is given as
parameter. This {<identifier of the module>} is the value which returns the
function {#214,load_song()} when is loaded in memory.

After being deleted a module {you must be very cautious}
for not use it again in the program, because the program
would crash.

{It is not necessary to delete the modules} before finishing the program
because the system will do it automatically.
So, just must be deleted from memory the modules which are not going to be
used in a determined time and is wanted to liberate the space filled in the
computer memory to load another resorts (other files of graphics, sounds, 
fonts, etc).

{#9999,Example program:}
PROGRAM example_unload_song;

GLOBAL
    id_canción;

BEGIN
    load_song("help\help.xm",1);
    song(id_cancion);
    write(0,0,0,0,"Press ESC to finish");
    REPEAT
        FRAME;
    UNTIL (key(_ESC));

    unload_song(id_canción); // Sets free the filled memory by the module

END
{-}

This example loads the module contained in the archive {help.xm} with the
function {#214,load_song()}. The reproduction of the archive is indicated with a
call to the function {#216,song()}.

The program will stay reproducing this module until the {ESC} key is pressed
moment in which will be finished the main loop and the module is deleted
from memory with the memory {unload_song()}, indicating as parameter 
{id_cancion} which contains the {identifier of the module}
given back when loaded.

{/}

{Note:} The songs contained in CD-Audio tracks, which reproduction
is begun with the function {#144,play_cd()}, don't fill computer memory,
so they cannot be deleted with the function {unload_song()}.

{/}See: {#214,load_song()} - {#216,song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.216,song()}

{song(}<identifier of the module>{)}

{Description:}

Starts the reproduction of a music module loaded with the function
{#214,load_song()}. The function will receive as only parameter the {<identifier
of the module>} to reproduce.

Just can be reproduced a module at the same time, if the reproduction of another
starts, the previous one, will stop. But can be played at the same time a music
module, a CD-Audio track (see {#144,play_cd()}) and multiple sound effects (see {#159,sound()}).

The reproduction always will be realized from the beginning of the module (the beginning
of the song). To reproduce any part of the module must be called
to the function {#218,set_song_pos()}, which fixes the position from the module will be
reproduced.

{#9999,Example program:}
PROGRAM example_song;

GLOBAL
    id_canción;

BEGIN
    load_song("help\help.xm",1);

    song(id_canción); // Starts the reproduction of the music module

    write(0,0,0,0,"Press ESC to finish");
    REPEAT
        FRAME;
    UNTIL (key(_ESC));
    unload_song(id_canción);
END
{-}

This example loads the module contained in the archive {help.xm} with the
function {#214,load_song()}, indicating that this must be reproduced
indefinitely (this must be indicated in the archive's load).

Then the reproduction of the archive begins with the function {song()}.

The program will enter then in a loop in which will stay playing
this module, until the {ESC} key is pressed and the program finishes.

The volume of reproduction can be controlled with the function
{#178,set_volume()} and the contained data in the {#1104,setup estructure}.

{/}

{Note:} To finish the reproduction of a music module the function
{#217,stop_song()} must be used.

{/}

{Note:} The function {#222,is_playing_song()} can find if the module is being reproduced.


{/}See: {#214,load_song()} - {#217,stop_song()} - {#144,play_cd()} - {#159,sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.217,stop_song()}

{stop_song(}{)}

{Description:}

Stops the reproduction of the music module (MOD, S3M or XM) which is being played.
This function doesn't require any parameter, because only can be reproduced
in the music module at the same time.

It is not essential to stop the reproduction of a music module before being
deleted from memory (operation made with the function {#215,unload_song()}), 
this action is made automatically.

{#9999,Example program:}
PROGRAM example_stop_song;

GLOBAL
    id_canción;

BEGIN
    load_song("help\help.xm",1);
    song(id_canción);
    write(0,0,0,0,"Press SPACE to stop the song ...");
    LOOP
        IF (key(_space))

            stop_song(); // Stops the module

        END
        FRAME;
    END
    unload_song(id_canción);
END
{-}

This example loads the module contained in the archive {help.xm} with the
function {#214,load_song()}. The reproduction of the archive begins with 
call to the function {#216,song()}.

The program will enter then in a loop in which will stay playing
this module, until the space bar is pressed which makes a call to {stop_song()}
and the module finishes.

To delete a song from memory the function {#215,unload_song()} must be used, 
all the programs created in DIV Games Studio will liberate the
filled memory automatically at the end.

{/}

{Note:} To stop a song of CD-Audio the function {#164,stop_cd()} is used, and to
make it with a sound effect, the function {#167,stop_sound()}.

{/}

{Note:} The function {#222,is_playing_song()} can find if a module is reproducing.

{/}See: {#216,song()} - {#214,load_song()} - {#144,play_cd()} - {#159,sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.218,set_song_pos()}

{set_song_pos(}<position of the module>{)}

{Description:}

Fixes the position of the music module reproduction (the number of "pattern").

This {<position of the module>} is a number between 0 and the max number of
{pattern} of the module. This value varies to each module, and can be defined in the
programs used to compose them. The modules usually have a quite variable number of 
patterns, though the average can be situated between 30 and 40.

Inside each pattern, the modules have a determined number of lines
(normally 64), in which appear the musical notes, so each pattern could be
defined as a small section of the music module.

To obtain the current position which is being reproduced the function
{#219,get_song_pos()} is used.

The position of the module can be changed if the module is playing or stopped.
This function can be used to advance or to gives back the reproduction of the module,
to implement diverse loops in certain parts of a module, etc.

{#9999,Example program:}
PROGRAM example_set_song_pos;

GLOBAL
    id_canción;
    posición_módulo;

BEGIN
    load_song("help\help.xm",1);
    song(id_canción);
    write(0,0,0,0,"Press SPACE to change the position of the module ...");
    write(0,0,20,0,"Posición:");
    write_int(0,0,30,0,OFFSET posición_módulo);
    LOOP
        IF (key(_space))
            posición_módulo=rand(0,19);

            set_song_pos(posición_módulo); // Changes the position of the module

        END
        posición_módulo=get_song_pos();
        FRAME;
    END
END
{-}

This program loads the module contained in the archive {help.xm} and then
starts its reproduction with the function {#216,song()}.

>From this moment will be shown the current position of the module on screen
and it can be changed pressing the space bar (a random position will be asigned
between 0 and 19, because this module has 20 patterns).

{/}

{Note:} Can't be fixed the reproduction line of a module (inside
each pattern), but the value can be obtained with the function
{#220,get_song_line()}.

{/}See: {#219,get_song_pos()} - {#216,song()} - {#214,load_song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.219,get_song_pos()}

{get_song_pos(}{)}

{Return:}

The current position of the musical module which is reproducing.

{Description:}

Return the current position of reproduction of the musical module, this
position can be fixed with the function {#218,set_song_pos()}.

This {<position of the module>} is the number between 0 and the max number of
{pattern} of the module. This value is different for each module, and is defined
in the programs used to compose them. The modules often have
very variable number of patterns, although the middle can be between 30 and 40.

Inside each pattern the modules have a determined number of lines
(normally 64), in which appear the musical notes, therefore
each pattern can be defined as a small section of musical module.

{#9999,Example program:}
PROGRAM example_get_song_pos;

GLOBAL
    id_song;
    position_module;

BEGIN
    load_song("help\help.xm",1);
    song(id_song);
    write(0,0,0,0,"Position of the module:");
    write_int(0,0,10,0,OFFSET position_module);
    LOOP

        posicion_modulo=get_song_pos(); // Obtain the position

        FRAME;
    END
END
{-}

This program loads the module contained in the archive {help.xm} and then
initiates its reproduction with the function {#216,song()}.

>From this moment will be shown the current position of the module on screen,
obtained with the function {get_song_pos()}.

{/}

{Note:} Can be obtained the number of line which is reproducted, inside the pattern,
with the function {#220,get_song_line()}.

{/}See: {#220,get_song_line()} - {#218,set_song_pos()} - {#216,song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.220,get_song_line()}

{get_song_line(}{)}

{Return:}

The number of line of musical module.

{Description:}

With this function can be obtained the number of line of musical module
which is reproducted (inside the position, or current pattern).

This current position, or pattern, can be obtained with the function
{#219,get_song_pos()}.

Inside each pattern the modules have a determined number of lines
(normally 64), in which appear musical notes. The modules
often have different number of patterns, although the middle can be between 30 and 40.

{#9999,Example program:}
PROGRAM example_get_song_line;

GLOBAL
    id_song;
    line_module;

BEGIN
    load_song("help\help.xm",1);
    song(id_song);
    write(0,0,0,0,"Line of module:");
    write_int(0,0,10,0,OFFSET line_module);
    LOOP

        line_module=get_song_line(); // Obtain the number of line

        FRAME;
    END
END
{-}

This program loads the module contained in the archive {help.xm} and then
initiates its reproduction with the function {#216,song()}.

From this moment is shown the current line of module in screen,
obtained with help of the function {get_song_line()}.

{/}

{Note:} Cannot be fixed the line of musical module, although if it is possible to fix
the position beginning with which must be reproduced with the function
{#218,set_song_pos()} (always will begin in the line 0 of the pattern).

{/}See: #219,get_song_pos()} - {#218,set_song_pos()} - {#216,song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.221,is_playing_sound()}

{is_playing_sound(}<number of channel>{)}

{Return:}

{0} - If the channel is stoped.ú
{1} - If is going the sound by the channel.

{Description:}

This function allows to know if one of the {sound channels} are reproducing sound or if it is disposed.

Is required as parameter the {<number of channel>}, this value is obtained as
return of the function {#159,sound()} after initiate the reproduction of the sound effect.

{#9999,Example program:}
PROGRAM example_is_playing_sound;

GLOBAL
    sound;
    channel;

BEGIN
    write(0,0,0,0,"Press ESC to finish.");
    sonido = load_pcm("help\help.pcm",0);
    canal  = sound(sonido, 256, rand(100,400));
    REPEAT

        // If finish the reproduction, return the sound

        IF (NOT is_playing_sound(channel))

            canal = sound(sound, 256, rand(100,400));
        END
        FRAME;
    UNTIL (key(_ESC));
END
{-}

This example uses a function to touch continually sound, 
controled by the program, instead of automatically (what is often made
indicating in the loading of sound that this cycle, in the functions
{#134,load_pcm()} or {#134,load_wav()}).

The reproduction again initiates always when the channel of sound is free,
it means, each time when is finished to reproduce one effect.

The program uses this circumstance (manual control the replay)
to emit the sound with the different frequence in each case, this couldn't be done
with the automatic replay. This frequence is obtained as
the value between 100 and 400 with the function {#149,rand()}.

{/}

{Note:} The same sound can be reproduced by different channels each time,
therefore is necessary to save the number of channel each time when is initiated the reproduction.

{/}See: {#159,sound()} - {#102,change_sound()} - {#222,is_playing_song()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.222,is_playing_song()}

{is_playing_song(}{)}

{Return:}

{0} - Any module is playing.ú
{1} - Is playing a musical module.

{Description:}

This function permits to determine if is reproducing a digital musical module
of the archive MOD, S3M or XM.

These modules must be loaded with the function {#214,load_song()} and their
reproduction is initiated with the call to {#216,song()}.

Only can be reproduced one module at the same time, therefore this function
doesn't require any parameter, only returns {1} if there is one module
reproducing.

{#9999,Example program:}
PROGRAM example_is_playing_song;

GLOBAL
    id_song;
    sounding;

BEGIN
    load_song("help\help.xm",1);
    song(id_song);
    write(0,0,0,0,"ENTER initiate the module / SPACE to stop it");
    write_int(0,0,10,0,OFFSET sounding);
    LOOP
        IF (key(_enter)) song(id_song); END
        IF (key(_space)) stop_song(); END

        sonando = is_playing_song(); // Determines if is playing

        FRAME;
    END
END
{-}

This example loads musical module contained in the archive {help.xm} and
permits, inside one loop, initiate it with the key {ENTER} and stop it with
the space bar.

Inside the same loop is used the function {is_playing_song()} to
determine if it is playing each moment.

{/}

{Note:} To finish the reproduction of one musical modul must be used the function {#217,stop_song()}.

{/}See: {#214,load_song()} - {#216,song()} - {#221,is_playing_sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.223,fopen()}

{fopen(}<name of archive>{,} <mode>{)}

{Return:}

The {handle} or identifier of open archive, or {0} if was produced an error.

{Description:}

Open an archive of the disk to read or write, using the system
of access with help of {handle} or {identifier of archive} which this function
returns from the open or created archive.

Is required the {<name of archive>} to open or create, and the {<mode>} of openning,
which must be a literal (text in inverted commas) inside the following:

 "{r}" - Open the archive for reading of the data contained in it.

 "{w}" - Create the archive to write (if exists, will loose its last contained).

 "{a}" - Open the archive to write after finish it, or it creates if it didn't exist.

 "{r+}" - Open a existent archive to actualize it, permiting reading and writting.

 "{w+}" - Create a file to write, permiting also its reading.

 "{a+}" - Open an archive to read it in any position and write in its end.

Once an archive is opened, can be used all functions of archives
based in {handles}, but once were realized the necessary operations
in the file {must not be closed}, using for it the function
{#224,fclose()}.

The main functions are {#225,fread()} for reading the data inside
the archive and {#226,fwrite()} to write the data; is important to
open the archive in appropriate {mode} for the realized operations.
It means, for example you can not write in the file if it was opened only for reading.

{#9999,Example program:}
PROGRAM example_fopen;

GLOBAL
    board1[3]=11,22,33,44;
    board2[3];
    mihandle;

BEGIN

    mihandle=fopen("help\help.dat","w"); // Open archive to write

    fwrite(OFFSET tabla1,4,mihandle);
    fclose(mihandle);

    mihandle=fopen("help\help.dat","r"); // Open archive to read

    fread(OFFSET tabla2,4,mihandle);
    fclose(mihandle);
END
{-}

This example program has defined two global boards; {board1} with four values
initiated in 11, 22, 33 and 44, and {board2} with four without initiate (in zero).

Are used the functions of archives to write in one archive the content
of the {board1} and then load it over the {board2}. After finish the program,
will be copied the data of the first board in the second.

Is calling to the function {fopen()} in two ocasions, the first to {create it and
write} in it and the second to {open it and read} its contain.

It is important to underline that each time when you open or create the archive, you must
close it with the function {#224,fclose()} (can be seen how in the example
the archive is closed in two occasions).

{/}

The function {#227,fseek()} allows to situate the {pointer of reading/writing}
in any position of the archive. This way, can be read or written
data of any point of the archive.

{/}

The function {#230,flush()} empty the buffers of writting and allows also
to check how many archives are opened in each moment.

{/}

{Note:} The functions {#155,save()} and {#130,load()} allow also
to save the data in archives of the disk and restore them. These functions are
less useful, but their use is easier than
the functions based in {handles} here described.

{/}See: {#224,fclose()} {#225,fread()} - {#226,fwrite()} - {#155,save()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.224,fclose()}

{fclose(}<handle>{)}

{Return:}

Number of closed archives.

{Description:}

Close an opened archive with the function {#223,fopen()}, for it must 
receive as parameter the {handle} or {identifier of archive} returned
by this function.

In the second modality, the function {fclose()} can {close all opened
archives} in one time, for it must be only indicated {0}
(zero) as parameter, instead of {handle}.

Anyway, the function returns the number of archives which were closed,
if it returns {0} can be one of these cases:

{ -} There were no open archive.ú
{ -} The passed {handle} doesn't correspond to any opened archive.
{ -} The archive corresponding to this {handle} was already closed.

All open archives must be closed before the program finishes its execution.

{#9999,Example program:}
PROGRAM example_fclose;

GLOBAL
    board1[3]=11,22,33,44;
    board2[3];
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET tabla1,4,mihandle);

    fclose(mihandle); // The archive closes to be opened in other mode

    mihandle=fopen("help\help.dat","r");
    fread(OFFSET tabla2,4,mihandle);

    fclose(mihandle); // The archive closes definitively
END
{-}

Are used the functions of archives to write in one archive the content
of the {board1} and then load it over the {board2}. After finish the program,
will be copied the data of the first in the second.

If the open archive of one mode (with the function {#223,fopen()}) wants to
access to other different mode, first must be closed for return to open it
in the new mode; as it succeeds in the example, is closed the
archive of writting to open it then in reading mode.

{/}

The function {#230,flush()} empties the buffers of writting and permits also
check how many archives are open in each moment.

{/}Ver: {#223,fopen()} {#225,fread()} - {#226,fwrite()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.225,fread()}

{fread(}<OFFSET data>{,} <length>{,} <handle>{)}

{Return:}

{0} - If was produced an error, or were not read all asked data.ú
{1} - If were read all data.

{Description:}

This function permits to read the data of one open archive with the function
{#223,fopen()}, from the position indicated by the {pointer of
reading/writting}.

The archive must be opened in the {reading mode}, or which it permits.

The {pointer} is situated in the beginning of the archive, after open it,
and advances secuencially during are reading the data. But
this pointer can be situated in any position,
using the function {#227,fseek()} and the function {#228,ftell()} permits
to obtain the current position of the pointer of an archive.

The function {fread()} requires as parameter the {<}{#1085,OFFSET}
{of the data>} in which must be read the data of archive, it means,
the address of memory from where must be placed the data which are reading from the archive.

As second parameter is required the {<length>} or total size of the data
which you want to read, it means, the number of positions of memory
which occupy these data. The length of one data can be obtained with the
function {#1094,sizeof()}.

The last parameter must be the {handle} or {identifier of archive} which
was obtained after open the archive as value of return of {#223,fopen()}.

{#9999,Example program:}
PROGRAM example_fread;

GLOBAL
    board1[3]=11,22,33,44;
    board2[3];
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET tabla1,4,mihandle);
    fclose(mihandle);
    mihandle=fopen("help\help.dat","r");

    fread(OFFSET tabla2,4,mihandle); // Read the archive about <board2>

    fclose(mihandle);
END
{-}

This example program has defined two global boards; {board1} with four
values initiated in 11, 22, 33 y 44, and {board2} with four without initiate
(in zero).

Are used the functions of archives to write in one archive the content
of the {board1} and then load it over the {board2}. After finish the program,
will be copied the data of the first board in the second.

Is calling to the function {#223,fopen()} in two ocasions, the first to {create it and
write} in it and the second to {open it and read} its contained.

It is important to underline that each time when you open or create the archive, you must
close it with the function {#224,fclose()} (can be seen how in the example
the archive is closed in two ocasions).

{/}

The inverse function to {fopen()}, it means, which permits to write data in
one archive instead of read them, is {#226,fwrite()}. The way to use this
function and its parameters are similar to those of {fread()}.

{/}

{Note:} By default, the {<length>} is specified as the number of simple data,
remembering that a simple data (a variable) occupies {4
bytes}. It means, if for example, are read ten data (indicating 10 as
length), will be read 40 bytes.

This relation can be changed modificating the global variable {#1420,unit_size},
which default values {4} in all programs.

{/}See: {#223,fopen()} - {#226,fwrite()} - {#227,fseek()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.226,fwrite()}

{fwrite(}<OFFSET data>{,} <length>{,} <handle>{)}

{Return:}

{0} - An error was produced or the data was not written.ú
{1} - If all the data was written.

{Description:}

This function allows to write data inside an opened archive with the function
{#223,fopen()}, from the indicated position by the {cursor of reading/writting}.

The archive must have been opened in a {written mode}.

The {cursor} is placed at the beginning of the archive, when openned or when 
the same is created, and advances secuencially as the data are written.
But this cursor of the archive can be placed in each position
using the function {#227,fseek()} and the function {#228,ftell()} allows to
obtain the current position of an archive cursor.

The function {fwrite()} requires as first parameter the {<}{#1085,OFFSET}
{of the data>} which must be written in the archive, so, the address of memory.

As second parameter is required the {<length>} or total size of the
data which are wanted to be written, the number of memory positions
which fill these data. The length of a data can be obtained with the
function {#1094,sizeof()}.

The last parameter must be the {handle} or {identifier of archive} which
was obtained when the archive was opened as return value of {#223,fopen()}.

{#9999,Example program:}
PROGRAM example_fwrite;

GLOBAL
    mitabla[3]=11,22,33,44;
    myhandle;

BEGIN
    myhandle=fopen("help\help.dat","w");

    fwrite(OFFSET board1,4,myhandle); // Writes <mitabla> in the archive

    fclose(myhandle);
END
{-}

This example program writes the contained data in {<mitabla>} in the archive
{help.dat} of the disk.

The function {#223,fopen()} is called to create it and to the function {#224,fclose()}
to close it once every data has been written.

{/}

The opposite function to {fwrite()}, the one that allows to write data in
an archive instead of read them, is {#225,fread()}. The way to use this function
and its parameters are the same to the {fwrite()}.

{/}

{Note:} By default, the {<length>} is specified as the number of simple data
thinking that a simple data (a variable) fills {4 bytes}. So, if for example, 
ten data are written (indicating 10 as length), then 40 bytes will be written.

This relation can be change modifying the global variable {#1420,unit_size},
which, by default is {4} in every program.

{/}See: {#223,fopen()} - {#225,fread()} - {#227,fseek()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.227,fseek()}

{fseek(}<handle>{,} <cursor position>{,} <mode>{)}

{Description:}

Places the {cursor of reading/writting} of an archive in the indicated position.

The function requires, first, the {<handle>} or {identifier of the archive}
given back by the function {#223,fopen()} when opened.

In second place is specified the new position in which must be placed the
{<cursor>} of the archive. After being called to this function, every reading or
writting operation which are made, from this position.

As last paratemer must be indicated the {<mode>} in which is specified
the new position of the cursor, can be one of the following three:

 {seek_set} - Position related to the beginning of the archive (0).ú
 {seek_cur} - Increment related to the current position (1).ú
 {seek_end} - Position related to the end of the archive (2).ú

To obtain the current situation of an archive cursor, the function
{#228,ftell()} must be used.

Every operation of reading or writting about an archive is done
automatically, so all these accesses are realized secuencially (reading or
writting the data one after another).

{#9999,Example program:}
PROGRAM example_fseek;

GLOBAL
    mitabla[3]=11,22,33,44;
    midato;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET mitabla,4,mihandle);
    fclose(mihandle);
    mihandle=fopen("help\help.dat","r");

    // Places the cursor to read the fourth data of the archive (44)

    fseek(mihandle,3,seek_set);

    fread(OFFSET midato,1,mihandle);
    fclose(mihandle);
END
{-}

This example writes the four data contained in {mitabla} (11,22,33 and 44)
in the archive {help.dat}, after this, opens the archive to reading and uses
the function {fseek()} to place the cursor in the {position 3} from the
beginning of the archive (with {seek_set}).

>From this moment, can be read from the fourth data of the archive, due to 
this, when a value is read in the variable {midato} this will be {44},
the fourth value of the board.

{/}

{Note:} By default, the {<position of the cursor>} is specified as a
number of simple data, thinking that a simple data (a variable)
fills {4 bytes}. What if, for example, is placed as cursor in the tenth position
from the beginning of the file, and then the program can access to the data 
from the byte fourty.

The relation can be changed, modifying the global variable {#1420,unit_size},
because by default is {4} in every program.

{/}See: {#228,ftell()} - {#225,fread()} - {#226,fwrite()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.228,ftell()}

{ftell(}<handle>{)}

{Return:}

The current position of the cursor of reading/writting of an archive.

{Description:}

Returns the position of the {reading/writting cursor} of an archive, to that,
is required just the {<handle>} or {identifier of archive} given back by the
function {#223,fopen()} to open it.

To establish a new position of an archive cursor, the function {#227,fseek()}
must be used. Opposite to this last function, {ftell()} always gives back
the position of the cursor, related to the beginning of the archive.

Every operation of reading or writting about an archive
goes forward automatically the cursor of the same, so every access is
done secuencially (reading or writting the data one after another).

{#9999,Example program:}
PROGRAM example_ftell;

GLOBAL
    mitabla[3]=11,22,33,44;
    midato1;
    midato2;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");

    midato1=ftell(mihandle); // Position of the cursor before writting

    fwrite(OFFSET mitabla,4,mihandle);

    midato2=ftell(mihandle); // Position of the cursor after being written the data

    fclose(mihandle);
END
{-}

This example writes the four data contained in {mitabla} (11,22,33 y 44)
in the archive {help.dat}.

After open the archive with {#223,fopen()} the position of the cursor is obtained
and it is saved in {midato1} (this will be 0, at the beginning of the archive).

Then, the four values contained in the board are written in the archive and the
position of the cursor is obtained again, which now is saved in {midato2} (will be
4, at the end of the archive, after the four written values).

Finally, the archive is closed with {#224.fclose()} before ends.

{Note:} By default, the {<position of the cursor>} is specified as a
number of simple data, thinking that a simple data (a variable)
fills {4 bytes}. What if, for example, is placed as cursor in the tenth position
from the begining of the file, and then the program can access to the data
from the byte fourty.

The relation can be changed, modifying the global variable {#1420,unit_size},
because by default is {4} in every program.

{/}

{Nota:} The function {#229,filelength()} allows to find the length of an
archive, to do this, this must be opened first.

{/}See: {#227,fseek()} - {#225,fread()} - {#226,fwrite()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.229,filelength()}

{filelength(}<handle>{)}

{Return:}

The length of the archive

{Description:}

This function allows to obtain the length of an archive previously opened
with {#223,fopen()}, to do this requires as parameter the {<handle>} or
{identifier of archive} given back by this function.

This function doesn't modify the current position of the reading/writting
cursor of the archive, simply gives back the number of data
contained actually in the same.

{#9999,Example program:}
PROGRAM example_filelength;

GLOBAL
    mitabla[3]=11,22,33,44;
    longitud;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");
    fwrite(OFFSET mitabla,4,mihandle);
    fclose(mihandle);
    mihandle=fopen("help\help.dat","r");

    longitud=filelength(mihandle); // Obtains the length of the archive (4)

    fclose(mihandle);
END
{-}

This example program creates first an archive called {help.dat},
writting on it the four values contained in {mitabla}.

Once created the archive on disk, it will be opened to obtain its {length}.

{/}

{Note:} By default, the {length of the archive} is obtained as the number of
simple data that contains, thinking that a simple data (a variable)
fills up {4 bytes}. If, for example, the length of an archive is ten
will occupy fourty bytes in the disk.

The relation can be changed modifying the global variable {#1420,unit_size},
which by default is {4} in every program.

{/}

{Note:} The functions {#231,get_dirinfo()} and {#232,get_fileinfo()} allows to 
obtain a lot of information about the structure of directories (folders)
of the disk and about the archives contained on it.

{/}See: {#223,fopen()} - {#231,get_dirinfo()} - {#1420,unit_size}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.230,flush()}

{flush(}{)}

{Return:}

The number of opened archives.

{Description:}

Empties the buffers of write, makes that every data written 
to an archive of disk which still are in the cache of write are saved
phisically in its correspondent archive.

This operation is not very necessary, because the administration of the
cache that the operative system makes, is very effective and the data are not 
going to be losen never due to don't be written correctly in the disk.

But, this function has another utiliy. It will give back the {number
of archives opened with} {#223,fopen()} inside of a program.

The system of archives allows just a maximum number of opened archives
which depend on the system configuration.

Every archive must be closed with {#224,fclose()} once the needed operation has been
done with each one of them. This last function allows to close just one archive,
or everyone which is opened.

{#9999,Example program:}
PROGRAM example_flush;

GLOBAL
    midato1;
    midato2;
    mihandle;

BEGIN
    mihandle=fopen("help\help.dat","w");

    midato1=flush(); // Obtains the number of opened archives (1)

    fclose(mihandle);

    midato2=flush(); // Obtains the number of opened archives (0)

END
{-}

This example obtains in two ocassions the number of opened archives with 
the function {flush()}. After being opened the archive {help.dat} the
function determines that there is one opened and, once closed,
could be checked that there isn't anyone open.

{/}See: {#223,fopen()} - {#224,fclose()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.231,get_dirinfo()}

{get_dirinfo(}<mask of directory>{,} <types of archive>{)}

{Return:}

Number of archives of the directory which coincides with the mask and the
type selected.

{Description:}

This function allows to obtain the list of archives of a directory (folder)
of the disk.

Is required the {<mask of directory>} to select the archives
which must be listed. This {<mask>} is just a name of a partial archive
using jokers; for example, the mask {"*.*"} (must be indicated as a text
between quotation marks) it will select every archive of the directory.

Also can be included in the mask, the {access route} of the directory (in
the opposite case the archives of the directory will be listed in the current directory). 
For example, the mask {"C:\WINDOWS\SYS*.??E"} will select every archive of the
directory {"C:\WINDOWS"} which name starts with {"SYS"} and which extension finishes
with {"E"}.

As second parameter must be indicated the {<types of archives>} which must
be included in the list, these are the following:

{ _normal} - To list just the normal archives.ú
{ _hidden} - To include also the hidden archives.ú
{ _system} - To include also the archives of system.ú
{ _subdir} - To include also the subdirectories.ú
{ _volid}  - To list just the label of the volume.ú

The most common is to indicate {_normal} as {<type of archives>}, this type
joins to the most part of archives which appear in a disk, as if it is
of reading/writting or just of reading (only are excluded some special archives
which, normally are internal system archives).

If there are indicated {_hidden}, {_system} or {_subdir}, this types of archives
will be included besides of the normal archives (it's not necessary to specify {_normal}).
Besides, can be added these types; for example, indicating {_hidden+_system}
will be listed every normal archive, the hidden and the system archives.

When is indicated {_volid}, just will be listed the name of the volume label
of the disk, won't be included any archive not subdirectory in the
list (can't be added other types to this).

{/}

The function {get_dirinfo()} simply returns the {total number} of listed archives
the names of these archives are saved in the global structure
{#1413,dirinfo} (the first name of the archive is saved in {dirinfo.name[0]}, the
second in {dirinfo.name[1]}, etc.).

The {total number} of listed archives which returns back this function is saved
besides in {dirinfo.files}.

The list of archive names is saved always in alphabetic order, but the function
{#213,qsort()} can be used to order the global structure {#1413,dirinfo} 
with any other criteria.

{/}

This function just allows to obtain the {names} of the archives, to
obtain further information of them (the atributes, the size, the data,
etc.) the function {#232,get_fileinfo()} must be used.

{#9999,Example program:}
PROGRAM example_get_dirinfo;

GLOBAL
    contador;

BEGIN
    write(0,0,0,0,"List of archives - Press ESC to finish");

    get_dirinfo("C:\WINDOWS\*.EXE",_normal); // Obtains the list of archives

    FOR (contador=0;contador<dirinfo.files;contador++)
       x=(contador%4)*80;
       y=16+(contador/4)*8;
       write(0,x,y,0,dirinfo.name[contador]);
    END

    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

This example program lists every normal archive {EXE} of the directory
C:\WINDOWS, and then shows them on screen.

The loop {#1025,FOR} is the one that shows on screen the list of the
archives of the structure {#1413,dirinfo} to four colums, because the function
{get_dirinfo()} doesn't show any information on screen, just fills up the
structure with the names of the archives, found in the directory.

{/}

To open or create an archive the function {#223,fopen()} can be opened.

To change of directory, must be used {#235,chdir()}, and
{#236,mkdir()} to create a new one.

The function {#238,disk_free()} allows to find the free space in a unit disk.

{/}See: {#232,get_fileinfo()} - {#223,fopen()} - {#235,chdir()} - {#236,mkdir()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.232,get_fileinfo()}

{get_fileinfo(}<name of the archive>{)}

{Return:}

{0} - Can't obtain the information about the archive.ú
{1} - The information about the archive was saved correctly.ú

{Description:}

Obtains the information about an archive or directory of the disk, to that,
the function requires the {<name of the archive>} as parameter (between quotation
marks). Just can be indicated the name, or included besides the access route to
the same.

If the function finds the archive in the specified directory (or in
the current one, in case of not being specified anyone), will return back {1} and will
save every information about the archive in the global structure {#1414,fileinfo},
which contains the following fields:

{ fullpath} - Complete name (including the route).ú
{ drive}    - Disk unit (1-A:, 2-B:, 3-C:, ...).ú
{ dir}      - Directory of the archive.ú
{ name}     - Name of the archive.ú
{ ext}      - Extension of the archive.ú
{ size}     - Size (in simple data, see {#1420,unit_size}).ú
{ day}      - Day (data of the last actualization).ú
{ month}    - Month (data of the last actualization).ú
{ year}     - Year (data of the last actualization).ú
{ hour}     - Hour (hour of the last actualization).ú
{ min}      - Minute (hour of the last actualization).ú
{ sec}      - Second (hour of the last actualization).ú
{ attrib}   - Attributes of the archive.ú

The route of access to the archive can be completely specified (from the
main directory of the unit, as "C:\WINDOWS\...") or relative to the current 
directory (from which is executed the game, likes "MAP\MIOS\...").
Anyway, in {fileinfo.fullpath} always will be back the complete route
from the main directory, including the letter of the unit.

{/}

The function {get_fileinfo()} just obtains information about an archive,
to obtain the complete list of archives of a directory, the function
{#231,get_dirinfo()} must be used.

{#9999,Example program:}
PROGRAM example_get_fileinfo;
BEGIN
    // ...

    get_fileinfo("HELP\HELP.FPG");

    // ...
END
{-}

This small example asks for information about the file {help.fpg}
contained in the directory {help}. It can be extracted and trazed (with {F12})
to see how, after the call to the function, the global structure
predefinied {#1413,fileinfo} has been filled up with every data of the archive.

{/}

To open or create an archive the function {#223,fopen()} can be used,
and to delete an archive of the disk the function {#237,remove()} can be used.

The function {#238,disk_free()} allows to know the free space of any unit.

{/}See: {#231,get_dirinfo()} - {#223,fopen()} - {#237,remove()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.233,getdrive()}

{getdrive(}{)}

{Return:}

The number of the current unit.

{Description:}

This function allows to determine which is the unit that is being
used currently, this is given back as a number, corresponding the
{1} to the unit {A:}, the {2} to {B:}, {3} to {C:}, etc. There are
not parameters required in the call.

The function {#234,setdrive()} allows to establish the current unit;
every access to disk (reading and writting archives) are done
always inside of the selected unit which, by default, will be the unit
in which the program is executed.

{#9999,Example program:}
PROGRAM example_getdrive;

GLOBAL
    unidad;

BEGIN
    write(0,0,0,0,"Current unit:");

    unidad=getdrive();

    write_int(0,0,20,0,OFFSET unidad);
    LOOP
        FRAME;
    END
END
{-}

This program shows on screen the number of the current unit obtained
with the function {getdrive()}.

{/}

To change the directory must be used {#235,chdir()}, and
{#236,mkdir()} to create a new one.

The function {#238,disk_free()} allows to know the free space which rests
in a unit.

{/}See: {#234,setdrive()} - {#235,chdir()} - {#236,mkdir()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.234,setdrive()}

{setdrive(}<unit>{)}

{Description:}

This function allows to establish the current unit; every access to the
disk (reading and writting of archives) which are done always
inside of the unit which, by default, will be the unit
where the program was executed.

The {<unit>} must be indicated with a number, corresponding
the {1} with the unit {A:}, the {2} with {B:}, {3} the {C:}, etc. Won't give back
any value.

The function {#233,getdrive()} allows to obtain the number of the current unit.

{#9999,Example program:}
PROGRAM example_setdrive;

GLOBAL
    unidad;

BEGIN
    // ...

    unidad=getdrive();

    setdrive(1);      // Is placed in the unit A:

    // ...

    setdrive(unidad); // Recovers the previous unit

    // ...
END
{-}

This program first, obtains the current unit with the function {#233,getdrive()}
and saves it in the variable {unit}, then is placed in the unit {1} (A:)
to, finally, go back to the unit in which the program is being executed.

{/}

{Note:} When a unit is changed with {setdrive()} no value is given back,
but after {#233,getdrive()} can be called to check that the program
has been placed in the asked unit.

{/}

To change the directory must be used {#235,chdir()}, and
{#236,mkdir()} to create a new one.

The function {#238,disk_free()} allows to know the free space of any unit.

{/}See: {#233,getdrive()} - {#235,chdir()} - {#236,mkdir()} - {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.235,chdir()}

{chdir(}<directory>{)}

{Return:}

{1} - The indicated directory was changed.ú
{0} - Can't be read this directory.

{Description:}

Changes the current directory, inside of the selected unit.

The directory must be indicated as a literal (a text between quotation marks), and
can be a relative route (from the current directory) or an absolute route
(from the main directory).

The ways of use and posibilities of this function are the same of the
command {CD} of the commands line of the operative system.

Each program is placed at the beginning in the directory where
is found the main executable.

In the structure of a disk can be created new directories (or folders)
with the function {#236,mkdir()}, and with the function {#237,remove()} can
be eliminated the others.

{#9999,Example program:}
PROGRAM example_chdir;
BEGIN
    chdir("MAP"); // Is placed in the directory MAP\

    // ...

    chdir("..");  // Comes back to the previous directory
END
{-}

This small example shows how the function {chdir()} must be used
to change the directory.

{/}

The function {#234,setdrive()} allows to establish the current unit
and the function {#233,getdrive()} to know it; every access to the disk
(reading and writting of archives) is done always inside the selected
unit which, by default, will be the unit in which is being executed the program.

{/}

{Note:} The list of a directory's archives can be obtained with the
function {#231,get_dirinfo()}.

{/}See: {#236,mkdir()} - {#237,remove()} - {#234,setdrive()} - {#233,getdrive()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.236,mkdir()}

{mkdir(}<directory>{)}

{Description:}

Creates a new directory (inside of the current directory or folder).

This must indicate the name of the directory when is created as literal (a text
between quotation marks).

The way of using and posibilities of this function are the same
that of the command {MD} of the commands line of the operative system.

Each program is placed at the beginning of the directory where
is found the main executable.

The directory where the program is placed (in which will be realized their 
archives operations) with the function {#235,mkdir()}, and with the function 
{#237,remove()} can be eliminated the other directories.
.
{#9999,Example program:}
PROGRAM example_mkdir;
BEGIN
    mkdir("temporal"); // Creates a new directory

    // ...
    remove("temporal");
END
{-}

This small program shows how must be used the function {mkdir()} to create
a directory, and then it is eliminated with the function {#237,remove()}.

{/}

The function {#234,setdrive()} allows to establish the current unit
and the function {#233,getdrive()} to know it; every access to disk
(reading and writting of archives) is done always inside the selected 
unit which, by default, will be the unit in which the program is executed.

{/}

{Note:} The directory's list of archives can be obtained with the function
{#231,get_dirinfo()}.

{/}See: {#235,chdir()} - {#237,remove()} - {#234,setdrive()} - {#233,getdrive()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.237,remove()}

{remove(}<name of archive or directory>{)}

{Description:}

Deletes archives or subdirectories contained inside of the current directory
in which the program is executed.

Must be indicated the {<name of archive or directory>} in a literal (a text
between quotation marks), also are accepted the joker characters "?" y "*" (as
for example "*.bak" to eliminate every archive with the extension BAK).

Will be eliminated always the archives inside of the current directory (see {#235,chdir()}
to change the directory) and of the current unit (see {#234,setdrive()} to change
the unit).

With this function also can be eliminated directories, but just
if they are empty (if there are no archives or other subdirectories inside).

{/}

{Note:} This function must be used with more caution, because the archives
deleted cannot be recovered, and can be lost information or programs
contained in the disk.

{/}

{#9999,Example program:}
PROGRAM example_remove;
BEGIN
    mkdir("temporal");
    // ...

    remove("temporal"); // Deletes a directory
END
{-}

This small example creates a directory with the function {#236,mkdir()} and then
eliminates it with the function {remove()}.

{/}

{Note:} The directory's list of archives can be obtained with the function
{#231,get_dirinfo()}.

{/}See: {#235,chdir()} - {#234,setdrive()} - {#231,get_dirinfo()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.238,disk_free()}

{disk_free(}<unit>{)}

{Return:}

The free space of the unit.

{Description:}

This function allows to determine the free space of any unit.

Is required the number of {<unit>} as only parameter, the
{1} with the unit {A:}, the {2} with {B:}, {3} with {C:}, etc.

The remain space in the unit returns back in {Kbs} (in kilobytes,
being each one a total of 1024 bytes).

The current unit can be known (the one where the program is being
executed) thanks to the function {#233,getdrive()}.

{#9999,Example program:}
PROGRAM example_disk_free;

GLOBAL
    unidad;
    espacio_libre;

BEGIN
    // ...

    unidad=getdrive();
    espacio_libre=disk_free(unidad);

    // ...
END
{-}

This program uses first the function {#233,getdrive()} to
determine in which unit is being executed the program (which
is stored in the variable {unit}), and then determines the free 
space of that unit with {disk_free()}.

{/}

To obtain the size of the disk archives must be used with the
functions {#231,get_dirinfo()} and {#232,get_fileinfo()}.

{/}

{Note:} The function {#239,memory_free()} allows to determine the free memory
the quantity of memory that is available for the program.

{/}See: {#233,getdrive()} - {#239,memory_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.239,memory_free()}

{memory_free(}{)}

{Return:}

The free memory available for the program.

{Description:}

This function allows to determine the computer's RAM memory that is
available to the use of the program.

It is not required any parameter, and the total of memory is returned in Kbs
(in kilobytes, being each one a total of 1024 bytes).

This quantity of memory will be available for the program to load
all its resorts (graphics, sounds, etc.), for that, is convenient to
check with this function, at the begining of the programs, that the computer
has enough memory to load every necessary resort.

{#9999,Example program:}
PROGRAM example_memory_free;

GLOBAL
    memoria_libre;

BEGIN
    // ...

    memoria_libre=memory_free();

    // ...
END
{-}

This small example uses the function {memory_free()} to save it in the
global variable denominated {free_memory} the quantity of RAM available
for the program.

{/}

{Note:} The function {#238,disk_free()} allows to determine the free space
of any computer unit.

{/}See: {#238,disk_free()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.240,ignore_error()}

{ignore_error(}<n£mero de error>{)}

{Description:}

This function allows to ignore a determined execution error,
is required as parameter the {<number of error>}; this is the present
number in the informative window of an error which appears in ocassions
when a program is being executed.

At the beginning is not recommendable to ignore the execution errors,
because the program cannot work correctly, without giving any information
relative to the error.

When a program produces an execution error, is always for a solutionable 
reason; and to ignore the error won't solve the problem.

{/}

{Note:} Not all the errors can be ignored, there are some errors which
make impossible for the program to run correctly. This are the errors
denominated "serious", which will abort always the program in case of happens.

{/}

{#9999,Example program:}
PROGRAM example_ignore_error;
BEGIN

    ignore_error(145); // To ignore the divisions by zero

    x=x/0;
END
{-}

In this example is called to the function {ignore_error()} to advice 
system that, from now, must ignore the divisions by zero
(these will be an indetermined result).

Now a division by zero is made, to check that the program doesn't emit
any informative window of the error.

This error is number {145}, the same can be seen with the call to the
function {ignore_error()} of the previous example.

{/}

{List of codes of the execution errors:}

{100} There is not enough memory to run the program.ú
{101} Call to key() with a nonexistent key code.ú
{102} The palette was not loaded, archive not found.ú
{103} An invalid archive of palette was loaded.ú
{104} Too many files FPG are opened at the same time.ú
{105} The file was not loaded, archive not found.ú
{106} An invalid FPG archive was loaded.ú
{107} Number of scroll invalid (must be between 0 and 9).ú
{108} Number of region invalid (out of range).ú
{109} Code of file invalid.ú
{110} Code of graphic invalid.ú
{111} A file FPG was used before load it.ú
{112} A code of graphic is needed for the scroll.ú
{113} Too many fonts have been loaded.ú
{114} The font was not loaded, archive not found.ú
{115} An invalid font archive was loaded.ú
{116} Identifier code of fonts invalid.ú
{117} Code of text centre invalid.ú
{118} There are too many texts activated in the program.ú
{119} Indentifier of text invalid.ú
{120} Screen region is defined incorrectly.ú
{121} Nonexistent graphic was used.ú
{122} A block out of memory was written.ú
{123} The archive for writting isn't opened.ú
{124} Can't write in the archive (check space in disk).ú
{125} A block out of memory was read.ú
{126} Can't open the archive for reading.ú
{127} Can't read the archive.ú
{128} Can't load the sound effect.ú
{129} Can't play the wanted sound effect.ú
{130} Can't start the wanted animation.ú
{131} Number of mode 7 invalid (must be between  0 and 9).ú
{132} A code of graphic for the mode 7 is needed.ú
{133} Number of checkpoint invalid.ú
{134} Number of botton incorrect (must be between 0 and 3).ú
{135} Number of axis incorrect (must be between 0 and 3).ú
{136} Address of the board of palette out of memory.ú
{137} Can't check regions in mode 7 graphics.ú
{138} Code of graphic information incorrect.ú
{139} Can't check collisions in mode 7 graphics.ú
{140} Access out of rank.ú
{141} An invalid process was accessed..ú
{142} The process looks like block, waiting FRAME.ú
{143} Can't load the map, archive not found.ú
{144} An invalid archive of map was loaded.ú
{145} A division by zero was made.ú
{146} The size of the region is incorrect.ú
{147} Can't load FLI/FLC, archive not found.ú
{148} Value of timeout incorrect (must be between 1 and 60).ú
{149} Number of players incorrect (must be between 2 and 8).ú
{150} Only can be sent global data.ú
{151} Size of the square invalid (must be between 1 and 256).ú
{152} Map of searching invalid (from 1x1 to 128x128).ú
{153} Size of the map incorrect (from 1x1 to 32768x32768).ú
{154} Number of color incorrect (must be from 0 to 255).ú
{155} The center is outside of the graphic limits.ú
{156} The object is outside of the map and will be eliminated.ú
{157} Map texture not found.ú
{158} Texture size incorrect.ú
{159} Can't load the world, archive not found.ú
{160} Can't load the world, archive not valid.ú
{161} Flag number invalid.ú
{162} Dispositive invalid (just 1-IPX,2-SERIAL,3-MODEM).ú
{163} Paquet size invalid (just from 1 to 199).ú
{164} The string of text destination is invalid.ú
{165} Nule cursor was accessed.ú
{166} The access mode to the archive is invalid.ú
{167} Can't load the module.ú
{168} Too many ignored errors.ú
{169} To many archives opened..ú
{170} Identifier of archive (handle) not valid.ú
{171} Value out of rank.ú
{172} Too many graphic objects visualizated.ú
{173} Type of graphic object is not known.ú
{174} Percentage of link out of rank (0..15).ú
{175} Number of graphic object invalid.ú
{176} Error variable of type: Texture of map [a] not found in file [b].ú
{177} Map texture.ú
{178} Not found in file.ú
{179} Too many petitions of dynamic memory were made..ú
{180} The cursor doesn't correspond to any of the reserved blocks.ú
{181} Can't reserve blocks of less than one position.ú
{182} A block outside of the memory was (des)encriptated.ú
{183} Can't be loaded another palette when is forced the current one.ú
{200} Archive with corrupted data, can't be loaded.ú

{/}

{Note:} With the compilation options (see {#1400,Compiler_options}) can be
ignored the errors of execution, but, this practice is not recommendable.

{/}See: {#1400,Compiler_options}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.241,save_map() / save_pcx()}

{save_map(}<file>{,} <graphic>{,} <name of the archive>{)}

{save_pcx(}<file>{,} <graphic>{,} <name of the archive>{)}

{Return:}

{1} - If the archive was loaded successfully.ú
{0} - While saving the archive there was an error.

{Description:}

Creates an archive MAP or PCX from a graphic loaded in memory.

The function requires the codes of {<file>} and {<graphic>} which identify
the graphic, and the {<name of the archive> MAP} or {PCX} which must be created
in the disk containing that image. The name of the archive must be specified
as a literal (a text between quotation marks, as "image.pcx").

The graphics loaded with the functions {#174,load_map()} or {#174,load_pcx()}
(or created with {#188,new_map()}) will be used as if they were from the
first file (the file with the code 0).

The function {save_map()} always creates archives {MAP}, as well as {save_pcx()}
will create just archives {PCX}, {independent from the indicated extension} in the
{<name of the archive>}. If there is no error, the function will create the archive
with the image and will return back {1}.

{/}

These maps can be loaded in the graphical environment of
DIV Games Studio or in the programs, using the functions
{#174,load_map()} o {#174,load_pcx()}.

{/}

{#9999,Example program:}
PROGRAM example_save_map;
BEGIN
    load_fpg("help\help.fpg");

    save_pcx(0,1,"help\help.pcx"); // Creates an archive PCX

END
{-}

This example uses the function {save_pcx()} to create an archive PCX
containing an image previously loaded inside of the file
{help.fpg} with the function {#132,load_fpg()}.

{/}

A graphic can be created with the function {#188,new_map()}, and to
modify a graphic the following functions must be used:

{#135,map_block_copy()} - Transfers a block of a graphic to another.ú
{#136,map_get_pixel()} - Obtains the color of a graphic point.ú
{#137,map_put()} - Puts a graphic into other.ú
{#138,map_put_pixel()} - Fixes the color of one point in a graphic.ú
{#139,map_xput()} - Places a graphic into another, with effects.ú

{/}

{Note:} The function {#253,write_map()} allows to write a text in a 
graphic created in memory (instead of writting it on screen).

{/}See: {#174,load_map/pcx()} - {#176,unload_map/pcx()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.242,sin()}

{sin(}<angle>{)}

{Return:}

The sin of a given angle.

{Description:}

Calculates the sin in thousandths of the angle given as parameter.

The angles are manipulated always in thousandths of degree (see the
{#1044,use of angles in the language}), and the sin will be given back 
in thousandths of degree too (as a value from -1000 to 1000).

For example, {sin(90000)} will give back  {1000}, because the sin of 90 degrees is 1.

{#9999,Example program:}
PROGRAM example_sin;

GLOBAL
    ángulo[15];
    seno[15];
    n;

BEGIN
    write(0,0,0,0,"Angles");
    write(0,160,0,0,"Sins");
    FROM n=0 TO 15;
        ángulo[n] = rand(0, 360000);

        seno[n] = sin(ángulo[n]); // The sin of the angle is calculated

        write_int(0, 0,   20+n*10, 0, offset ángulo[n]);
        write_int(0, 160, 20+n*10, 0, offset seno[n]);
    END
    write(0,0,192,0,"Press ESC to finish ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

This program will print on screen a list of angles, randomly
chosen between 0 and 360000 (from 0 to 360 degrees), and to use the function
{sin()} to calculate the sin of them.

{/}See: {#1035,Expression} - See: {#1044,Use of the angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.243,cos()}

{cos(}<angle>{)}

{Return:}

The cos of a given angle.

{Description:}

Calculates the cos in thousandths the angle given as parameter.

The angles are manipulated always in thousandths of degree (see the
{#1044,use of angles in the language}), and the cos will be given back 
in thousandths of degree too (as a value from -1000 to 1000).

For example, {cos(0)} will give back  {1000}, because the cos of 0 degrees is 1.


{#9999,Example program:}
PROGRAM example_cos;

GLOBAL
    ángulo[15];
    coseno[15];
    n;

BEGIN
    write(0,0,0,0,"Angles");
    write(0,160,0,0,"Cos");
    FROM n=0 TO 15;
        ángulo[n] = rand(0, 360000);

        coseno[n] = cos(ángulo[n]); // The cos of the angle is calculated

        write_int(0, 0,   20+n*10, 0, offset ángulo[n]);
        write_int(0, 160, 20+n*10, 0, offset coseno[n]);
    END
    write(0,0,192,0,"Press ESC to finish ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

This program will print on screen a list of the angles, randomly chosen
between 0 and 360000 (from 0 to 360 degrees), and will use the function
{cos()} to calculate the cos of them.

{/}See: {#1035,Expression} - See: {#1044,Use of the angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.244,tan()}

{tan(}<angle>{)}

{Return:}

The tan of a given angle.

{Description:}


Calculates the tan in thousandths of the angle given as parameter.

The angles are manipulated always in thousandths of degree (see the
{#1044,use of angles in the language}), and the tan will be given back 
in thousandths of degree too (as a value inside of the rank 
{#1177,min_int} ... {#1178,max_int}).

For example, {tan(45000)} will give back  {1000}, because the tan of 45 degrees 
is 1.

{#9999,Example program:}
PROGRAM example_tan;

GLOBAL
    ángulo[15];
    tangente[15];
    n;

BEGIN
    write(0,0,0,0,"Angles");
    write(0,160,0,0,"Tans");
    FROM n=0 TO 15;
         ngulo[n] = rand(0, 360000);

        tangente[n] = tan(ángulo[n]); // calculates the tan of the angle

        write_int(0, 0,   20+n*10, 0, offset ángulo[n]);
        write_int(0, 160, 20+n*10, 0, offset tangente[n]);
    END
    write(0,0,192,0,"Press ESC to finish ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

This program will print on screen a list of the angles, randomly chosen
between 0 and 360000 (from 0 to 360 degrees), and will use the function
{cos()} to calculate the cos of them.

{/}See: {#1035,Expression} - See: {#1044,Use of the angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.245,asin()}

{asin(}<asin>{)}

{Return:}

The asin of a given sin.

{Description:}

Calculates the asin of the sin given as parameter in thousandths, the correspondent
angle to a sin is obtained (opposite operation to the sin, which can be obtained
with the function {#242,sin()}).

The angles are manipulated always in thousandths of degree (see the
{#1044,use of angles in the language}), and the asin will be given back 
in thousandths of degree too (as a value inside of the rank 
{#1177,min_int} ... {#1178,max_int}).

The {<sin>} is required as a value from{ -1000} to {1000} (from -1.0 to +1.0),
and the result is given back as an angle between{ -90000} and {90000} (from -90
to +90 degrees).

{#9999,Example program:}
PROGRAM example_asin;

GLOBAL
    seno[15];
    ángulo[15];
    n;

BEGIN
    write(0,0,0,0,"Sin");
    write(0,160,0,0,"Asin (angle)");
    FROM n=0 TO 15;
        seno[n] = rand(-1000, 1000);

        ángulo[n] = asin(seno[n]); // calculates the asin of a sin

        write_int(0, 0,   20+n*10, 0, offset seno[n]);
        write_int(0, 160, 20+n*10, 0, offset ángulo[n]);
    END
    write(0,0,192,0,"Press ESC to finish ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

This program will print on screen a list of the sins, randomly chosen
between -1000 and 1000 (represented in thousandths), and will use the function
{asin()} to calculate the asin of them.

{/}See: {#1035,Expression} - See: {#1044,Use of the angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.246,acos()}

{acos(}<cos>{)}

{Return:}

The acos of a given cos.

{Description:}

Calculates the acos of the cos given as parameter in thousandths, the correspondent
angle to a cos is obtained (opposite operation to the cos, which can be obtained
with the function {#243,cos()}).

The angles are manipulated always in thousandths of degree (see the
{#1044,use of angles in the language}), for that the asin gives back too in thousandths
(as a value inside of the rank). 

The {<cos>} is required as a value from{ -1000} to {1000} (from -1.0 to +1.0),
and the result is given back as an angle between{ -90000} and {90000} (from 0
to 180 degrees).

{#9999,Example program:}
PROGRAM example_acos;

GLOBAL
    coseno[15];
    ángulo[15];
    n;

BEGIN
    write(0,0,0,0,"Cos");
    write(0,160,0,0,"Acos(angle)");
    FROM n=0 TO 15;
        coseno[n] = rand(-1000, 1000);

        ángulo[n] = acos(coseno[n]); // The acos of a cos is calculated

        write_int(0, 0,   20+n*10, 0, offset coseno[n]);
        write_int(0, 160, 20+n*10, 0, offset ángulo[n]);
    END
    write(0,0,192,0,"Press ESC to finish ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

This program will print on screen a list of the sins, randomly chosen
between -1000 and 1000 (represented in thousandths), and will use the function
{acos()} to calculate the asin of them.

{/}See: {#1035,Expression} - See: {#1044,Use of the angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.247,atan()}

{atan(}<tan>{)}

{Return:}

The atan of a given tan.

{Description:}

Calculates the atan of the tan given as parameter in thousandths, the correspondent
angle to a tan is obtained (opposite operation to the tan, which can be obtained
with the function {#244,tan()}).

The angles are manipulated always in thousandths of degree (see the
{#1044,use of angles in the language}), and the atan will be given back 
in thousandths of degree too.

The {<tan>} is required as a value inside of the rank {#1177,min_int}...
{#1178, max_int} (of -inf to +inf), and the result is given back as an 
angle between{ -90000} and {90000} (from -90 to +90 degrees).

{/}

{Note:} There is another function to calculate the atan called {#248,atan2()},
this function takes as parameters {<x>} and {<y>} and gives back the atan
of {y/x} between -180000 and 180000 (of -180 to 180 degrees).

{/}

{#9999,Example program:}
PROGRAM example_atan;

GLOBAL
    tangente[15];
    ángulo[15];
    n;

BEGIN
    write(0,0,0,0,"Tan");
    write(0,160,0,0,"Atan(ángulo)");
    FROM n=0 TO 15;
        tangente[n] = rand(-1000, 1000);

        ángulo[n] = atan(tangente[n]); // The atan of a tan is calculated

        write_int(0, 0,   20+n*10, 0, offset tangente[n]);
        write_int(0, 160, 20+n*10, 0, offset ángulo[n]);
    END
    write(0,0,192,0,"Press ESC to finish ...");
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
{-}

This program will print on screen a list of the sins, randomly chosen
between -1000 and 1000 and use the function {atan()} to calculate the
atan of them (between -45 and 45 degrees).

{/}See: {#1035,Expression} - See: {#1044,Use of the angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.248,atan2()}

{atan2(}<x>{,} <y>{)}

{Return:}

The atan of {<y>}/{<x>}.

{Description:}

Calculates the atan of the tan obtained of the division of the
two values, given as parameter ({<y>}/{<x>}), the angle correspondent
to a tan  (opposite operation to the tan, which can be obtained with the function
 {#244,tan()}) is obtained.

The angles are manipulated always in thousandths of degree (see the
{#1044,use of angles in the language}), due to that, the atan is given back too
in thousandths as a value between{ -180000} and {180000} (from -180 to +180
degrees).

{/}

{Note 1:} Exists another function to calculate the atan called
simply {#248,atan()}, this function takes as only parameter the
own tan and gives back it's atan between -90000 and 90000 (from -90
to 90 degrees).

{/}

{Note 2:} Also can be found a version of {atan2()}, adapted to the
geometric concepts more simple; it is the function denominated
{#113,fget_angle()} which obtains directly the angle between two points.

{/}See: {#1035,Expression} - See: {#1044,Use of angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.249,draw()}

{draw(}<type>{,} <color>{,} <opacity>{,} <region>{,} <x0>{,} <y0>{,} <x1>{,} <y1>{,}{)}

{Return:}

The {identifier of the graphic primitive} painted.

{Description:}

Is a generic function able to represent some graphic primitives
on screen (as lines, boxes and circles). The following parameters
must be indicated:

{<type>} - Type of primitive, inside of the following:

  {1} - Straight line.ú
  {2} - Rectangle.ú
  {3} - Filled rectangle.ú
  {4} - Ellipse.ú
  {5} - Filled ellipse.ú

{<color>} - Color of the ink to the primitive (from {0} to {255}, as a color
of the palette).

{<opacity>} - Level of opacity of the primitive, from {0} to {15} (to allow
transparence effects).

{<region>} - Number of region (window inside of the screen) in which can be
painted the primitive; normally this value will be {0} to print the 
primitive in any position of the screen. To define
a region the function {#106,define_region()} must be used.

{<x0>}, {<y0>} - Initial point of the straight line, or the upper left corner
of the box which contains the rectangle or ellipse.

{<x1>}, {<y1>} - Final point of the straight line, or the lower right corner
of the box which contains the rectangle or ellipse.

{/}

When a primitive is painted with {draw()} this will remain fixed
on screen until it is moved with {#251,move_draw()}, or eliminated with
{#250,delete_draw()}.

The {identifier of the primitive} given back by the function {draw()} will be 
necessary to move or delete the primitive.

The representation system of these graphic primitives is quite similar
to the system of texts; are painted with {#171,write()} and will remain fixed
until they are moved with {#141,move_text()} or eliminated with {#107,delete_text()}.

{/}

{Note:} The priority of impression of the graphic primitives can be controlled 
with the predefinied global variable {#1418,draw_z}.

{/}

{#9999,Example program:}
PROGRAM example_draw;

GLOBAL
    contador;
    tipo;
    color;
    opacidad;
    x0,y0;
    x1,y1;

BEGIN
    write(0,0,0,0,"Press ESC to finish ...");
    REPEAT
        FROM contador=1 TO 10;
            tipo=rand(1,5);
            color=rand(0,255);
            opacidad=rand(0,15);
            x0=rand(0,319);
            y0=rand(0,199);
            x1=rand(0,319);
            y1=rand(0,199);

            // Paints a graphic primitive

            draw(tipo,color,opacidad,0,x0,y0,x1,y1);

        END
        FRAME;
        delete_draw(all_drawing);
    UNTIL (key(_esc));
END
{-}

This example program represents on screen  10 graphic primitives
which characteristics are selected randomly with the function
{#149,rand()}, and after giving an image with {#1029,FRAME}, it deletes them with
the function {#250,delete_draw()}.

The process is repeated until the ESC key is detected.

{/}

{Note:} On the screen at the same time can be represented a maximum of {256} graphical primitives.

{/}See: {#251,move_draw()} - {#250,delete_draw()} - {#1418,draw_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.250,delete_draw()}

{delete_draw(}<identifier of the graphic primitive>{)}

{Description:}

Deletes a graphic primitive which has been painted with the function {#249,draw()},
and for that is required as parameter  {<identifier of the primitive>},
which is the numeric code which was given back when was painted.

If is specified as parameter {all_drawing} will delete every
graphic primitive represented on screen, the {identifier} will be 
necessary only in the case of want to eliminate a concrete primitive.

{#9999,Example program:}
PROGRAM example_delete_draw;

PRIVATE
    id_draw;
    tipo;
    color;
    opacidad;
    x0,y0;
    x1,y1;

BEGIN
    write(0, 160, 8, 1, "[ENTER] To show a primitive / [SPACE] to delete it");
    draw(2,127,15,0,0,0,319,199);
    LOOP
        tipo=rand(1,5);
        color=rand(0,255);
        opacidad=rand(0,15);
        x0=rand(0,319);
        y0=rand(0,199);
        x1=rand(0,319);
        y1=rand(0,199);

        id_draw=draw(tipo,color,opacidad,0,x0,y0,x1,y1);

        WHILE (NOT key(_space))
            FRAME;
        END

        delete_draw(id_draw); // We delete the text

        WHILE (NOT key(_enter))
            FRAME;
        END
    END
END
{-}

In the previous example, a primitive is printed on screen, then is expected
for the {space bar} to be pressed, moment in which the primitive
deleted and the {ENTER} key is expected to repeat the loop.

Can be seen as only the second primitive, which identifier
has been saved in the variable {id_draw} (the first is the rectangle which
has the same size as the screen and is painted with the first call to {#249,draw()} of
the program).

To delete every primitive the function should be called as {delete_draw(all_drawing);}, 
what could eliminate also the rectangle.

{/}

{Note:} With the function {#251,move_draw()} can be modified the
characteristics of a graphic primitive presented on screen (position,
color, opacity and size).

{/}See: {#249,draw()} - {#251,move_draw()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.251,move_draw()}

{move_draw(}<identifier of the primitive>{,} <color>{,} <opacity>{,} <x0>{,} <y0>{,} <x1>{,} <y1>{)}

{Description:}

Modifies a graphic primitive which has been painted with the function {#249,draw()},
to do this, the following parameters are required:

{<identifier of the primitive>} - Is the numeric code which was given back by the
function {#249,draw()} when the primitive was painted and which now is wanted to
be modified.

{<color>} - Color of ink for the primitive (from {0} to {255}, as a color
of the palette).

{<opacity>} - Level of opacity of the primitive, from {0} to {15} (to allow
transparence effects).

{<x0>}, {<y0>} - Initial point of the straight line, or the upper left corner
of the box which contains the rectangle or ellipse.

{<x1>}, {<y1>} - Final point of the straight line, or the lower right corner
of the box which contains the rectangle or ellipse and the coordinates
({x}, {y}) of screen where must be moved.

{/}

{#9999,Example program:}
PROGRAM example_move_draw;

PRIVATE
    id_draw;
    color;
    opacidad;

BEGIN
    write(0, 0, 0, 0, "Move the mouse ...");
    id_draw=draw(4, 127, 15, 0, 0, 0, 32, 32);
    LOOP
        color=rand(0,255);
        opacidad=rand(0,15);

        // The graphic primitive is moved to the mouse coordinates

        move_draw(id_draw, color, opacidad, mouse.x-16, mouse.y-16, mouse.x+16, mouse.y+16);

        FRAME;
    END
END
{-}

In the example is painted, with the function {#249,draw()}, a circular graphic 
primitive, and is saved its {identifier of graphic primitive} in the global 
variable {id_draw}.

Then is when, inside of a loop, will be used the function {move_draw()}
to place the circle in the mouse coordinates, and asign to it a color 
and opacity chosen randomly in each image.

{/}

{Note:} To eliminate (delete) a graphic primitive the function
{#250,delete_draw()} is used, and with the predefinied global variable {#1418,draw_z} can
be handled the priority of impression of them.

{/}See: {#249,draw()} - {#250,delete_draw()} - {#1418,draw_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.253,write_in_map()}

{write_in_map(}<font>{,} <text>{,} <code of centre>{)}

{Return:}

The created {code of the graphic} containing the text.

{Description:}

Creates a new map in memory (without load it on disk, the same as the
function {#188,new_map()}) and writes in the same a text which characteristics
are described with the following parameters:

{<font>} - The {code of the font} or {type of letter} which is going to be used.
Here must be placed a  0 when is wanted to use the system font
(font of white color, small, of 6 per 8 points), or the {code of font} given back
by the function {#131,load_fnt()} when a new font is loaded in the program.

{<text>} - In second place will be specified the text to be written as a
literal, a text between quotation marks (see the {#1047,delimitation symbols of literals}).

{<code of centre>} - Is a code which determines the position of the text
in which will be placed the {center} or {#1136,checkpoint} of the created map. It's
possible values are:

  {0}-Up left 		{1}-Up 		{2}-Up rightú
  {3}-Left       	{4}-Center 	{5}-Rightú
  {6}-Down left  	{7}-Down  	{8}-Down rightú

The text always will be fitted in a new map of the same dimensions, but
this {#1136,checkpoint} will specify which point of the map will centered in
the coordinates in which then, will be placed the same.

{/}

This function works practically as {#174,load_map()}, but it doesn't
read an archive on the disk with the graphic but it is created as a graphic
which contains a written message as a determined font of letters.

As value of return is given back the {code of the graphic}, which is a numeric
value which must be specified to use the graphic in the variable
{#1126,graph} or, in general, in every function which requires a {code
of graphic} between it's parameters.

When is wanted inside of a function the {code of file} which belongs
the graphic, must be indicated the code {0} (which is the code
of the first {file FPG} which is loaded in the program).

{/}

{#9999,Example program:}
PROGRAM example_write_in_map;

GLOBAL
    mi_fuente;

BEGIN
    mi_fuente=load_fnt("help\help.fnt");

    // A new map is created with the text "MOUSE"
    // with the checkpoint in the center, and is
    // asigned as graphic of the mouse cursor.

    mouse.graph = write_in_map(mi_fuente,"MOUSE",4);

    REPEAT
        FRAME;
    UNTIL (key(_esc));
    unload_map(mouse.graph);
END
{-}

In the example is loaded a font of letters with the function {#131,load_fnt()},
and then is created a map with the function {write_in_map()} saving the
{code of the graphic} which returns in the variable {#1100,mouse.graph}, so
it will appear as mouse cursor.

The new map is created with the message {"MOUSE"} written with the font {help.fnt},
and it's main {#1136,checkpoint} is placed in the center (with the code {4}).

Pressing the {ESC} key will be out of the visualization loop and the program will
delete the graphic with the function {#176,unload_map()} (exactly the same
as if it were loaded of an archive of disk).

But, {it is not necessary to delete the graphic from memory} before finishing
the program, because the system will do it automatically.

{/}

The main advantage which gives the function {write_in_map()} is to be able
of work with the texts as if they were graphics, so they can be rotated,
scalated, printed with transparences, etc.

{Note:} To {write_in_map()} can show a numeric value must be used the function 
{#255,itoa()}, which allows to convert a numeric value into a string of text.

{/}See: {#171,write()} - {#176,unload_map/pcx()} - {#1126,graph} - {#255,itoa()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.254,calculate()}

{calculate(}<text with an numeric expression>{)}

{Return:}

The result of the numeric expression.

{Description:}

Allows to convert a literal (or text between quotation marks), which contains a
number or numeric expression, in a constant value which can be asigned to any
data.

Allows to convert a text into a number; for example, the
statement {x=calculate("234");} will asign the value {234} to the variable
{x} (exactly the same with the statement {x=234;}). The function {#255,itoa()}
allows the opposite operation, to convert a number into a text.

But, besides, the function {calculate()} can evaluate an expression, contained
in the text with some operators, that can be the following (all the synonimous
accepted by each operator are indicated):

{ + -}      Addition and substraction.ú
{ * /}      Multiplication and division.ú
{ % MOD}    Module, or rest of an entire division.ú
{ < <<}     Binary rotation to the left.ú
{ > >>}     Rotation to the right.ú
{ ^ ^^ XOR} OR binary exclusive.ú
{ | || OR}  OR binary.ú
{ & && AND} AND binary.ú
{ ! NOT}    Binary negation.ú
{ SQRT}     Square root.ú

Also can be used the parenthesis {( )} to indicate priorities
inside of the calculation of the expresion. For example, {calculate(}"(2+3)*4"{)}
would give back {20} as result.

{/}

{Note:} The operativity of this function is very similar to the window
of the {#1301,calculator} ({System\Calculator}) of the windows environment.

{/}

{#9999,Example program:}
PROGRAM example_calculate;

GLOBAL
    STRING cálculo;
    resultado;

BEGIN
    write(0,0,0,0,"Introduce an expression:");
    write(0,0,10,0,cálculo);
    write(0,0,30,0,"Result:");
    write_int(0,0,40,0,OFFSET resultado);
    LOOP
        SWITCH(ascii)
            CASE 8:
                cálculo--;
            END
            CASE 27:
                cálculo="";
            END
            CASE 0..31:
            END
            DEFAULT:
                cálculo+=ascii;
            END
        END

        resultado = calculate(cálculo); // Evaluates the calculation

        IF (timer MOD 100>50)
            cálculo+="_";
        ELSE
            cálculo+=" ";
        END
        FRAME;
        cálculo--;
    END
END
{-}

This example program allows to introduce an expression in a string of text
(See {#1406,STRING}) and then evaluates it with the function
{calculate()} to show the result of the same.

{/}

{Note:} if an error is produced in the evaluation of the expression (for example,
that exists any parenthesis without being closed), the function will give back {0} as
result.

{/}See: {#255,itoa()} - {#171,write()} - {#1406,STRING}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.255,itoa()}

{itoa(}<expression>{)}

{Return:}

A string of text containing the resut.

{Description:}

This function is used to convert a numeric value or {<expression>} into
a string of text, that allows to convert a number into text.
The string will have as many types as digits has the result.

The function {#254,calculate()} allows the oppossite operation;
to convert a literal or string of text into a numeric value.

{#9999,Example program:}
PROGRAM example_itoa;

GLOBAL
    STRING message;

BEGIN
    load_fpg("help\help.fpg");
    mouse.graph=200;
    write(0,0,0,0,message);
    REPEAT

        // It makes a message with text and numbers using itoa()

        message = "Cursor of the mouse in (" + itoa(mouse.x) +
                  "," + itoa(mouse.y) + ").";

        FRAME;
    UNTIL (key(_esc));
END
{-}

This example program makes in a string of text called {message}
(see {#1406,STRING}) letters and numeric values (the coordinates
of the mouse, see {#1100,mouse}), and it is represented on screen
with the function {#171,write()}.

The program loads the archive {help.fpg} with {#132,load_fpg()} and asign
the graphic {200} as cursor of the mouse. The program will continue until
the {ESC} key is pressed.

{/}

{Note:} The name of the function {itoa()}, that comes from the C language, comes
from the expression "integer to ascii". And the function that makes the oppossite
operation, "ascii to integer" is {#254,calculate()}.

{/}See: {#254,Calculate()} - {#1035,Arithmetic expressions} - {#171,Write()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.256,change_channel()}

{change_channel(}<channel>{,} <volume>{,} <balance>{)}

{Description:}

Is a complementary function to {#102,change_sound()}, which modifies
the properties of one of the sound channels which reproduce the
digital effects (See {#159,sound()}) or music modules (See {#216,song()}).

The number of the {<channel>} which is wanted to be adjusted must be indicated, (normally
the number of channel given back by the function {#159,sound()}), and the two following
values:

{<volume>} - Is given as volume of the channel, between {0} and {512},
independent of the volume of the sound and the general volume.

When the volumes of the different channels are too loud an effect of distortion
will be produced, so it is recommended to  modify the volume of the sound effects
through the function {#102,change_sound()} which, besides, allows to adjust the
frequency of the same.

{<balance>} - Is the "panning" or difference of volume between the left speaker
and the right one, must be a value between {0} and {255}.

{/}

{Note:} The general levels of volume can be adjusted with the
global structure {#1104,setup} (digital sound, cd-audio and general volume).

{/}

{#9999,Example program:}
PROGRAM example_change_channel;

PRIVATE
    balance=128;     // Valor medio (0..256)

    id_sonido;
    canal;

BEGIN
    load_fpg("help\help.fpg");
    put_screen(0, 1);

    id_sonido = load_pcm("help\help.pcm", 1);
    canal = sound(id_sonido, 256, 256);

    write(0, 160, 0, 1, "Press right or left to change the balance.");
    write_int(0, 160, 10, 1, offset balance);
    LOOP

        // Changes the balance of the channel

        change_channel(canal, 50, balance);

        IF (key(_right) AND balance<255) balance++; END
        IF (key(_left) AND balance>0) balance--; END
        FRAME;
    END

END
{-}

In the example is loaded and played a sound (contained in the archive
{help.pcm}). Inside of the program's main loop can be changed the channel
balance through which is being played the sound with the function
{change_channel()}, using the cursor keys.

{/}

{Note:} See also the global predefined board in the predefined global board 
{#1416,channel}, that indicates which of the sound channels are being used.

{/}See: {#102,change_sound()} - {#159,sound()} - {#216,song()} {#1104,STRUCT setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.257,malloc()}

{malloc(}<length>{)}

{Return:}

The {OFFSET} of the memory block asked, or {0} if the memory available is not
enough.

{Description:}

This function asigns dynamic memory, a new block of free memory if the computer is
asked for the program.

Is required as parameter the {<length>} of the memory block which is wanted to be
ocuppied. This length is specified as a number of simple data, filling up
each one of them 4 bytes; for example, if is asked a block of length {100} 
400 bytes of memory will be saved.

Inside of a program can be asked a max number of {256 blocks},
independently of its size, the function {#258,free()} allows to liberate
these memory blocks.

{/}

Normally the {OFFSET} (memory address) returned by the function
{malloc()} is asigned to a data of type cursor (See {#1405,POINTER}).

{/}

{#9999,Example program:}
PROGRAM example_malloc;

GLOBAL
    POINTER mitabla[1000];  // Cursor of a board of 1000 data

BEGIN

    mitabla = malloc(1000); // Asks 1000 positions of memory

    FOR (contador=0;contador<1000;contador++) // Accesses to the data
        mitabla[contador]=-1;
    END

    free(mitabla);          // Liberates the memory ocupped by the board
END
{-}

This small example shows how can be defined a cursor to the board
(with the cursor is not saved space to the data of the board), and to
ask for memory to this with the function {malloc()}.

Once the memory is asked to the board of data, the program accesses to them
(they are initiated to -1, as an example), and liberates the memory.

The memory blocks which are not liberated  with the function {#258,free()}, will be
liberated automatically by the system when the program has finished.

{/}

{Note:} the quantity of available memory to the data of the program processes
(local and privated data) it can be controlled with the options of compilation
(See {#1400,Compiler_options}).

{/}See: {#258,free()} - {#1405,POINTER}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.258,free()}

{free(}<OFFSET of the memory block>{)}

{Description:}

Liberates a block of dynamic memory which has been reserved previously with the
the function {#257,malloc()}

Is required as parameter the {OFFSET} or memory address in which starts the block
which is the value obtained when it is reserved.

The memory blocks not liberated with the function {free()}, will be liberated
automatically by the system when the program ends.

{#9999,Example program:}
PROGRAM example_free;

GLOBAL
    POINTER mitabla[1000];  // Cursor of a board of 1000 data

BEGIN

    mitabla = malloc(1000); // Asks for 1000 positions of memory

    FOR (contador=0;contador<1000;contador++) // Accesses to the data
        mitabla[contador]=-1;
    END

    free(mitabla);          // Liberates the memory filled up by the board
END
{-}

This small example shows how can be defined a cursor to a board 
(with the cursor, the space to the data of the board is not reserved), and to
ask for memory to this with the function {#257,malloc()}.

Once asked for the memory to the board of data the program accesses to them
(they are started to -1, as an example), and the memory is liberated.

{/}See: {#248,free()} - {#1405,POINTER}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.259,encode()}

{encode(}<OFFSET of the data>{,} <length>{,} <clue>{)}

{Description:}

Encript or unencripts a block of data in memory with a determinied clue.
The necessary parameters are the following:

{<OFFSET of the data>} - Memory address in which starts the block which must
be compressed, to obtain this address the operator {#1085,OFFSET} must be used.

{<length>} - Length of the data to be compressed, the number of
positions of memory, filled up for the same, the length of any
data can be obtained with {#1094,SIZEOF()}.

{<clue>} - A literal (text between quotation marks) with the clue of encriptation
or unencriptation of the data.

The algorithm is reversible so, to unencript the data, simply you must to encript
them with the same clue.

The algorithm of encriptation is very complex, so, any encripted data with a clue
just can be recovered applying to it the same clue again.

{#9999,Example program:}
PROGRAM example_encode;

CONST
    clave="miclave";

GLOBAL
    tabla_original[14]  =0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;
    tabla_encriptada[14]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;
    contador;

BEGIN
    write(0,0,  0,0,"Original values");
    write(0,160,0,0,"Encripted values");
    write(0,0,190,0,"[SPACE] to encript/unencript the values");

    // Encriptates the values of the second board

    encode(OFFSET tabla_encriptada,sizeof(tabla_encriptada),clave);

    FOR (contador=0;contador<15;contador++)
        write_int(0,0,  20+contador*8,0,OFFSET tabla_original[contador]);
        write_int(0,160,20+contador*8,0,OFFSET tabla_encriptada[contador]);
    END

    LOOP
        IF (scan_code==_space)

            // Encripts and unencripts of values of the second board

            encode(OFFSET tabla_encriptada,sizeof(tabla_encriptada),clave);

        END
        FRAME;
    END
END
{-}

This program has defined two boards of global data both with the same
values and allows, pressing the {space bar}, to encript and
unencript one of the two boards (the denominated {tabla_encriptada[]}).

It can be seen how, when the data are encripted a second time they are recovered
in its original state. If a different clue is used, the result will be 
completely different.

{/}

{Note:} There are other two functions which allow to encript and 
unencript any kind of archive, in this case must be used a function to
each operation: {#260,encode_file()} to encript and {#261,decode_file()}
to unencript.

{/}See: {#260,encode_file()} - {#261,decode_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.260,encode_file()}

{encode_file(}<name of archive>{,} <clue>{)}

{Description:}

Encripts one or some archives of the disk with a determined clue.
The necessary parameters are the following:

{<name of the archive>} - Description of an archive which must be encripted,
a literal (text between quotation marks) with the name of the same. Can be used
the joker characters "?" and "*" to specify some archives (for example,
"*.BAK" to encript every archive with extension BAK).

{<clue>} - Other literal with the clue of encriptation of the archive or archives.

The algorithm of encriptation is quite complex, so any encripted archive
with a clue just can be recovered applying to it the same clue with the 
function {#261,decode_file()}. If this operation is not made,
the resulted archive will be completely useless, being impossible to recover
the data contained in it.

Cannot be encripted per second time the archives which are already encripted.

{#9999,Example program:}
PROGRAM example_encode_file;

CONST
    clave="miclave";

GLOBAL
    mitabla[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;

BEGIN
    save("help\help.enc",OFFSET mitabla,sizeof(mitabla));

    encode_file("help\help.enc",clave); // Encripts the archive
END
{-}

This small program uses the function {#155,save()} to create an archive
called {help.enc} with the data contained in {mytable}, and then the program
encripts it with the function {encode_file()}.

You can see how the contain of the created archive (inside of the directory
{help\}) doesn't save any relation with the original data (without depending
of which is the encriptation clue).

{/}

There is another function denominated {#259,encode()} which allows to encript
and unencript data in memory, in this case the operation is reversible, so
the same function is used to both operations.

{/}

{Note:} the functions {#262,compress_file()} and {#263,uncompress_file()}
allow to compress and uncompress archives of the disk. The encripted archives
{cannot be compressed} with the functions (due to that it's contain is completely
random).

{/}See: {#259,encode()} - {#261,decode_file()} - {#262,compress_file()} - {#263,uncompress_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.261,decode_file()}

{decode_file(}<name of the archive>{,} <clue>{)}

{Description:}

Unencripts one or some archives of the disk, with the same clue which the one
with they were encripted with the function {#260,encode_file()}. The necessary 
parameters are the following:

{<name of archive>} - Description of the archive which must be unencripted,
a literal (text between quotation marks) with the name of the same. Can be used
the joker characters "?" and "*" to specify some archives (for example,
"*.BAK" to unencript every archive with extension BAK).

{<clue>} - Other literal with the clue of unencriptation of the archive or archives.
This clue must be {exact} to the clue with the archive were encripted originally, 
if {they are unencripted with a different clue, the archives will remain useless}.

The archives unencripted cannot be unencripted.

{#9999,Example program:}
PROGRAM example_decode_file;

CONST
    clave="miclave";

GLOBAL
    mitabla[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;

BEGIN
    save("help\help.enc",OFFSET mitabla,sizeof(mitabla));
    encode_file("help\help.enc",clave);
    // ...

    decode_file("help\help.enc",clave); // unencripts the archive

END
{-}

This small program uses the function {#155,save()} to create an archive
called {help.enc} with the data contained in {mytable}, and is encripted with
the function {encode_file()}.

Before the program finishes the contain of the archive is recovered again when
is unencripted with the function {decode_file()}. The archive will remain finally
with the data contained in {mitabla}, in its original form.

{/}

Exists other function denominated {#259,encode()} which allows to encript and
unencript data in memory, in this case, the operation is reversible, so
the same function is used for both operations.

{/}

{Note:} the functions {#262,compress_file()} and {#263,uncompress_file()}
allow to compress and uncompress archives of the disk. The archives encripted
{cannot be compressed} with the functions (due to it's content is completely 
random).

{/}See: {#260,encode_file()} - {#259,encode()} - {#262,compress_file()} - {#263,uncompress_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.262,compress_file()}

{compress_file(}<name of archive>{)}

{Description:}

Compresses one or some archives of the disk, the only parameter is required
the {<name of archive>} which must be compressed, as a literal (text between
quotation marks). Can be used the joker characters "?" y "*" to specify some
archives (for example, "*.BAK" to compress every archive with
extension BAK).

To uncompress these archives must be used the function {#263,uncompress_file()}.
The format of archive encripted is an own format of DIV Games Studio,
so can't be uncompressed with any external utility.

The archive will be saved compressed with the same name and extension of the
original. Can't be compressed on a second time the archives already compressed.


{#9999,Example program:}
PROGRAM example_compress_file;

GLOBAL
    contador;
    mitabla[999];

BEGIN
    FOR (contador=0;contador<1000;contador++)
        mitabla[contador]=contador;
    END

    save("help\help.cmp",OFFSET mitabla,sizeof(mitabla));

    compress_file("help\help.cmp"); // Compress the archive.
END
{-}

This small program uses the function {#155,save()} to create an archive
called {help.cmp} with the data contained in {mitabla}, being these a group of
consecutive numbers from 0 to 1000.

Once created the archive, is compressed with the function {compress_file()}.

In this case, the original size of the archive is 4000 bytes (1000 data),
and the size of the archive compressed is 1441 bytes (a 36% of the original
size).

{/}

{Note:} the functions {#260,encode_file()} and {#261,decode_file()}
allow to encript and unencript archives of the disk.

The archives encripted with these functions {can't be compressed}
due to it's content is completely random. But, {the archives
compressed can be encripted}.

{/}See: {#263,uncompress_file()} - {#260,encode_file()} - {#261,decode_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.263,uncompress_file()}

{uncompress_file(}<nombre de archivo>{)}

{Description:}

Uncompresses one or some archives of the disk, previously compressed
with the function {#262,compress_file()}, the only parameter required is
the {<name of archive>} which must be uncompressed, as a literal
(text between quotation marks). Can be used the joker character "?" y "*"
to specify some archives (for example, "*.BAK" to uncompress every
archive with extension BAK).

The format of the archive encripted is an own format of DIV Games Studio,
so it can't be uncompressed with any external utility.

The archive will be uncompressed with the same name and extension of the 
compressed one. Can't be uncompressed archives not compressed
with the function {#262,compress_file()} of the language.

{#9999,Example program:}
PROGRAM example_uncompress_file;

GLOBAL
    contador;
    mitabla[999];

BEGIN
    FOR (contador=0;contador<1000;contador++)
        mitabla[contador]=contador;
    END

    save("help\help.cmp",OFFSET mitabla,sizeof(mitabla));

    compress_file("help\help.cmp"); // Compress an archive

    // ...

    uncompress_file("help\help.cmp"); // Uncompress the archive

    load("help\help.cmp",OFFSET mitabla);
END
{-}

This small example used in the function {#155,save()} to create an archive
called {help.cmp} with the data contained in {mitabla}, being these a group
of consecutive numbers from 0 to 1000, then the archive is compressed
with the function {#262,compress_file()}.

Once created the archive compressed in disk, it is uncompressed with the function
{uncompress_file()} and is loaded again over the original board with the
function {#130,load()}.

{/}

{Note:} the functions {#260,encode_file()} and {#261,decode_file()}
allow to encript and unencript archives of the disk.

The encripted archives, generated with these functions {cannot be compressed}
due to it's content is completely random. But, {the compressed archives
can be encripted}.

{/}See: {#262,compress_file()} - {#260,encode_file()} - {#261,decode_file()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.264,find_color()}

{find_color(}<red>{,} <green>{,} <blue>{)}

{Returns:}

The {color number} in the palette.

{Description:}

Finds the color of the current palette nearest to the indicated color.

Three components which make the desired color must be localized inside of the
palette, as {<red>} (red), {<green>} (green) and {<blue>} (blue), all of them
as values between 0 and 63.

As return value will be given the {number of color} of the palette which is
the nearest of the indicated components.

For example, if the program calls a function like {find_color(63,63,0)}, it will
give back the color number of the palette which is the nearest or looks like {yellow}.

{/}

{Note:} the function {find_color()} {doesn't modify the current palette}, just
search for determined colors inside of the same, to modify a color of the
palette the function {#179,set_color()} must be used.

{#9999,Example program:}
PROGRAM example_find_color;

GLOBAL;
    azul;
    verde;
    amarillo;
    rojo;

BEGIN

    azul=find_color(0,0,63);      // Search for the color blue
    verde=find_color(0,63,0);     // Search for the color green
    amarillo=find_color(63,63,0); // Search for the color yellow
    rojo=find_color(63,0,0);      // Search for the color red

    draw(2,azul,15,0,0,0,79,79);
    draw(2,verde,15,0,80,0,159,79);
    draw(2,amarillo,15,0,160,0,239,79);
    draw(2,rojo,15,0,240,0,319,79);

    LOOP
        FRAME;
    END
END
{-}

This example uses the function {find_color()} to localize the colors
{blue}, {green}, {yellow} and {red} inside of the palette, and then
with the function {#249,draw()}, shows four squares of these colors.

The advantage of use this system is that doesn't matter that the program changes
of palette, because always can be found the colors inside of the same.

{/}

To modify all the palette, must be loaded the same with an archive of the disk
with the function {#133,load_pal()}.

To realize other palette effects, the function {#154,roll_palette()} can be used,
which allows to realize cycles of color, or the function {#110,fade()} which allows
to realize multiple fades and saturations of color at different speeds.

{/}See: {#179,set_color()} - {#154,roll_palette()} - {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.265,load_screen()}

{load_screen(}<name of the archive>{)}

{Description:}

Loads the image of background from the screens of an archive {MAP} or {PCX}.

If the graphic is of a size (in points) different to the one of the screen
simply will be printed centered in the same.

To delete the background the function {#103,clear_screen()} must be used.

{/}

It is a function that resumes three actions in one:

{1 -} To load an archive which contains a map with the background image (with the
function {#174,load_map()} or {#174,load_pcx()}).

{2 -} To establish the image as background (with {#148,put_screen()}).

{3 -} To delete the archive with the image from memory (with {#176,unload_map()} or
{#176,unload_pcx()})

{/}

{#9999,Example program:}
PROGRAM example_load_screen;
BEGIN
    load_screen("help\help.map");
    LOOP
        FRAME;
    END
END
{-}

In the example the background image contained in the archive {help.map}
is loaded with the function {load_screen()}.

{/}

{Note:} If is wanted to print a graphic in a concrete part of the screen
or a graphic {not centred}, it can be used to that the function
{#146,put()}. The function {#173,xput()} allows, besides, to print graphics
rotated, escalated, mirrored and/or transparented in any region of the
screen.

{/}See: {#174,load_map/pcx()} - {#148,put_screen()} - {#176,unload_map/pcx()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.266,force_pal()}

{force_pal(}<name of archive>{)}

{Description:}

Loads a palette of color of the disk (of an archive PAL, FPG, MAP, PCX or FNT) and
{it is established as obligatory palette} to all the graphics and fonts which are
loaded after.

The functioning is very similar to {#133,load_pal()} (which simply loads and
activates a palette) but, once loaded the palette with {force_pal()},
{every map, file and font} loaded {will adapt automatically to the current palette}.

The {graphics already loaded} before being called {force_pal()} {won't
be adapted}, due to this, if is wanted that all the graphics can be seen with
a unique palette, this function must be called at the beginning of the program.

Is {important} to say that the maps, files y fonts just will adapt in the
computer memory, the original archives remain unaltered, each one with
its palette.

{/}

{Note:} To stop the adapting of the loaded graphics to the palette, the function 
{force_pal(0)} must be called (indicating a {0} as parameter, instead of a 
name of archive.

{/}

{#9999,Example program:}
PROGRAM example_force_pal;
BEGIN

    force_pal("help\help.pal");

    // Now can be loaded all the files, maps and fonts
    // which are wanted, without depending of the palette, all will be adapted
    // automatically to the current palette.

    // ...

END
{-}

This small example shows how can be forced all the graphics to just one 
palette inside of a programm calling to {force_pal()} at the beginning of
the same.

{/}

A palette can't be deleted from the computer memory, because this doesn't
fill up space in the memory.

{/}See: {#133,load_pal()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Informacion extendida sobre los mensajes de error del compilador
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.500,Not enough memory}

There is not {enough memory} to compile the program.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.501,The ltobj.def was not found}

The archive <LTLEX.DEF> was not found in the DIV directory; this
archive is essential to the program's compilation.

Recover the original archive if you have a copy, or in the opposite case,
you must install the application again.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.502,Wrong ltlex.def archive}

The changes done in the archive <LTLEX.DEF> {are not valid}; recover the
original archive if you have a copy, or in the opposite case, you must
install the application again.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.503,Wrong ltlex.def archive}

{Too many symbols} have been defined in the archive <LTLEX.DEF>; recover the
original archive if you have a copy, or in the opposite case, you must
install the application again.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.504,Wrong ltlex.def archive}

An {invalid symbol} has been defined in the archive <LTLEX.DEF>; recover the
original archive if you have a copy, or in the opposite case, you must
install the application again.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.506,ltobj.def was not found}

The archive <LTOBJ.DEF> was not found in the DIV directory; this archive is
essential for the program's compilation.

Recover the original archive if you have a copy, or in the opposite case, 
you must install the application again.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.507,Wrong ltobj.def archive}

Changes done to the archive <LTOBJ.DEF> {are not valid}; recover the
original archive if you have a copy, or in the opposite case, you must
install the application again.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.510,Character not recognized}

A character was found in the program which is no part of any symbol of the
language and, besides, {is not valid} to construct a new name.

If it is a {#1002,commentary} you must indicate it with a symbol
// at the beginning of the commentaries of a line, or the symbols /* y */ to
indicate the beginning and ending, respectively, of the commentaries that fill 
up to one line.

If is wanted to construct a {#1001,name} you must change the character
for another one inside of the allowed in the language.

{/}See: {#1000,Sintaxis} - {#1002,Commentaries}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.511,Literal without being closed}

The literals are the {texts between quotation marks}. In the indicated position
of the program stars a literal and it is not closed.

All the literals must be closed in the same line in which were started, so
it can't be defined literals of more than one line.

The literals can begin and finish with the character [{#1047,'}] or with the
character [{#1047,"}] (but they must begin and finish with the same one). If 
is not wanted to include the character [{#1047,"}] in a literal, it can be
done in two ways; if is wanted to define a literal with the text: a"B"c

 - Duplicate the character: "a""B""c"

 - Define it with the simple quotation mark: 'a"B"c'

The same happens with the character [{#1047,'}], which can be included inside of
a literal if it is duplicated, or if the literal is delimited with the 
character [{#1047,"}].

{/}See: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.512,Symbol not recognized}

In the indicated position of the program there is a symbol not belonged
to the language; check all the available symbols in the language to
construct correctly the expression.

Probably is a typographic error; check the sintaxis.

{/}See: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.520,Waiting [PROGRAM]}

All the programs must begin with the reserved word {PROGRAM} followed by
the name of the program; before this word just can appear
{#1002,commentaries} or the {#1400,compilation options}.

Check if the word has been written correctly, because there is no difference 
between capital letters and small letters, so are valid {PROGRAM}, 
{program}, {Program}, ...

{#9999,Example:}
// -------------------
// List of my game
// -------------------

PROGRAM my_game;
BEGIN
    LOOP
        FRAME;
    END
END
{-}

{/}See: {#1000,Sintaxis} - {#1002,Commentaries} - {#1003,Headline of program}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.521,Waiting the name of the program}

After the reserved word {PROGRAM} the name of the program is waited.

{#9999,Example:}
PROGRAM name_of_the_program;
BEGIN
    //...
END
{-}

The name of this program is {name_of_the_program}.

{/}See: {#1000,Sintaxis} - {#1001,Names} - {#1003,Headline of program}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.522,The name is not new}

As name of the structure has been used one that already was related with other
object previously defined. It can be a name of a constant, a variable, a board
a structure, a process or a program function.

It can be that the same name has been used inside of the program to identify
two different objects, or {a predefined name has been used to other use inside
of the language}.
In this case, the glossary can be accessed to see which is the object with that
name.

Anyway, {this name must be changed for a similar one}.

{#9999,Example:}
PROGRAM name_of_the_program;
GLOBAL
    position=0;
    STRUCT position[9] // Error: The name is not new.
        x, y;
    END
BEGIN
    //...
END
{-}

{/}See: {#1000,Sintaxis} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.523,Waiting [=]}

To define a board it's length is indicated between "[]"; in case of don't have
specified the number of elements of the board, the program waits for it to be 
initiated for the compiler to determine it's length.

A board without defined length has been found, so the compiler has been
waiting that, after closing the brackets ({#1079,[]}), the symbol has come
{#1073,=} indicating the initiation of the board.

Indicate the length of the board between "[]", or asign values to the 
different positions of the board.

When a board is not initiated, all of it's positions will be initiated
as zero.

{#9999,Example:}
PROGRAM name_of_the_program;
GLOBAL
    board1[3];
    board2[]=2, 4, 6, 8;
    board3[]; // Error: Waiting [=].
BEGIN
    //...
END
{-}

In the example has been defined two boards of four positions (0..3), board1
initiated as (0, 0, 0, 0) and board2 initiated as (2, 4, 6, 8).

{/}See: {#1000,Sintaxis} - {#1011,Declaration of board}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.525,Waiting [)]}

The compiler has been waiting that in the indicated position a parenthesis
were closed, previously opened with the symbol {#1053,)}.

This error usually happens due to one of these two reasons:

- In an expression has been opened some parenthesis and not everyone has been closed;
in this case, every parenthesis must be closed.

- Inside of an expression, between parenthesis, has been omited a operator, appearing
then, two consecutive operators, for example {(2*3 4)}, and, in this case, will be
necessary to indicate the operator.

{/}See: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.526,Waiting []]}

  The compiler has been waiting that in the indicated position to close a 
brackets, previously opened, with the symbol {#1079,]}.

This error happens usually, due to one of these two reasons:

- In a board or structure has been indicated the opening of a bracket ({[})
and after being indicated the length or index of itself it has not been closed;
in this case, you must add in the indicated position the symbol {]}.

- When the index of a board or structure is signed a operator has been omitted
appearing, then, two consecutive operators, for example {board[2*3 4]}, indicating
now, the missing operator.

{/}See: {#1000,Sintaxis}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.527,An operator was expected}

The indicated position in the program is inside of the matter of an expression
and in that point of the expression was expected an operator (a value over which
can be realized calculations) but, in it's place, has come a different element
over which can't be realized calculations.

There are some reasons that can make this error; the most usually are:

- a reserved word of the language has been used as if it were a variable,
for example {x=global*2;}. In this case, can be checked if it is a reserved
word accessing to the glossary.

- an operator has been omitted inside of an expression, for example {x=2+ /y;}.

- a bracket has been closed inside of a expression or parenthesis which have
not been previously opened, for example {x=);}.

Anyway, it must be checked the {#1000,sintaxis} of the indicated expression
to construct it in the correct way.

{/}See: {#1000,Sintaxis} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.528,Unknown name}

In the indicated position of the program a constant is used, a variable,
a board or an structure to access to it before being declared.

The compiler can't resolve the problem because it doesn't know which kind of 
object is.

Each constant must be defined at the beginning of the program, inside of
the section {#1004,CONST}.

The variables, boards and structures can be defined inside of the sections
{#1006,GLOBAL}, {#1007,LOCAL} or {#1008,PRIVATE} depending of it's range, but
always must be defined before to be used.

The more frequent cases in which this error appears are:

- A name has been introduced incorrectly, for example;

{#9999,Example:}
PROGRAM my_game;
CONST
    centro=160;
BEGIN
    x=centro; // Error: Unknown name.
    //...
END
{-}

- An object is used before and declared after, for example:

{#9999,Example:}
PROGRAM my_game;
CONST
    doble=simple*2; // Error: Unknown name
    simple=1;
BEGIN
    //...
END
{-}

  In this case the two last declarations should be interchanged.

- Initiating a board or structure, a comma has been placed after
the list of values.

{#9999,Exaple:}
PROGRAM my_game;
GLOBAL
    tabla[]=0, 1, 2, 3,
    a=0; // Error: Unknown name.
BEGIN
    //...
END
{-}

  In this case the compiler will warn of this error in the variable {a}, because
it thinks that it is the next value in the initiation list of the board and
it is an undefined name.

{/}See: {#1000,Sintaxis} - {#1004,Declaration of constants}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.529,Waiting [BEGIN]}

This error is produced when is realized a wrong declaration inside of the
sections {#1004,CONST}, {#1006,GLOBAL}, {#1007,LOCAL} or
{#1008,PRIVATE}.

After the first statement {#1003,PROGRAM name_of_program;} it is expected for appear
any of the sections previously named (always in the same order)
and finally the word {#1086,BEGIN}.

After the beginning of a process ({#1016,PROCESS} {name_of_process(}...{)}) or
function ({#1408,FUNCTION} {name_dof_function(}...{)})
which shows the section {#1008,PRIVATE} or the word {#1086,BEGIN}.

The error can be produced under the following circumstances:

- The name of any section has been writted incorrectly.

- Some sections has been placed in a wrong order:

{#9999,Example:}
PROGRAM my_game;
LOCAL
    a=0;
GLOBAL // Error: Waiting [BEGIN]
    b=0;
BEGIN
    //...
END
{-}

  Remember that the sections must be in the next order:

    {CONST}ú
    {#1006,GLOBAL}ú
    {#1007,LOCAL}ú
    {#1008,PRIVATE}ú

- Inside of any of the sections mentioned before you can see an
element that is not a valid declaration inside of this section.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    +variable=0; // Error: Waiting [BEGIN]
BEGIN
    //...
END
{-}

  In this example, when reaches the symbol {#1056,+} the compiler determines
that the section {#1006,GLOBAL} has finished and as the next element
is not the beginning of the sections {#1007,LOCAL} not
{#1008,PRIVATE}, wait until comes the reserved word {#1086,BEGIN}
giving the beginning of the code of the program.

- At the beginning of the program or when a process is defined the word
{BEGIN} has been omited.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    //...
END

PROCESS my_process()
    FRAME; // Error: Waiting [BEGIN]
END
{-}

{/}See: {#1000,Sintaxis} - {#1086,BEGIN}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.530,A constant expression was expected}

To start {#1004,constants}, variables, boards
and structures must be used numeric values or expresions
whose value can be determined when the program is compiled.

In the indicate position begins a expression whose value can't be resolved
in compilation time, probably because is using any global data, local or
private, or may be because any function is being called.

In the constant expressions can be used only:

    - {#1004,constants} defined before.ú
    - {Numeric values}.ú
    - {Operators} arithmetic or logical.ú
    - {Literals} (texts between quotation marks).ú
    - The function {#1094,sizeof()}.ú

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    my_variable=4;
    position=2*my_variable; // Error: A constant expression was expected
BEGIN
    //...
END
{-}

In this example can't be initiated {position}, because it is being used
for the local variable {x}.

{/}See: {#1000,Sintaxis} - {#1005,Definition of constants}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.531,The board was exceeded}

The constant expression that begins in the indicated position of the program
can't be calculated, because in it a board or a structure out of its rank of positions 
is acceded.

Check the rank of the board or structure in its definition.
Remember that a definited board, for example, like {tabla[10]}
has {11} positions (from board[0] to board[10]).

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    board[]=1, 3, 5;
    value=board[3]; // Error: The board has been exceeded.
BEGIN
    //...
END
{-}

In this example can't be initiated the variable {value} because
it is being used, for one nonexistant position of board.

{/}See: {#1000,Sintaxis} - {#1011,Declaration of board}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.532,It can't be calculated the offset}

In the indicated expression in the program, it is used the operator {#1085,offset}
(or the synonymous symbol {#1085,&}) to obtain the direction
(movement) of an object. This object hasn't got a direction, because it is not
a variable, a board or a structure,
for that, the compiler can't resolve the expression.

Probably you have pretended to obtain the address from a constant expression or from 
one that uses some operators.

Now it is going to be shown a program with some examples of a valid
use of the operator {#1085,offset}, and other wrong uses.

{#9999,Examplw:}
PROGRAM my_game;
CONST
    my_constant=0;
GLOBAL
    my_offset=0;
    my_variable=0;
    my_board[10];
    STRUCT my_estructure[10]
        variable;
    END
BEGIN
    // Valid examples
    my_offset=offset my_variable;
    my_offset=offset my_board;
    my_offset=offset my_board[my_variable];
    my_offset=offset my_estructure[0].variable;
    my_offset=offset id.x;

    // Wrong examples
    my_offset=offset (my_variable*2);
    my_offset=offset my_constant;
    my_offset=offset 0;
    write_int(0, 0, 0, 0, offset (my_variable+1));
END
{-}

There is no difference between the use of the reserved word {#1085,offset}
or the symbol {&}.

The {#1005,constants} like {my_constant} don't have a address because they
are simple synonymous of the numeric value that represent.

The statement {my_offset=offset (my_variable*2);} is wrong due to the
multiplication realized in first place and, once realized,
the value {my_variable*2} is converted into a numeric result that doesn't 
have any address allocated.

But, the expression {offset my_variable*2} is correct because, in this case, you have first
the address of {my_variable} and then, will be this address multiplied by {2}.

{/}See: {#1000,Sintaxis} - {#1085,Offset}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.533,Too many values for this board}

A board has been initiated with more values that can be contained.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    tabla1[3]=0, 1,2 , 3, 4; // Error: Too many values to the board.
BEGIN
    //...
END
{-}

To initiate a board it must be known that, as maximum, it can contain 
as many values as indicates the number that goes between "[]" plus 1.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    board1[3]=2, 4, 6, 8;
BEGIN
    //...
END
{-}

In this case the board {board1} can contain four values (board1[0]=2,
board1[1]=4, board1[2]=6 and board1[3]=8).

Other option is {not to indicate the size of the board}, in that way, the
compiler will know it from it's initiation.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    tabla1[]=2, 4, 6, 8;
BEGIN
    //...
END
{-}

In this case, if inside of the program is needed to make a reference to the length of the board,
it should be used the expression {sizeof(tabla1)} which, in this example, would be {4}.

{/}See: {#1000,Sintaxis} - {#1011,Declaration of board} - {#1094,sizeof()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.534,overflow in division}

In the indicated position of the program appears a {#1005,constant expression} which
wasn't resolved due to contain inside of itself operations, a division of zero.

When a number is divided by zero, it results infinite and as the language
of programation only can handle entire numbers, inside of the range
({#1177,min_int} ... {#1178,max_int}) it is not possible to save the result
of the operation in any variable or constant.

{#9999,Example:}
PROGRAM my_game;
conST
    infinito=1/0; // Error: overflow in division.
BEGIN
    //...
END
{-}

Probably is an unintentional error, for that the divisions by zero must
be eluded.

{/}See: {#1000,Sintaxis} - {#1019,Statement of asignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.535,Board of negative length}

To define a board indicating between "[]" it's length it must be used an entire 
positive number (0, 1, 2, 3, ...), thinking that every board starts in the 
position zero and finishes in the position indicated by the index.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    board1[9];
    board2[-9]; // Error: Board of negative length.
BEGIN
    //...
END
{-}

The compiler has detected a board defined with a negative length
as {board2}; in this example the board must be defined as
{board1} which, in this case, will be a board of 10 positions (from
board1[0] to board1[9]).

{/}See: {#1000,Sintaxis} - {#1011,Declaration of board}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.536,Waiting [(]}

The compiler waits that in the indicated position of the program for a 
parenthesis to be opened with the symbol {#1053,(}.

There are some cases in which the openning of a {#1053,parenthesis} is obligatory:

- {After a name of a process or a function} their parameters of call must be 
indicated always between parenthesis; also when the process or the function don't 
 have parameters, a parenthesis must be opened, closing it after.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    my_process();
    //...
END
PROCESS my_process()
BEGIN
  //...
END
{-}

- {In the statements of control that requires a condition} 
to control the flow of the progam, the condition must be 
written between parenthesis.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    IF (x<10)
        //...
    END

    WHILE (x<10)
        //...
    END

    REPEAT
        //...
    UNTIL (x<10)

    SWITCH (x)
        //...
    END

    FOR (x=0;x<10;x++)
        //...
    END
END
{-}

  In this example you can see how the different statements of control show
the condition between parenthesis. There are two exceptions:

  - The statement {#1021,SWITCH} doesn't requiere a condition but a simple expression;
anyway, is required between parenthesis.

  - The statement {#1025,FOR} has three parts inside of the parenthesis, separated by
points and comma, being these parts the following: initiation ({x=0}),
condition ({x<10}) and increment ({x++}).

- {After the operator {#1089,DUP}} (used to initiate boards and structures)
the opening of a parenthesis is obligatory.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    board1[]=10 dup (1, 2, 3);
BEGIN
    //...
END
{-}

  In this example, board1 would be a board of 30 positions (from board1[0]
to board1[29]) initiated in the following way: 1, 2, 3, 1, 2, 3, ...

{/}See: {#1000,Sintaxis} - {#1053,( )}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.538,It can't be duplicated 0 or less times}

The operator {#1089,DUP} used to initiate boards and structures 
allows to repeat (duplicate) a statement of values, a determined
number of times: from just one time (the operator has no utility) to 
an indetermined positive number of times.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    board1[]=10 dup (1, 2, 3);
    board2[]=-10 dup (1, 2, 3); // Error: It can't be duplicated 0 or less times.
BEGIN
    //...
END
{-}

In this example, board1 would be a board of 30 positions (from board1[0]
to board1[29]) initiated the following way: 1, 2, 3, 1, 2, 3, ...

Is possible, besides, to omit the operator {#1089,DUP} so the 
declaration of board1 would be like this:

  {board1[]=10(1, 2, 3);}

The effect is exactly the same that in the previous example. When the
compiler is in a initiation of board, the sequence
{number ( sequence_of_values ... )} thinks  that the {sequence_of_values} 
is going to be repeated the {number} of times indicated.

Is impossible to repeat a sequence of values zero or a negative number of
times.

{/}See: {#1000,Sintaxis} - {#1089,DUP}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.539,Incorrect asignation}

The indicated asignation can't be done in this position of the program.
In a statement of asignation it's only allowed to asign values to
objects like variables (of any kind) to a position of a board or to
an element of a structure.

It is not possible to asign a value to a {#1004,constant}, to a
function or to a process, or, in general, to any logic or numeric
expression.

In the following program some examples of some types of incorrect asignations 
are shown:


{#9999,Example:}
PROGRAM my_game;
CONST
    my_constant=0;
BEGIN
    my_constant=1;  // Error: Incorrect asignation.
    type my_game=2; // Error: Incorrect asignation.
    sizeof(mouse)=3; // Error: Incorrect asignation.
    4+5=6;           // Error: Incorrect asignation.
    //...
END
{-}

All these asignations are not valid because an asignation can't modify the
result of an expression, which is just a numeric value; due to that, is like to
place a statement of the type {2=4;} which, of course, is impossible to realize.

{/}See: {#1000,Sintaxis} - {#1035,Definition of expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.540,Waiting [END]}

Inside of the reserved words {#1086,BEGIN} and {#1091,END} a block of 
statements is expected, as inside of the following statements:

  {#1020,IF} ... {#1090,ELSE} ... {#1091,END}ú
  {#1024,LOOP} ... {#1091,END}ú
  {#1022,WHILE} ... {#1091,END}ú
  {#1025,FOR} ... {#1091,END}ú
  {#1043,FROM} ... {#1091,END}ú
  {#1021,SWITCH} ... {#1091,END}ú

A block of statements finishes (and only can finish) with any of these
three reserved words: {#1091,END}, {#1097,UNTIL} or {#1090,ELSE}.

In the program there is a block that was expected to finish with the reserved word
{#1091,END} but finishes with other word; the two more common cases are:

- That a {#1023,REPEAT} has lost or a {#1020,IF} finishing the block of
statements with a {#1097,UNTIL} or a {#1090,ELSE}; in this case, the
{#1023,REPEAT} must be found or {#1020,IF} associated.

{#9999,Example:}
PROGRAM my_game;
BEGIN
//  REPEAT
    //...
    UNTIL (key(_esc)); // Error: Waiting [END].
END
{-}

  In this example, the block of statements which started with the {#1086,BEGIN}
of the main program has finished with a {#1097,UNTIL} (because the
{#1023,REPEAT}) has been commented accidentally, and the compiler was waiting that
this block would finish with a {#1091,END}.

- That it has lost a {#1091,END} of some statement and arrives the next {#1016,PROCESS}, 
{#1408,FUNCTION} or the finish of the program waiting the END that has lost.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    IF (x<0) x++;
END
PROCESS my_process() // Error: Waiting [END].
BEGIN
    //...
END
{-}

  In this case the {#1091,END} of the {#1020,IF} has not be place thinking that
the compiler that the {#1020,IF} finishes when arrives to the next {#1091,END}
(the one of the {#1086,BEGIN}) and for that, when the new {#1016,PROCESS} arrives
or {#1408,FUNCTION}, the {#1091,END} of the {#1086,BEGIN} is still expected.

{/}See: {#1000,Sintaxis} - {#1091,END}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.541,Incorrect expression}

In the indicated position of the program there is an expression incorrectly
built, so the compiler can't understand it.

- Check the {#1000,sintaxis} of the expression.

- In case of no error, try to express it in other way.

- Try to divide the expression into some subexpressions doing it
sequencialy and in a separated way so the different calculations that are made
in the original expression. For example, the expression:

  {x=(x*4+1)/2;}

  can be expressed as three different expressions, which are:

  {x=x*4;}ú
  {x=x+1;}ú
  {x=x/2;}ú

  In this way it will be able to localize in which exact point of the calculate is the
operation that can't be realized.

{/}See: {#1000,Sintaxis} - {#1035,Definition of Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.542,Waiting [UNTIL]}

A block of statements that begun with the reserved word {#1023,REPEAT}
must finish with the word {#1097,UNTIL}; in the indicated position of the
program has finished the block of statements with other different word,
what will happen is:

- That it has finished with a {#1023,REPEAT} and a {#1091,END} in which case,
if what is wanted is to make a loop indefinitely, the statement 
{#1024,LOOP} ... {#1091,END} must be used.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    REPEAT
    //...
    END // Error: Waiting [UNTIL]
END
{-}

- That inside of the loop {#1023,REPEAT} ... {#1097,UNTIL} appears a word
like {#1091,END} or {#1090,ELSE} of more and, for that, without it's 
correspondant beginning ({#1020,IF}, {#1022,WHILE}, ...).

{#9999,Example:}
PROGRAM my_game;
BEGIN
    REPEAT
        IF (x<0) x++; END
            y++;
        END // Error: Waiting [UNTIL]
    UNTIL (x>=0);
END
{-}

  In this case, the {#1091,END} of the {#1020,IF} has been placed two times,
thinking the compiler that the second {#1091,END} pretends to close the
{#1023,REPEAT}.

- Or, that the {#1097,UNTIL} of the {#1023,REPEAT} has been forgotten.

{/}See: {#1000,Sintaxis} - {#1023, Statement REPEAT} - {#1020,IF} - {#1022,WHILE}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.543,Local can't be accessed}

In the indicated position in the program is wanted to acces to a data
of another process, being impossible because this data is not local
of the other process.

It must be checked that the data that is wanted to be accessed to be defined
inside of the section {#1007,LOCAL} of the program, or a local data
predefined in the language (as {#1123,x}, {#1124,y}, {#1126,graph},
{#1128,size}, ...).

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    id_my_process;
    puntos=0;
BEGIN
    id_my_process=my_process();
    id_my_process.x=0;
    id_my_process.points=0; // Error: Local can't be accessed.
END
PROCESS my_process()
BEGIN
    //...
END
{-}

In this case is wanted to access to the {points} of {my_process}, but
{points} is a unique variable {#1006,GLOBAL} and no a variable {#1007,LOCAL}
of each process. This can happens also trying to access to a constant
(defined in {#1005,CONST}) or to an expression like:

  {x=id_my_process.(x+1);}

In this last example, the expression has no sense completely;
probably it would be the following expression the one that is going to be
formulated:

  {x=id_my_process.x+1;}

  (equivalent to {x=(id_mi_process.x)+1;}).

{/}See: {#1000,Sintaxis} - {#1007,Declaration of local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.544,Parameter no valid}

The processes can take parameters in the following types of data:

- A predefined local data (as {#1123,x}, {#1128,size}, {#1127,flags}, ...).

- A definied local data inside of the section {#1007,LOCAL}.

- A definied global data inside of the section {#1006,GLOBAL}.

- A private data of the process declarated inside of the section {#1008,PRIVATE}
of the process.

- A private data that is {not declared} inside of the section
{#1008,PRIVATE}.

Understanding that in all of these cases in which a data can refer into a 
variable, to a certain position of a board or an element inside of a structure.

In the indicated position of the program is wanted to take a parameter as
a different object of the above indicated, or indicate an expression instead of
a simple data. These are some examples of declaration of invalid parameters:

  {PROCESS my_process(my_constant)}ú
  A parameter in a constant can't be taken.

  {PROCESS my_process(x*2)}ú
  A parameter in an expression can't be taken.

  {PROCESS my_process(x=0)}ú
  A parameter in an asignation can't be taken.

{/}See: {#1000,Sintaxis} - {#1018,Parameters of a process}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.545,Another parameter was expected}

In the calls to processes or functions as many values or expressions as required
must be taken, everyone inside of the {#1053,parenthesis} and separated by 
{#1059,commas (,)}. This error is produced when the parenthesis are closed 
after a {#1059,comma}, as in the following example:

{#9999,Example:}
PROGRAM my_game;
BEGIN
    signal(id, ); // Error: Another parameter was expected.
END
{-}

Two things can hapenned; a comma has been written accidentally after the last
parameter, or the last parameter has been omitted (as in the previous example).

{/}See: {#1000,Sintaxis} - {#1018,Parameters of a process}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.546,Number of parameters incorrect}

The process or function has a different number of parameters that those that appear
in the signed position by the program.

If it is a function, access to the {glossary} to see the parameters which are
required or place the cursor over the name of the function in the program
and then press {F1}.

If it is a process, then it can be that in the signed position, the number of
parameters is correct but a call to the process has appear
previously in the program with a different number of parameters.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    my_process();
END
PROCESS my_process(x, y) // Error: Number of parameters incorrect.
BEGIN
    //...
END
{-}

In this example the error is not in the definition of the process as it is indicated,
but in the call previous to the process ({my_process();}); this is like that
because the compiler, when finds a call to a process that it doesn't know
registers it as a new process and saves it's number of parameters.
If the next time when is found the process, the number of parameters are not
the same as the previously registered, then, an error is given.

In case of being correct the call or definition of the process, signed in the 
program, use the option Find ({ALT-F}) to check the number of parameters in the
previous calls to the process.

{/}See: {#1000,Sintaxis} - {#1018,Parameters of a process}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.547,Waiting [;]}

The statement {#1024,FOR} has three parts inside of the parenthesis separated by
point and comma, being these part of the followings:

  FOR ({initiation}; {condition}; {increment})

- The {initiation} use to be an {#1019,asignation} which fixes the
value of a data when the statement {#1025,FOR} starts.

- The condition that is established in second place determines the permanence
inside of the loop; each iteration will be look first if the conditions is true, 
and in the opposite case, the execution of the statement {#1025,FOR} will finish.

- The {increment} actualize the value of the data that is used as counter after
each iteration of the loop.

None of the three parts are obligatory, but the brackets are and the two
symbols {#1068,point and comma (;)} that separate the parts.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FOR ( graph=10 ; graph<20 ; graph=graph+1 )
        //...
    END
    FOR ( graph=10 ; graph<20 graph=graph+1) // Error: Waiting [;]
        //...
    END
END
{-}

Inside of each one of the three parts you can put few statements if they are
separated by {#1059,comas (,)} (few initiations, conditions or
increments).

{/}See: {#1000,Sintaxis} - {#1068, Point and comma (;)} - {#1025,statement FOR}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.548,[BREAK] doesn't appear inside of a loop}

The statement {#1026,BREAK} makes the program to continue after the loop is
running.

This statement is used to go out of the following loops:

  {#1024,LOOP} ... {#1091,END}ú
  {#1043,FROM} .. {#1096,TO} .. {#1095,STEP} .. ... {#1091,END}ú
  {#1023,REPEAT} ... {#1097,UNTIL} {#1053,(} .. {#1053,)}ú
  {#1022,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
  {#1025,FOR} {#1053,(} .. {#1068,;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú

One {#1026,BREAK} will make the program to continue running after the
{#1091,END} or {#1097,UNTIL} of the nearest loop to the statement.
{#1026,BREAK} only can appear inside of one of these loops}.

In the case of being some loops, one inside of another, the statement
{#1026,BREAK} will go out of the most internal loop.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    LOOP
        REPEAT
            IF (key(_esc)) BREAK; END
            //...
        UNTIL (x==0);
        //...
    END
    BREAK; // Error: [BREAK] doesn't appear inside of a loop.
END
{-}

In this example, the statement {#1026,BREAK} will go out of the
{#1023,REPEAT} ... {#1097,UNTIL} (When the key {ESC} be pressed)
but no of the {#1024,LOOP} ... {#1091,END}.

{/}See: {#1000,Sintaxis} - {#1026,statement BREAK}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.549,[continue] doesn't appear inside of a loop}

The statement {#1027,continue} makes that the program finishes the 
current iteration of the loop that is executing.

This statement is used to go to the beginning/end of the following loops:

{#1024,LOOP} ... {#1091,END}ú
One {#1027,continue} inside of this loop will go to the {#1024,LOOP}.

{#1043,FROM} .. {#1096,TO} .. {#1095,STEP} .. ... {#1091,END}ú
One {#1027,continue} inside of this loop will make the increment
({#1095,STEP}) and, if the indicate value is not passed in the
{#1096,TO}, the program will continue at the beginning of the loop.

{#1023,REPEAT} ... {#1097,UNTIL} {#1053,(} .. {#1053,)}ú
One {#1027,continue} inside of this loop will go to the {#1097,UNTIL}.

{#1022,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
One {#1027,continue} inside of this loop will go to the {#1022,WHILE}.

{#1025,FOR} {#1053,(} .. {#1068,;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú
One {#1027,continue} inside of this loop will make the increment and the
comparison; if the last one is true, then the program will continue
at the beginning of the loop, but if it is false, the program will continue
after the {#1091,END} of the {#1025,FOR}.

{#1027,continue} {must appear inside of one of these loops}.

If there are some loops, one inside of another, the statement {#1027,continue} 
will have only effect in the most internal loop.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FOR (x=0, y=0;x<10;x++)
        IF (x<5) continue; END
        y++;
    END
END
{-}

In this example after run the complete loop {x} will be {10} and {y}
will be {5}, because meanwhile {x} is smaller than 5 the statement {#1027,continue}
doesn't let to be executed the statement {y++;}.

{/}See: {#1000,Sintaxis} - {#1027,statement continue}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.550,Waiting [CASE], [DEFAULT] o [END]}

The sintaxis of the statement {#1021,SWITCH} is as it follows:

    {#1021,SWITCH} {#1053,( }expression{#1053, )}ú
        {#1087,CASE} value{#1067, :}ú
            statements{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} value{#1064, .. }value{#1067, :}ú
            statements{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} value, value, value{#1067, :}ú
            statements{#1068,;}ú
        {#1091,END}ú
        //...ú
        {#1088,DEFAULT} {#1067,:}ú
            statements{#1068,;}ú
        {#1091,END}ú
    {#1091,END}

The position marked in the program is inside of a statement {#1021,SWITCH},
but outside of a section {#1087,CASE} o {#1088,DEFAULT}; for that the compiler
is waiting that in this position appears one of these three statements:

- The reserved word {#1087,CASE} initiating a new section to execute
when the expression coincides with the indicate value.

- The reserved word {#1088,DEFAULT} initiating one section to execute
when the expression doesn't coincide with any of the indicated values in the 
different sections {#1087,CASE}.

- The reserved word {#1091,END} finishing the statement
{#1021,SWITCH}.

To see a description more detailed of the statement {#1021,SWITCH}
see the sintaxis of the language.

{/}See: {#1000,Sintaxis} - {#1021,statement SWITCH}


# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.551,Waiting [END]}

It was waited one {#1091,END} from {#1087,CASE} or {#1088,DEFAULT} inside the statement {#1021,SWITCH}.

Inside the reserved words {#1021,SWITCH} and {#1091,END} it is waited one o more  sections like:

  {#1087,CASE} ... {#1091,END}ú
  {#1088,DEFAULT} ... {#1091,END}ú

In the program there is one from this sections which is supposed finishes with the reserved word {#1091,END} but is finished with another word; the most probable case is:

- Was the lost one {#1023,REPEAT} or one {#1020,IF} finishing the block
of statements with one {#1097,UNTIL} or one {#1090,ELSE}; in this case it is necessary to find the {#1023,REPEAT} or accompanying {#1020,IF}.

{#9999,Example:}
PRoGRAM my_game;
BEGIN
    SWITCH (x)
        CASE 0:
            //REPEAT
            //...
            UNTIL (key(_esc)); // Error: Waiting [END]
        END
    END
END
{-}

In this example the section which began with the {#1087,CASE} finishes with
one {#1097,UNTIL} (because accidentally was coMmented {#1023,REPEAT}), 
and the compiler was waiting this section to be finished with one {#1091,END}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.552,Waiting [PROCESS] or [FUNCTION]}

The compiler interpreted that, in the marked position in the program, was finished the main program
({#1015,PROGRAM} ... {#1086,BEGIN} ... {#1091,END}), or the last
process ({#1016,PROCESS}) or function ({#1408,FUNCTION}) and, in
continuation, was waited to be continued another process or the program to be finished.

The most frequent is to be duplicated one {#1091,END} inside the last block of
statements {#1086,BEGIN} ... {#1091,END}.

{#9999,Example:}
PRoGRAM my_game;
BEGIN
    IF (x<0) x++; END
    END
    FRAME; // Error: Waiting [PROCESS] or [FUNCTION].
END
{-}

In this examples accidentially was put twice the {#1091,END}
from {#1020,IF}, interpreting the compiler that the second is the {#1091,END}
from {#1086,BEGIN}, therefore, after the last {#1091,END} can be only the program end or the reserved words {#1016,PROCESS}
or {#1408,FUNCTION} marking the new block beginning. Once one statement is localized in this position {#1029,FRAME}, the compiler commits the error.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.553,Can not specify one board as parameter}

It is not necessary to declare inside the section {#1008,PRIVATE} the
{#1018,process parameters}, they will be declared automatically;
in the case of its declaration have to be declared as variables
not as boards or structures, and have not to be initiated.

The most probable is that it was pretended to use the same name for two different objects; on the one hand, for one of the process parameters
and, on the other, for one board {#1008,PRIVATE} of the same process.

{#9999,Example:}
PRoGRAM my_game;
BEGIN
    //...
END
PROCESS my_process(a)
PRIVATE
    a[9]; // Error: Can not specify one board as parameter.
BEGIN
    //...
END
{-}

The compiler interpretes that is typifying the parameter {a} as
one board of 10 positions and if one board can not pass as
parameter, emits the error.

{/}See: {#1000,syntax} - {#1018,Process parameters}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.554,Can not initiate one parameter}

It is not necessary to declare inside one section {#1008,PRIVATE}
the {#1018,process parameters}, because they are declared
automatically, in the case of its declaration must be declared
as variables not as boards or structures, and have not to be initiated.

The most probable is that it was pretended to use the same name for two different objects; on the one hand, for one of the process parameters
and, on the other, for one board {#1008,PRIVATE} of the same process.

{#9999,Example:}
PRoGRAM my_game;
BEGIN
    //...
END
PROCESS my_process(a)
PRIVATE
    a=0; // Error: Can not initiate one parameter.
BEGIN
    //...
END
{-}

The compiler interpretes that it is initiating the parameter {a} a {0},
and as it is not permited initiate one parameter (its value will take in fuction from the named process), emits the error.

{/}See: {#1000,syntax} - {#1018,Process parameters}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.555,The end inside one commentary}

Reached the end of the program inside one commentary of some lines
(the definitions between the symbols{#1002, /*} and{#1002, */}).

This error is because one of the commentaries is not certain, therefore it is necessary to examine if all open commentaries with the symbol{#1002, /*} have its correspondential symbol{#1002, */} to be closed.

{#9999,Example:}
PRoGRAM my_game;
BEGIN
    /* Commentary beginning
    FRAME;
END // Error: Reached the commentary end.
{-}

{/}See: {#1000,syntax} - {#1002,Commentary definition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.556,Can not acceede the PRIVATE external data}

In the indicated position of the program is intenting acceede to one data
like {#1008,PRIVATE} of the another process; it is not  permited.

If you want to acceede from one process to one data of the another, this must be declared inside the section {#1007,LOCAL}.

{#9999,Example:}
PRoGRAM my_game;
PRIVATE n;
BEGIN
    my_process();
    //...
END
PROCESS my_process()
PRIVATE n;
BEGIN
    father.n=0; // It is not possible to acceede to PRIVATE external data.
END
{-}

It is imposible to acceede to data {#1008,PRIVATE} including when the acceeded process has the same type as the process which is intenting to acceede to data.

The correctly form in which must be declared the variable {n} in the last example.
It will be shown in continuation:

{#9999,Example:}
PROGRAM my_game;
LOCAL n;
BEGIN
    my_process();
    //...
END
PROCESS my_process()
BEGIN
    father.n=0;
END
{-}

We remind that the declared inside the section data {#1007,LOCAL}
All program processes will have them (all the processes from the last example will have another variable name {n}).

{/}See: {#1000,syntax} - {#1008,Declaration of PRIVATE data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.557,one structure must contain, at least, one element}

In the rush out position of the program is pretended to close with
{#1091,END} the declaration of one structure without
any element (field) defined in the same.

One structure ({#1012,STRUCT}) is like one list of files
(registers) with different informations (fields) in each file.

{STRUCT name_structure[10]}ú
    {x, y;}ú
{END}

In this example the structure (files group) is named {name_structure}
And have {10 registers} (ten files) with {2 fields} each other (with two
informations; {x} and {y}).

Therefore, there is no sense to define one structure
without fields (because is the same as to define one files group without any
information).

To acceede than to the files information will be used the structure.
As continues (supose that you want to put in the variable global {n} the value
{y} of the file number {5}).

{n=number_structure[5].y;}

In continuation will be shown one erroneous program.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT my_structure[10]

    END // Error: one structure must contain, at least, one element.
BEGIN
    //...
END
{-}

{/}See: {#1000,syntax} - {#1012,Structure declaration}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.558,Waiting one element of the structure}

In the marked position of the program is pretended to declare one invalid element (field) of the structure.

One structure can have only fields of such types:

- one variable, in which case have to indicate in the declaration its name, without initiate.

- one board, indicating its name and, in continuation, between brackets, its length (remember that one declared board as {my_board[9];} is a board of {10} positions, from my_board[0] to my_board[10]). Not necessary to initiate.

- other structure. Is possible to include structures inside the others, without any limit of quantity, while it is necessary. In continuation will be shown one example of adding of structures.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT my_structure[9]
        elements;
        STRUCT data[9]
            x, y;
        END
    END
    a, b;
BEGIN
    FROM a=0 To 9;
        my_structure[a].elements=-1;
        FROM b=0 To 9;
            my_structure[a].data[b].x=-1;
            my_structure[a].data[b].y=-1;
        END
    END
    //...
END
{-}

In this example, each register from {my_structure} will have one variable
denominated {elements} and another structure with 10 elements each other with two variables: {x} and {y}.

Further, in the same example, one can observe one example of access
to named structure with two added rianglets which initiate all values of the structure a{ -1}.

To see how must initiate in proper definition the values of one structure acceede to the typical {#1000,syntax}.

{/}See: {#1000,syntax} - {#1012,Structure declaration}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.560,It is not one process type}

The operator {#1042,TYPE} can be used only if is proper to one name of process of the program or to the word {#1100,mouse}
(for the detection of collisions with the mouse pointer).

In the signed position of the program it is not proper to a name of
process; it is probable that the process name was written incorrectly
or intents to obtain the process type on the strength of its {#1039, identification code}.

There is one way to obtain the process type if it is known its {#1039, identificataion code},
as it is shown in continuation (supose that the identifier is in
the variable {id2}).

    {id2.reserved.process_type}

In the place of {TYPE id2} which is not permitted (there is no process
named {id2}, because {id2} is one variable).

In continuation will be shown one example of the correct use of the operator {#1042,TYPE} (with the goal to obtain the {#1039,identification code} of one process).

{#9999,Example:}
PROGRAM my_game;
PRIVATE
    id2;
BEGIN
    //...
    id2=get_id(TYPE my_process);
    //...
    id2=get_id(TYPE id2); // Error: This is not a process type.
    //...
END
PROCESS my_process()
BEGIN
    //...
END
{-}

As it is seen, the operator {#1042,TYPE} requires the name of
one process of the program without parentheses not parameters.

{/}See: {#1000,syntax} - {#1042,Process types}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.561,Can not calculate the size}

The function {#1094,sizeof()} can be used to obtain the number of
elements from one board or from one structure; for it
requires, between {#1053,parentheses},  the name of the board or
structure (without brackets not index).

It can be used with the name of one variable as well but, in this case,
the function return is always 1.

Also can be used with global, local or private data.

In the signed position of the program it is pretended to  obtain the size of one
object which is not one variable quantity, board or structure. For example, this error is produced if it is intenting to obtain the size of one constant, function, process, etc.

{#9999,Example:}
PROGRAM my_game;
CONST
    my_constant=99;
GLOBAL
    a=sizeof(my_constant); // Error: Can not calculate the size.
BEGIN
    //...
END
{-}

This example provokes the error while intenting to obtain the number of elements
of one {#1004,constant}, one constant is not one object which has one size but is only a synonym to the number value which represents.

{/}See: {#1000,syntax} - {#1094,sizeof}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.562,Use: IMPORT "name.dll"}

The compiler was waiting, after the reserved word {#1014,IMPORT}, to appear
in inverted commas the archives name.

To declare the use of one external library it is necessary to run one declaration as in the example.

{#9999,Example:}
PROGRAM my_game;
IMPORT "libreria.dll";
BEGIN
    //...
END
{-}

This program declares the use of the denominated library {libreria.dll}
(suposed name of one hypotetic library with the external functions).

The declaration has to be done together {after the heading of the program},
so, after the declaration {PROGRAM name_of_program;}. It is possible to make different consecutive declarations {#1014,IMPORT}, to declare the use of more than one library.

{/}: {#1000,syntax} - {#1014,Declaration of libraries}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.563,Use of one external DLL is invalid}

In the indicated position of the program it is pretended to load one {DLL} which
is invalid; this can occure because of:

- The archive with the {DLL} was corrupt because of the accumulation in one defected place.

- One {DLL} was designed specially for DIV Games Studio.

- Can not find the file with extention {DLL} in the specified by the statement route {#1014,IMPORT}.

Can not use {DLL} of other languages, they are not compatible with this language inspite the all files have the extention {DLL}.

In case of talking about one {DLL} prepared for this language, revise your instructions of installation and check the file with extention
{DLL} to be in the directory of DIV Games Studio, or the statement {#1014,IMPORT} specifies the complete route to access to named file.

{/}See: {#1000,syntax} - {#1014,Declaration of libraries}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.564,expression without sense}

In the signed position in the program the compiler supposed that was beginning
one of this statements:

    Asignations, ej.:ú
    <data>{ = }<expression>{ ; }

    Increments or decrements, ej.:ú
    <data>{ ++ ;}

    Name of one process or function, ej.:ú
    <name_process>{ ( }...{ ) ;}

But, in its place, was met one expression which seems to be senseless, because once its operations were effected does not use the result with any propose.

It is possible that one operator, which flew out, was left out of one sentense, for example, because he lost one operator.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    x+1; // Error: Expression without sense.
    //...
END
{-}

In this example we adverte to this error, so the statement {x+1;} is useless, sums the variable quantity {x} and the constant {1}, but, than does not use this result for any propose. What is it necessary is to sum {1} with
the variable quantity {x} has to be done with such statement:

    {x=x+1;}

Here sums the variable {x} and the constant {1} and than this result is used to asign it to the variable {x}; this also could be done with the statement {x++;} (increment x).

{/}See: {#1000,syntax} - {#1019,statement of asignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.565,Waiting [:]}

The signed position in the program is inside one statement {#1021,SWITCH},
After the beginning of one section with "{#1087,CASE} value", therefore the compiler was waiting in named position to appear the symbol{#1067, :} preceding to the statements of named section.

The syntax of the statement {#1021,SWITCH} is, in outline, so:

    {#1021,SWITCH} {#1053,( }expression{#1083, )}ú
        {#1087,CASE} value{#1067, :}ú
            statements{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} value{#, .. }value{#1067, :}ú
            statements{#1068,;}ú
        {#1091,END}ú
        {#1087,CASE} value, value, value{#1067, :}ú
            statements{#1068,;}ú
        {#1091,END}ú
        //...ú
        {#1088,DEFAULT} {#1067,:}ú
            statements{#1068,;}ú
        {#1091,END}ú
    {#1091,END}

To see more detail description of the statement {#1021,SWITCH}
consult the syntax of languages.

{/}See: {#1000,syntax} - {#1021,statement SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.566,Waiting [;]}

The compiler is waiting one {#1068,point and comma (;)} in the position indicated in the program.

In the language must be indicated two points and comma such points of the program:

- The end of the {#1400,options of compilation}.

- The end of the {#1003,declaration PROGRAM}.

- The end of one {#1009,declaration of one data}.

- The end of one {#1014,declaration IMPORT}.

- The end of such statements:ú
    {#1019,Asignations or increments of data}.ú
    {#1033,Call a processes}.ú
    {#1032,Call a functions}.ú
    {#1029,FRAME}, {#1028,RETURN}, {#1031,DEBUG}, {#1026,BREAK} y {#1027,continue}.ú

- The end of the loop initiation {#1043,FROM}.

- And as separator of the different parts of one statement {#1025,FOR}.

The compiler will indicate when there will be shortage of symbol {;} in one of this points.

Also this symbol can be put in other determined points of the programs, after each type of the statement, but this will be the optional case and therefore the compiler will not adverte its absence.

{/}See: {#1000,syntax} - {#1068, ; }

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.567,Waiting variable}

The compiler was waiting one global variable quantity, local or
private of the process in the position indicated in the program.

The syntax of the loop statement {#1043,FROM} is:

{FROM} <variable>{=}{#1005,<constant>} {#1096,To} {#1005,<constant>} {#1095,STEP} {#1005,<constant>}{;}ú
    {#1017,<statement>} {;}ú
    ...ú
{END}

Being the optional declaration {STEP <constant>}.

After the reserved word {#1043,FROM} must appear directly the
{#1001,name} of one variable quantity (normally local or private of the process).

If you want to use as counter one variable from another process,
one board or one element from one structure, must be used the statement {#1025,FOR} instead of {#1043,FROM}, because this gives more liberty
in the moment to define the conditions of the loop.

{/}See: {#1000,syntax} - {#1043,statement FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.568,Waiting [=]}

The compiler was waiting one symbol {#1073,=} (asignation) in the position indicated in the program.

The syntax of the statement of loop {#1043,FROM} is:

{FROM} <variable>{=}{#1005,<constant>} {#1096,To} {#1005,<constant>} {#1095,STEP} {#1005,<constant>}{;}ú
    {#1017,<statement>} {;}ú
    ...ú
{END}

Being the optional declaration {#1095,STEP <constant>}.

After reserved word {#1043,FROM} must appear directly the
{name} of one variable (normally local or
private of the process) and, after it the symbol {#1073,=}
(asignation).

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    id2;
BEGIN
    //...
    FROM id2.x=0 To 9; // Error: Waiting [=].
        //...
    END
END
{-}

In this example the error is produced as it was detected after the {first name}
which appears ({id2}) the symbol{#1063, . (point)} instead of {#1073,=}. This
succeeds because it is not possible to use as counter from one loop {#1043,FROM} one variable of another process.

If you want to use as counter one variable of another process,
one board or one element of one structure, must be used the statement {#1025,FOR}, instead of {#1043,FROM}, because it gives more liberty in the moment to define the conditions of the loop.

{/}See: {#1000,syntax} - {#1043,statement FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.569,Waiting [To]}

The compiler was waiting the reserved word {#1096,To} of the statement
{#1043,FROM} in the indicated position in the program.

The syntax of the statement of loop {#1043,FROM} is:

{#1043,FROM} <variable>{=}{#1005,<constant>} {#1096,To} {#1005,<constant>}
{#1095,STEP} {#1005,<constant>}{;}ú
    {#1017,<statement>} {;}ú
    ...ú
{#1091,END}

Being the optional declaration {#1095,STEP <constant>}.

After reserved word {#1043,FROM} must appear directly the {name} of one variable (normally local or private of the process) and after it the symbol {#1073,=} (asignation) preceding with one constant. {After this value constant can appear only reserved word {#1096,To}.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    id2;
BEGIN
    //...
    FROM id2.x=0 STEP 9; // Error: Waiting [To].
        //...
    END
END
{-}

In one statement {#1043,FROM} always must appear the {initial}
and {final} values of the variable counter of the loop on the two sides of the word {#1096,To}.

{/}See: {#1000,syntax} - {#1043,statement FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.570,The value STEP is invalid}

In one statement {#1043,FROM}:

- If the initial value {is smaller} than the final value, can not specify in the declaration one negative value {#1095,STEP}.

- If the initial value {is bigger} than the final value, can not specify in the declaration one positive value {#1095,STEP}.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FROM x=0 To 10 STEP -1; // Error: The value STEP is invalid.
        //...
    END
END
{-}

This loop is invalid so if {x}, which originally values  {0},
rests {1} in each repeat, never will reach {10}. If it pretends to make one loop which would repeat always, must be used the statement {#1024,LOOP}.

{/}See: {#1000,syntax} - {#1043,statement FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.571,statement FROM is incorrect}

In one statement {#1043,FROM}:

- The {initial} and {final} values of one loop {#1043,FROM} must be different.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FROM x=0 To 0; // Error: statement FROM is incorrect.
        //...
    END
END
{-}

There is no sense to realize the buck, will not repeat the interior statement group more than once, this would be equivalent to initiate {x} to {0} (with the statement {x=0;}) and than put directly the interior statements, omitting
the loop {#1043,FROM}.

If you want to make one which could repeat always, you must use the statement {#1024,LOOP}.

{/}See: {#1000,syntax} - {#1043,statement FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.599,Incorrect compilation}

The program has not compilation errors, press:

{Menu programs\Execute} or {F10}.ú
To save, compile and execute the program.

{Menu programs\Sketch} or {F12}.ú
To record, compile and sketch step by step the program.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.600,Exceeded the capacity of the vector of names}

The buffer is exceeded to accumulate the {#1001,names} of the program;
This error is produced only because were used too large data and processes names.

The only solution to compile the program is to substitute some of this names with another shorter.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.601,Exceeded the capacity of the demo version}

This DEMO version of DIV Games Studio does not permit create so big programs as this one, can only compile programs from one determined number from variables quantities and processes.

In the complete version of DIV GAMES STUDIO does not exist this limitation, so you can create the programs of any size.

The only option to compile this program is first undo all the processes and data which yet are not required and/or are not seen
imprescriptable.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.602,Exceeded the capacity of the board of objects}

Exceeded the disposed space to save registers of the data and
the processes of the program.

This error will never succeed but if it happens there is one difficult solution; the program is too big for this version of the compiler.

If exists one new version of the compiler or one 'patch' which actualizes
this limitation, it must be actualized.

Otherwise the only option is undo from the program all processes and {#1034,data} which yet are not required and/or are not seen
imprescriptable.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.610,Waiting the structure name}

To define one structure of data must be specified its name and the reserved word {#1012,STRUCT}.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT positions[9]
        x, y;
    END
BEGIN
    //...
END
{-}

This structure was defined with the name {positions} and contains
{ten registers} (from 0 to 9) each one with two values {x} and {y}.

{/}See: {#1000,syntax} - {#1001,Names} - {#1012,Declaration Structures}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.611,Waiting the process or function name}

To define one process or function it is necessary to specify its name and the reserved words {#1016,PROCESS} o {#1408,FUNCTION}.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    //...
END

PROCESS my_game()
BEGIN
    //...
END
{-}

This process was declared with the name {my_process}.

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.612,Waiting the process name}

After reserved word {#1042,TYPE} must be specified the name of one of the processes defined in the program.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    //...
    signal(TYPE my_process, s_kill);
    //...
END

PROCESS my_process()
BEGIN
    //...
END
{-}

{/}See: {#1000,syntax} - {#1001,Names} - {#1042,Process types}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.613,Waiting one name}

The function {#1094,sizeof()} requires as parameter the name of one data,
it can be the name of one variable quantity, one board or one
structure of the program.

This function returns the data (or elements) number which has the object,
which name passes as argument; therefore, if this object was one variable, the function return always 1.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    board[]=0, 1, 2, 3;
    length_board;
BEGIN
    length_board=sizeof(board);
END
{-}

In this example {length_board} will value {4} after execute the statement,
because the board contains four data.

{/}See: {#1000,syntax} - {#1001,Names} - {#1094,sizeof}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.614,The name is not the new one}

One name was used twice in the structure field. This name must be substituted with the another similar.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{#9999,Example:}
PROGRAM name_of_program;
GLOBAL
    STRUCT position[9]
        x0, x0; // Error: The name is the new one.
    END
BEGIN
    //...
END
{-}

{/}See: {#1000,syntax} - {#1001,Names} - {#1012,Declaration of structure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.615,The name is not the new one}

It was used one invalid {#1001,name} in program, it was yet predefined as the name of other object. You must substitute
this name with another similar.

To know which object is identified with this {#1001,name} you can acceed to the
{glossary}.

{#9999,Example:}
PROGRAM x; // Error: The name is not the new one.
BEGIN
    //...
END
{-}

In this example it is pretended to use as the program name {x},
what predefines the name of the local variable which indicates the coordinate
x of the processes.

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.616,The name is not the new one}

To define one {#1004,constant} was used one invalid {#1001,name}
it is yet predefined as the name of another object.
It could be name of one constant, one variable,
one board, one structure, one process or
one function of the program.

Also it was pretended to use the same {#1001,name}
inside the program to identificate two different objects, or
{it was used one name predefined for other use inside
the language}. In this case you can acceed to {glossary} to see 
to which object belongs this name.

You must substitute this name with one similar.

{#9999,Example:}
PROGRAM my_game;
CONST
    x=0; // Error: The name is not the new one.
BEGIN
    //...
END
{-}

In this case was pretended to use as the constant name {x} which
is  predefined as local variable which indicates the coordinate {#1123,x} of the
processes.

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.617,The name is not the new one}

To define one new data was used one invalid {#1001,name}
it was yet predefined as the name of the other 
object. It could be the name of one {#1004,constant},
one variable, one board, one structure,
one process or one function of the program.

Also, may be was pretended to use the same name inside the same program
to identificate two different objects, or {was used
one name predefined for another use inside the language}.
In this case you can acceed to the {glossary} to see to which object belongs the name.

You must substitute this name with one similar.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    x[3]=0, 1, 2, 3; // Error: The name is not the new one.
BEGIN
    //...
END
{-}

In this case it is pretended to use as name from one global board {x}
which is predefined as local variable which indicates the coordinate {#1123,x} of the processes.

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.618, The name is not the new one}

Was used one {#1001,name} of one invalid process, 
it was yet predefined as the name of another object. It could be
name of one {#1004,constant}, one variable, one
board, one structure, one process or one
function of the program.

Also, may be was pretended to use the same name inside the same program
to identificate two different objects, or {was used
one name predefined for another use inside the language}.
In this case you can acceed to the {glossary} to see to which object belongs the name.


You must substitute this name with one similar.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    //...
END

PROCESS my_game() // Error: the name is not the new one.
BEGIN
    //...
END
{-}

In this example is pretending to use as name of one process
the name which before was used to identificate the
principal program.

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.619,Waiting [=]}

To define one constant you must put one symbol {#1073,=} after the name of the constant.

The compiler understood that the last defined word was the name
of one new {#1004,constant} and, in the indicated position, was waiting the asignation symbol to appear ({#1073,=}).

{#9999,Example:}
PROGRAM my_game;
CONST
    a=0;
    b=1;
    c,d; // Error: Waiting [=].
BEGIN
    //...
END
{-}

{/}See: {#1000,syntax} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.620,Too much values for the structure}

Was initiated one structure with too much values.

To initiate one structure you must remember the maximum number of values
which can be contained; this number is :

    {N§ from registers} X {N§ from fields}

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT positions[9]
        x, y;
    END = 10 dup (-99, 99);
BEGIN
    //...
END
{-}

In this case the structure {positions} have {10 registers} (from positions[0]
to positions[9]) and {2 fields} (x and y); than, the maximum number of values is
{20}. In the example initiate all the fields {x} to{ -99} and all
the fields {y} to {99}.

{/}See: {#1000,syntax} - {#1012,Declaration de structure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.621,Unknown name}

In the position indicated in the program is made the reference to one unexistant block {#1016,PROCESS} or {#1408,FUNCTION};
it could be one of this cases:

- The process or function name were written incorrectly;
revise the original name, may be in its definition it is written badly.

- Was pretended to use one function of the language
and the name was written incorrectly; in such case you can
acceed to help to find the exactly name of the function.

- It is made the reference to one process or function which code yet is not
defined, therefore if you want to compile the program you must
define the block, as you see:

{#9999,Example:}
PROGRAM my_game;
BEGIN
    my_process();
END

PROCESS my_process()
BEGIN
END
{-}

Indicating in the new block the parameters which receive (in the last example without parameter).

{/}See: {#1000,syntax} 

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.622,The increment can not be realized}

In the expression indicated in the program is used incorrectly the operator
{#1057, ++} (or the operator{#1061, --}), with the goal to
increment (or decrement) one object. This object has not direction,
this is not one variable, board or structure, therefore
the compiler can not realize one increment (or decrement) about itself.

May be was pretended to increment or decrement one constant expression or one which involves 
different operations.

In continuation, you will see one program with different examples of valid use of
the operators{#1057, ++} and{#1061, --}, and other invalid cases.

{#9999,Example:}
PROGRAM my_game;
CONST
    my_constant=0;
GLOBAL
    my_variable=0;
    my_board[10];
    STRUCT my_structure[10]
        variable;
    END
BEGIN
    // Correct examples
    my_variable++;
    my_board--;
    ++my_board[my_variable];
    --my_structure[0].variable;
    id.x++;

    // Erroneous examples
    (my_variable*2)++;
    my_constant--;
    ++0;
    --(my_variable+1);
END
{-}

The constants as {my_constant} can not be incremented, they are simple
synonyms of the number value which represent.

The statement {(my_variable*2)++;} is erroneous because firstly realize the
multiplication and than the value
{my_variable*2} converts in one number result which has not direccion
and therefore we can not acceed it to increment.

In this case may be the correct statement would be {my_variable=my_variable*2+1;}

{/}See: {#1000,syntax} - {#1057,++} - {#1061,--}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.623,Structure of the negative length}

To define one structure indicating between {#1079,brackets} its registered number
it is necessary to use one complete positive number (0, 1, 2, 3, ...), remembering that all the
structures begin in the register with null and finish with what it is indicated in the index.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT e1[9]
      x, y;
    END
    STRUCT e2[-9] // Error: Negative structure of length.
      x, y;
    END
BEGIN
    //...
END
{-}

The compiler detected one defined structure with one negative number of registers as
{e2}; in this case we have to define the structure as {e1} which,
is the structure of 10 registers (from e1[0] to e1[9])
and two fields (x and y).

{/}See: {#1000,syntax} - {#1012,Declaration of structure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.624,Was waited a statement}

The indicated position in the program is inside the environment of one
block of statements. These are the possible types of statements:

statements of asignationú
<expression>{#1035,=}<expression>;

statements of controlú
{#1020,IF} and {#1021,SWITCH}.

statements of loopsú
{#1043,FROM}, {#1022,WHILE}, {#1023,REPEAT}, {#1024,LOOP} and {#1025,FOR}.

statements of ruptureú
{#1026,BREAK}, {#1027,CONTINUE} and {#1028,RETURN}.

special statementsú
{#1029,FRAME}, {#1030,CLONE} and {#1031,DEBUG}.

It is possible that in this position appears one of the reserved words
which can mark the end of the statements block, as these:

{#1091,END}, {#1090,ELSE} and {#1097,UNTIL}.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    CASE 0: // Error: Was waited a statement.
        //...
    END
END
{-}

This example will produce the error, because the reserved word {#1087,CASE} is invalid
to begin one statement; it is valid only inside one statement {#1021,SWITCH}.

{/}See: {#1000,syntax} - {#1017,Declaration of statement}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.625,Waiting the name of the string}

To define one string of text you must specify the its name after the reserved word {STRING}.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRING player[32];
    STRING message;
BEGIN
    //...
END
{-}

In this example were defined two strings of the global text. The first is eith the name
{player} which can accumulate to 32 characters and the second with the name {message}
which with the undeclared length can accumulate
to 256 characters (because this is the board maximum size
of the strings of text).

{/}See: {#1000,syntax} - {#1001,names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.626,The name is not the new one}

As the string name of one text was used one which yet was
connected with another object defined before. It could be a name,
a constant, a variable, a board, a structure, a process or function
of the program.

Also, may be was pretended to use the same name inside the same program
to identificate two different objects, or {was used
one name predefined for another use inside the language}.
In this case you can acceed to the glossary to see to which object belongs the name.


In each case,{you must substitute this name with one similar}.

{#9999,Example:}
PROGRAM name_of_program;
GLOBAL
    player=0;
    STRING player; // Error: The name is not the new one.
BEGIN
  //...
END
{-}

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.627,Text string has a negative length}

To define one text string indicating in brackets its length,
it is necessary to use one complete positive number (0, 1, 2, 3, ...), remebering that all strings begin in the position null
and finish in the position which indicates the index.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRING string[9];
    STRING string2[-9]; // Error: Text string has negative length.
BEGIN
    //...
END
{-}

The compiler detected one text string with the negative string length as {string2};
in this example you must define the string as
{string1} which will be the string of 10 characters (from
string1[0] to string1[9]).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.628,Was waited a literal}

The literals are {texts in brackets}. In the indicated position of the
program was waited one literal as initial value of one text string.

The text strings can be initiated as it is shown in this example.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRING string="initial text in the string";
BEGIN
    //...
END
{-}

It is not obligatory to initiate the text strings of one program.
In the case of initiation, the string would have an empty text ("") in the beginning of the program,
so, this two declarations will be identical:

  {STRING} string;ú
  {STRING} string{=}""{;}

In this cases, their length is not declared, therefore the strings can accumulate
to maximum of 256 characters (because this is the board maximum size
of the strings of text).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.629,Literal is too long}

Was initiated one text string with a literal with bigger number of characters of which can be contained.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRING string1[3]="ABCDE"; // Error: Literal is too long
BEGIN
    //...
END
{-}

To initiate one text string you must remember that as maximum
it can have so much characters as it is indicated in the number, which is in brackets, more 1.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRING string1[3]="ABCD";
BEGIN
    //...
END
{-}

In this case a text string {string1} can contain four characters
(string1[0]=char("A"), string1[1]=char("B"), string1[2]=char("C") and
string1[3]=char("D")).

Other option is {not indicate the size of the string of text}, establishing in
this case the string sixe maxumum of 256 characters.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRING string1="ABCDEF";
BEGIN
    //...
END
{-}

In this case, {string1} would contain firstly six indicated characters
("ABCDEF"), but it can reach 256 during the execution of the program.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.630,Was expected a comma}

It is acceeding a board indicating less dimension of the required.

It means that a board of two dimensions is prentending to use one dimension as the one
or one board of three dimensions is prentending to use it as two.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    board1[9,9];
BEGIN
    //...
    board1[0]=0; // Error: Was expected a comma.
END
{-}

Check the previous declaration of the named board of data in the program.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.631,Was expected a comma}

It is acceeding a structure indicating less dimension of the required.

It means that a structure of two dimensions is prentending to use one dimension as the one
or one structure of three dimensions is pretending to use it as two.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT structure1[9,9];
      n;
      //...
    END
BEGIN
    //...
    structure1[0].n=0; // Error: Was expected a comma.
END
{-}

Check the previous declaration of the named structure of data in the program.


{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.632,Can not calculate the offset of the data}

In the expression indicated in the program is used the operator {#1085,offset}
(or synonymous symbol {#1085,&}) with the goal to obtain the direccion
(dislocation) of one {#1406,character}, {#1404,byte} or {#1403,word} which belongs
to one board.

It is not permited, it is possible only to obtain the direccion in the beginning of the
board, but not of its data (except such data as {#1402,int}).

In continuation it is shown a program with two examples of use of the operator
{#1085,offset} (or the symbol {&}) for boards of such type {#1404,byte}; one valid, another not.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    BYTE my_board[99];
    offset_data;
BEGIN
    // Correct example
    offset_data=offset my_board;

    // Erroneous example
    offset_data=offset my_board[1];
END
{-}

{/}

It is also applicable to {strings of text} (data like {#1406,string}),
it means, it is not possible to obtain the direccion of a character inside of the string.

Then, the operator {#1085,offset} is not necessary to obtain the
dislocation of a string of text (can be omitted).
It means, that this two statements would be valid:

  offset_string{=}offset my_string{;}ú
  offset_string{=}mi_string{;}

{Note:} To operate with the strings of text one has to use the functions
of the language which were written with such goal (see for example
{#202,strcpy()}).

{/}See: {#1000,syntax} - {#1085,offset}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.633,Assignation to incorrect string}

With strings of text you can only realize assignations of three types:

- Convencional assignations (=), will be done a copy of the string.

- Sum and assignation (+=), will be added the substring.

- Subtraction and assignation (-=), will be undone characters of the string.

In the signed position of the program probably was intented to use one other type of
operative assignation with one {string of text}. This operation is impossible, because there is no sense.

{/}See: {#1000,syntax} - {#1035,Definition of expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.635,string of text is too long}

To define a string of text indicating in brackets its length
one must use a whole number {less than 1048576}, remembering
that all strings begin in the position zero and finish in the position which indicates the index.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRING string1[29999999]; // Error: string of text is too long.
BEGIN
    //...
END
{-}

The compiler detected a string of text with too long length, as {string1}; as maximum could be declared a string of text of 1 Megabyte, with such declaration:
  {STRING} string1{[}1048575{];}

It can contain {string1} to {1024*1024} characters, from string1[0] to string1[1048575].

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.636,Incorrect initiation}

The number of values indicated in the initiation does not coincide with the previous declaration of the structure.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT my_structure[9];
        STRING name;
        x,y;
    END = 10 dup ("AAA",0); // Error: Incorrect initiation.
BEGIN
    //...
END
{-}

In the last example declares a structure of three fields, and then initiates if it had had only two.

You must check the previous declaration, always remembering that a
structure as {my_structure[9]} has {10} registers (from {0} to {9}). For example,
the valid initiation for the structure would be:

  10 {dup (}"AAA"{,} 0{,} 0{);}

Seeing that initiate {10 registres} from {3  field}, do not forget the declaration
my_structure}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.637,Waiting [;]}

The compiler waits one {#1068,point and conma (;)} in the position indicated in the program.

In the language you must indicate the end of a declaration of a data with one point and comma.

{/}See: {#1000,syntax} - {#1068, ; }

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.638,Waiting an option of compilation}

The compiler was waiting an option of compilation in the indicated position of the program.

See the {#1400,options of compilation} disposed in this version of language.

{/}See: {#1000,syntax} - {#1003,Headline of program}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.639,Waiting [=]}

To establish a maximum number of processes you must use the statement
{#1400,compiler_options} as it is shown in this program:

{#9999,Example:}
COMPILER_OPTIONS _max_process = 100;

PROGRAM my_game;
BEGIN
    //...
END
{-}

In this case was established that during the execution of the program can 
exist { a maximum of 100 processes} executing simultaneously.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.640,Assignation inside of one condition}

The compiler detected, in the fly out position of the program, a statement of asaignation inside of one condition.

Probably was intented to compare two values using for it the assignation symbol {#1073,=}, 
instead of the symbol of comparison {#1074,==}.

{/}

{Note for new users:} If you want to {compare} two values with the symbol{=},
you must include in the program the option {#1400,_simple_conditions}.
For it you must put in the first line (before {PROGRAM ...}) this statement:

  {COMPILER_OPTIONS _simple_conditions;}

{/}

{Note for users of the previous version:} In this new version of the language
are prohibited the {assignations inside of one condition}, to simplify
the programation for new users. But it can be changed with
the options of compilation (see {#1400,_extended_conditions and _simple_conditions}).

{/}See: {#1000,syntax} - {#1400,Compiler_options}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.641,The length does not coincide with the previous declaration}

Was declared {twice} a string of text or pointer, as parameter and as
private data, and in each declarations were specified the different length.

It is not necessary to return to declare this data as private, because you can
specify its length in the same parameters of the process.

{#9999,Example:}
PROGRAM name_of_program;
BEGIN
  //...
END

PROCESS my_process(string my_string[16])
BEGIN
  //...
END
{-}

The process of this example receives a parameter in one {private} string (but
does not indicate in this seccion) to {17} characters of length (from
my_string[0] to my_string[16]).

The previous process can return to declare this string in the seccion
{#1008,PRIVATE} (for example, to add a explanatory commentary), but in this case you must
coincide the previous specified length. So,{my_string} will be declared as it is shown.

{#9999,Example:}
PROGRAM name_of_program;
BEGIN
  //...
END

PROCESS my_process(string my_string[16])

PRIVATE
  string my_string[16]; // Here I will receive a text.

BEGIN
  //...
END
{-}

{/}See: {#1000,syntax} - {#1008,Declaration of private data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.642,Waiting a name}

To define a board of bytes you must specify its name after the reserved word {BYTE}.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    BYTE my_byte;
    BYTE my_board1[127];
    BYTE my_board2[255,255];
BEGIN
    //...
END
{-}

In this example were defined three data of this type. The first this the name
{my_byte} can contain the only value (between 0 and 255), the second
with name {my_board1} can contain to 128 from this values
(from my_board1[0] to my_board1[127]), and the third, which is a board
of bytes of two dimensions, can contain totaly 65536 values
(because it is the multiplicated result 256 by 256).

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.643,Value of BYTE out of rank (0...255)}

Was initiated a {BYTE} with a value too big or negative. This
type of data can contain values only inside the rank {0} ...
{255}.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    BYTE mi_value=300; // Error: Value of byte out of rank (0...255).
BEGIN
    //...
END
{-}

If you want to assign this value to the data, you must not declare the data of this type {BYTE}, as it is shown in this program.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    my_value=300;
BEGIN
    //...
END
{-}

As this form creates a data which can contain the whole numerable value
inside the rank ({#1177,min_int} ... {#1178,max_int}).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.644,Value of word out of rank (0...65535)}

Was initiated a {WORD} with a value too big or negative. This
type of data can contain values only inside the rank {0} ...
{65535}.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    WORD my_value=70000; // Error: Value of word out of rank (0...65535).
BEGIN
    //...
END
{-}

If you want to assign this value to the data, you must not declare the data of this type {BYTE}, as it is shown in this program.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    my_value=70000;
BEGIN
    //...
END
{-}

As this form creates a data which can contain the whole numerable value
inside the rank ({#1177,min_int} ... {#1178,max_int}).


{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.645,Waiting a name}

To define a board of bytes you must specify its name after the reserved word {WORD}.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    WORD my_word;
    WORD my_board1[127];
    WORD my_board2[255,255];
BEGIN
    //...
END
{-}

In this example were defined three data of this type. The first this the name
{my_word} can contain the only value (between 0 and 65535), the second
with name {my_board1} can contain to 128 from this values
(from my_board1[0] to my_board1[127]), and the third, which is a board
of bytes of two dimensions, can contain totaly 65536 values
(because it is the multiplicated result 256 by 256).

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.646,Can not specify a board as parameter}

The {#1018,parameters of the process} must be declared as variables,
not as boards or structures, and can not be initiated (because will receive its value with each call).

{#9999,Example:}
PROGRAM my_game;
BEGIN
    //...
END
PROCESS my_process(a[9]) // Error: Can not specify a board as parameter.
BEGIN
    //...
END
{-}

The compiler interprets that sees the parameter {a} as
a board of 10 positions, and can not pass a board as parameter, emits the error.

{/}See: {#1000,syntax} - {#1018,Parameters of a process}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.647,statement IMPORT is incorrect (see corresponding help)}

The declaration of external libraries must be done {behind the headline
of the program}, it means, after the declaration {PROGRAM name_of_program;}.
Can be done in turn different declarations {#1014,IMPORT} to declare
the use of more than one library, as it is in this example.

{#9999,Example:}
// Headline of the program

PROGRAM my_game;

// Declaration of libraries

IMPORT "lib1.dll";
IMPORT "lib2.dll";
//...

// And in continuation (optional) the rest of seccions.

CONST
   //...
GLOBAL
   //...
LOCAL
   //...
PRIVATE
   //...

BEGIN
    //...
END
{-}

This program declares the use of the denominated libraries {lib1.dll} and
{lib2.dll} (supposed names of hypotetical libraries with external functions).

{/}

{Note 1:} In the first version of the language of program DIV, this
declaration must be done between seccions {LOCAL} and {PRIVATE} of the
program.

{Note 2:} The libraries prepared for the first version of the language {will not
function correctly} in new versions, before it is necessary first re-compile
this libraries with new archives of declarations. It means,
that the font code of the libraries will be valid, but before it must be re-compiled
with new archives of the headline (because they contain
the declarations of the new data and structures which exist in the language).

{/}See: {#1000,syntax} - {#1014,Declaration of libraries}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.648,Waiting a name}

To declare a pointer you must specify its name after the reserved word {#1405,POINTER} (or the symbol {*}).

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    POINTER ptr;
    WORD POINTER my_words[15];
    BYTE POINTER my_bytes;
BEGIN
    //...
END
{-}

In this example were defined three data of this type. The first
with the name {ptr} is a pointer to whole conventional data, and it has not
any limitation of rank in its access (you can acceed to ptr[{n}]
{n} of any value). The second is the pointer of the data of {WORD} type
(whole between 0 and 65535) with one limitation of access to the first 16
values. And the third is a pointer of a data of {BYTE} type (whole between
0 and 255) and without limitation of rank.

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.649,Waiting a name}

To declare a data you must specify its name after the reserved word {INT}, but in this case it is not so important
(because all the data by default are of the same type).

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    INT a,b;  // declare two whole data
    c,d;      // declare another two whole data
BEGIN
    //...
END
{-}

In this example you can see 4 data of the whole type to be declared, for
the first two ({a} and {b}) were specified that the type would be {INT} (from
"integer"), but there is no difference, 
in the level of declaration, with the last two ({c} and {d}), 
because these would be too the data of the whole type.

{/}See: {#1000,syntax} - {#1001,Names}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.650,Incorrect declaration of the pointer to one structure}

The compiler was waiting, in the indicated position of the program, the name
of one structure declared before, to have the possibility to declare to it a pointer.

To define a pointer to a structure of data you must use such syntax:

{STRUCT POINTER name_structure name_pointer;}

Being {name_structure} the name of a structure of data declared
in previous position of the program, and {name_pointer} name of the pointer
to the structure which is declaring.

{/}See: {#1000,syntax} - {#1001,Names} - {#1012,Declaration Structures}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.651,Can not receive a structure as parameter}

A process can not receive a structure as parameter, if it wants to
acceed from one process to an external structure, it must receive as
parameter a pointer to itself.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT positions[9]
        x, y;
    END
BEGIN
    my_process(OFFSET positions);
    //...
END

PROCESS my_process(STRUCT POINTER positions pos[9]);
BEGIN
    //pos[ ... ].x = ... ;
    //...
END
{-}

In this example you can acceed to the structure inside the {my_process}
using the pointer {pos}, if it had been the proper structure {positions}.

{/}See: {#1000,syntax} - {#1001,Names} - {#1012,Declaration Structures}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.652,Waiting a name of structure}

The indicated function requires as parameter, in the indicated position, the name
of a structure of data of the program.

You have not to use the operator {#1085,offset}, you must only indicate the name of the structure.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT records[9]
        STRING initials[2];
        points;
    END
BEGIN
    //...
    qsort(offset records,points,1); // Error: Waiting a name.
END
{-}

In this example is used the function {qsort}, which requires the name of a
structure as the first parameter. In this case, the corresponding instruction 
to order the board{records} is this one:

  qsort(records,points,1);

This instruction indicates how to order this structure, in function
of the field {points} and in descending order.

{/}

{Note 1:} Also it is possible that the indicated name has nothing to do with a
structure of data, but with the other type of object (for example, was 
specified the name of on a board of data).

{Note 2:} This structure of data can not belong at the same time to other
structure, so, you can not specify the name of a structure inside the other one.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.653,Waiting a field of structure}


The indicated function requires as parameter, in the indicated position, the name
of {a field pertinent to the structure indicated before}.

You have not to use the operator {#1085,offset}, you must only indicate the name of the field.


{#9999,Example:}
PROGRAM my_game;
GLOBAL
    STRUCT records[9]
        STRING initials[2];
        points;
    END
BEGIN
    //...
    qsort(records,&points,1); // Error: Waiting a field of structure.
END
{-}

In this example is used the function {qsort}, which requires the name of a field
of the structure as second parameter. In this case, the instruction to order the board (records)will:

  qsort(records,points,1);

This instruction indicates how to order this structure, in function
of the field {points} and in descending order.


{/}

{Note:}  Also it is possible that the indicated name has nothing to do with a
structure of data.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
# Temas de interes relacionados with los errores de compilacion
# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1000,syntax of a program}

In continuation is shown in the language the general structure of a program; 
press with mouse on the intersting for you section to see the corresponding syntactic definition.

{#1400,<Options of compilation>}ú
{#1003,<Headline of the program>}ú
{#1014,<Declaration of libraries>}ú
{#1004,<Declaration of constants>}ú
{#1006,<Declaration of global data>}ú
{#1007,<Declaration of local data>}ú
{#1008,<Declaration of private data>}ú
{#1015,<Main code>}ú
{#1016,<Declaration of processes>}ú
{#1408,<Declaration of functions>}ú

All programs must respect the previous structure with one
exception, and the {#1002,explaining commentaries} can be put in each point of the program.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1001,Definition of name}

A name is a sequence of alfanumeral characters which uses to
{identify} an object of the program, it can be name of a
process, of one {#1004,constant} or of one variable.

This names can be formed by following characters:

  Symbols:ú
  {_#¦§$}ú
  Digits:ú
  {0123456789}ú
  Letters:ú
  {abcdefghijklmnopqrstuvwxyz}ú
  Letters (extended):ú
  {¤¡o£}ú

always when are respected the following rules to make new names:

- The sequence of characters can not contain characters which are not in the previous relation
(except the letters {capital} corresponding to a small ones of the list).

- Inside the sequence can not be white spaces, it means,
such name {nave enemiga}is invalid, so the compiler
sees two names; in this case you declare the name as {nave_enemiga}.

- A name can not begin with the numeral digit, it means,
{0a} is invalid name. But after the first character,
in the valid name can be included all necessary digits ({a0}.

- The name can not coincide with any of the reserved words
of the language not with any of the objects (constants, variables, etc.)
predefined in the language. To check it, see the list of reserved words
and predifined objects, acceeding to the glossary in any moment.
The reserved words appear in capital letters and predifined objects in the small ones.

- There is no difference between capital and small letters ({ABc} and {abC}
for the compiler it is the same name).

- Can not use the same name for two different objects,
for example, it is impossible to name a constant {value} and, then, declare
one process as {PROCESS value(x, y);}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1002,Definition of commentaries}

A commentary is an explanatory note about the program. The commentaries are not
necessary to the correct functioning of the program.

There are two types of the commentaries:

- of one line, they begin with the symbol{ //} and finish in the end of the line in which they define.

- of many lines, they begin with the symbol{ /*} and finish with the symbol {*/}.

{#9999,Example:}
/*
    This is the example of a commentary
    of many lines, in which we realize 
    explanations about the program
*/

PROGRAM my_game; // Example of a commentary of one line.
BEGIN             // Begins the main program.
    FRAME;
END               // Finishes the main program.
{-}

All texts included in one commentary are ignored by the compiler.
There can be so many commentaries in the program as it is necessary
in any point of the program.

The commentaries which begin with{ /*} and finish with{ */} (denominated of many lines) 
can also begin and finish in the same line.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1003,Headline of the program}

{PROGRAM} {#1001,<name>} {;}

All the programs must begin with the reserved word {PROGRAM} followed by program name and the symbol{#1068,; (point and comma)}. 
This headline is obligatory in all programs (before it can only appear the ({#1400,options of compilation}).

In the names and reserved words there are no difference between capital and small
letters, therefore are valid {PROGRAM}, {program}, {Program}, ...

{#9999,Example:}
// -------------------
// List of my game
// -------------------

PROGRAM name_of_my_game;
BEGIN
    //...
END
{-}

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1004,Declaration of constants}

{CONST}ú
    {#1001,<name>} {=} {#1005,<constant>} {;}ú
    ...

This section of the program is optional, so its function is to establish
series of synonyms for numerical values.

For example, if in one game is established in one or various points of the program
the number 3 as maximum of lifes of the starring, when you want
to modify it to increase or decrease, you must look for and
substitute this number in the program. But there is a risk to
substitute another '3' what will appear in the program with other goals.

One alternative is declare one denominated constant, for example,
{maximum_lifes} as a synonym of numerical value 3 and use in the
program this constant in the place of this number; now, when you want 
to change this value, you have only to do it in the declaration
of the constant {maximum_lifes}.

This section establish a relation of names which will
represent a series of numerical constants.

This section obligatory must begin with reserved word {CONST}
and, in continuation, for each declared constant must appear its name
followed by the symbol {#1073,= (symbol of assignation)} and an expression of constant
(numerical value). After the declaration of each constant must be the symbol
{#1068,;} (point and comma).

{#9999,Example:}
PROGRAM my_game;
CONST
    maximum_lifes=3;
BEGIN
    //...
END
{-}

As was assigned a value of one constant, it can not latter be
modified in the program.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1005,Definition of a constant}

A constant is a value or a numerical constant expression.

As values can be used only whole numbers inside the rank ({#1177,min_int} ... {#1178,max_int}).

The numerical constants expressions are mathematical formulas in which you can use:

    - {Constants} definided before.ú
    - {Numerical values}.ú
    - {Operators} arithmatical or logical.ú
    - {Literal} (texts in invertal commas).ú
    - The function {#1094,sizeof()}.ú

These expressions will be evaluated when the program will be compiled and its result will be used in the execution of the program.

The {operators}, which can be used, are in a constant expression (in
parenthesis are shown the synonymous of the operator, if there are).

    {#1056, +}    Sumú
    {#1060, -}    Subtraction (or negation of sign)ú
    {#1054, *}    Multiplicationú
    {#1065, /}    Divisionú
    {#1048, MOD}  Modul ({#1048,%})ú
    {#1070, <<}   Rotation to the rightú
    {#1077, >>}   Rotation to the leftú
    {#1045, NOT}  Binary and logical negation({!})ú
    {#1051, AND}  AND binary and logical ({&},{&&})ú
    {#1083, OR}   OR binary and logical ({|},{||})ú
    {#1082, XOR}  OR exclusive ({^^})ú
    {#1074, ==}   Comparasonú
    {#1046, <>}   Distinct ({!=})ú
    {#1076, >}    Moreú
    {#1075, >=}   More or equal ({=>})ú
    {#1069, <}    Lessú
    {#1072, <=}   Less or equal ({=<})ú
    {#1085, OFFSET} Direccion or dislocation ({&})ú
    {#1053, ( )}  Parenthesisú

In continuation will be shown some examples of valid constants:

{ 0}ú
{ -1000}ú
{ 2+2}ú
{ "Hi!"}ú
{ 4*(2+1)}ú
 ...

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1006,Declaration of global data}

{GLOBAL}ú
    {#1009,<declaration of data>} {#1068,;}ú
    ...

This section of the programs is optional; here are declared the
global data, it means, the {data which can be used
from each point of the program}.

The section obligatory must begin with the reserved word GLOBAL
followed by a series of {#1009,declarations of data} finished with the
symbol {#1068,;} (point and comma).

In general, are declared as global data all these which establish
general conditions of the game which affect different processes; one example
can be two points obtained by the player, which could accumulate in the
different global {puntuation}, such way when any process of the game could
increment it in the necessary moment.

A declaration of global data will define only one data which could be used
by all processes of the program; in change a declaration of local data
will define a data of this type and with this name for each process of the program.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    punctuation=0;
BEGIN
    //...
END
{-}

{/}See: {#1000,syntax} - {#1009,Declaration of a data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1007,Declaration of local data}

{LOCAL}ú
    {#1009,<declaration of data>} {#1068,;}ú
    ...

This section of the program is optional, because the data are declared in the local field
it means, the {data which will have all processes of the
program}, each one with its own value (as the local
predefined variables {#1123,x} and {#1124,y} will determine the coordinates of all processes).

The section obligatory must begin with the reserved word LOCAL
followed by a series of {#1009,declarations of data} finished with the
symbol {#1068,;} (point and comma).

In general, are declared as local data which are considered
to have important information about the processes, which can be interested in
consulting or modifying from other processes.

An example could be the energy which has any process (can be 
a ship, a shot, the protagonist, etc.); this information can accumulate
in one local variable {energy} such way when each process can
acceed or modify the energy of others (for example, when collides with them it will lose the energy).

{#9999,Example:}
PROGRAM my_game;
LOCAL
    energy=0;
BEGIN
    //...
END
{-}

If a data declared as local will be used only inside one
process, then we can define it as a private data (inside one section
{#1008,PRIVATE} of this process).

{/}See: {#1000,syntax} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1008,Declaration of private data}

{PRIVATE}ú
    {#1009,<declaration of data>} {#1068,;}ú
    ...

This sections of the programs are optional; here the data can be declared
in private shpere, it means, {data which will be used exclusively 
inside one process}.

This section defines just before the {#1086,BEGIN} of the process which will use this data
and must begin, obligatory, with the  reserved word PRIVATE
followed by series of {#1009,declarations of data} finished with the
symbol {#1068,;} (point and comma).

The main program also consideres as a process, with the
declaration of private data just before the {#1086,BEGIN} of itself.

In general, all of them are declared as private data which will contain
necessary information only for this process and, equally, won`t be acceeded
from any other process.

Typically are defined as private data that variables which will be used
as counters in a loop, the variables to contain secondary identification codes, etc.

{#9999,Example:}
PROGRAM my_game;
PRIVATE
    n;
BEGIN
    FROM n=0 To 9;
        //...
    END
    //...
END

PROCESS my_process()
PRIVATE
    id2;
    angle2;
BEGIN
    id2=get_id(TYPE my_process);
    IF (id2<>0)
        angle2=id2.angle;
        //...
    END
    //...
END
{-}

If a data declared as private needs the consulting or modification from
another process (identifier.data), then it will be necessary to declare this data
as local (inside the section {#1007,LOCAL} of the program); this way,
all processes will have the data, so each one can acceed each other to its value
or the value which has named data in other process.

{/}See: {#1000,syntax} - {#1009,Declaration of a data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1009,Declaration of a data}

In declaration of data can be manifested three different types of objects:

  {#1010,<Declaration of variable>}ú
  {#1011,<Declaration of board>}ú
  {#1012,<Declaration of structure>}ú

In general, a variable will accumulate a simple numerical value, a
list of numerical values, while a structure will accumulate a list of registers of various
fields (as a list of files with different information).

All data are declared with its proper name which beginning with this moment
will be the way to acceed or modify the information which contains this data.

{/}

{Note:} In this version of language were incluided different {#1401,types of data}, 
while are still valid the declarations of data from the previous version.

{/}

Each data will belong to the defined shpere, by its declaration inside the
section {#1006,GLOBAL}, {#1007,LOCAL} or {#1008,PRIVATE}..

  {#1006,<Declaration of global data>}ú
  {#1007,<Declaration of local data>}ú
  {#1008,<Declaration of private data>}ú

To the global data one can acceed from each point of the
program; the local are those which have all processes
(each process has there its own value) while the private data belong to only one determined process.

{/}See: {#1000,syntax} - {#1401,Types of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1010,Declaration of one variable}

{#1401,<type>} {#1001,<name>}

(or if you want to initiate)

{#1401,<type>} {#1001,<name>} {#1073,=} {#1005,<constant>}

Can be declared different numericals of different types, in any section of declaration {#1006,GLOBAL}, {#1007,LOCAL} or {#1008,PRIVATE}.
To declare a variable you must indicate the type ({#1402,INT}, {#1403,WORD} or {#1404,BYTE}) following with
name of the variable and, if it wants to initiate, a symbol of assignation
({#1073,=}) preceeding the value of the variable.

{/}

{Types of variables:}

{#1402,INT} - External numerical variables between -2147483648 and +2147483647 ({#1177,min_int} ... {#1178,max_int}).
The reserved word {INT} can be omited, because all the data will be of this type by default
(whole of 32 bit with sign).

{#1403,WORD} - Whole numerical variables between 0 and 65535 (whole of 16 bit without sign).

{#1404,BYTE} - Whole numerical variables between 0 and 255 (whole of 8 bit without sign).

{#1405,POINTER} - Pointer to different types of data.

{Note:} The strings of text (data of the type {#1406,STRING} are considered boards
of data (of characteres), in the place of simple variables (see the {#1011,declaration of a board}).

{/}

{Examples of declaration of variables:}

{My_data=-1;} -  Variable type INT, initiated to -1.

{INT a=0,b;} - Two variables type INT, initiated to 0.

{WORD conta=10;} - Variable type WORD, initiated to 10.

{BYTE b1,b2=32;} - Variables type BYTE, b1 to 0 and b2 to 32.

{/}

{Final considerations:}

{1.} If the type of variable is not indicated, it will be INT.ú
{2.} If it is not indicated the value of variable, will be initiated to 0.ú
{3.} After each declaration you must pur the symbols of point and comma.ú
{4.} Different names of data ( of the same type) can be separated by commas.ú

{Note:} Will be valid the declarations of data which were initiated in the first
version of the language (without indicating any type). In this case, all variables will be of type {#1402,INT}.

{/}See: {#1000,syntax} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1011,Declaration of board}

{#1401,<type>} {#1001,<name>} {#1079,[} {#1005,<constant>} {#1079,]}

(or if you want to initiate the board)

{#1401,<type>} {#1001,<name>} {#1079,[} {#1005,<constant>} {#1079,]} {#1073,=} {#1013,<list of constants>}

(or if it will be initiated without defining its length)

{#1401,<type>} {#1001,<name>} {#1079,[} {#1079,]} {#1073,=} {#1013,<list of constants>}

Also can be declared boards of different types and in any section ({#1006,GLOBAL}, {#1007,LOCAL} or {#1008,PRIVATE}).
To declare a board must be indicates the type ({#1402,INT}, {#1403,WORD}, {#1404,BYTE} or {#1406,STRING}) the name,
the length in brackets ((symbols {#1079,[} {#1079,]})) and, if you want initiate it, a symbol of
assignation ({#1073,=}) preceeding to the {#1013,list of constants}.

{/}

{Note:} The length of the board expresses as the maximum value of its index, it means,
all the boards go from {position 0} to a {position indicated in brackets}. For
example, a board declared as {my_board[9]}, will be a board of {length 10} (of 10
positions, from my_board[0] to my_board[9]).

{/}

{Different examples of declaration of boards:}

{Myboard[3];} - board INT of 4 elements (from Myboard[0] to Myboard[3]).

{INT tab[]=1,2,3,4,5;} - board INT of 5 elementes (from tab[0] to tab[4]).

{WoRD tword[1];} - board WORD of 2 elementes.

{BYTE tbyte[3]=11,22;} - board BYTE of 4 elementes (initiated to 11,22,0,0).

{STRING p;} - string of text to 256 characteres (initiated to "").

{STRING q[32]= "hola";} - string of text to 33 characteres (initiated to "hola").

{/}

{considerations about boards:}

{1.} If it is not indicated the type of a board, it will be of type {#1402,INT}.ú
{2.} If it is initiated the board (with a {#1013,list of constants}), can be omited the length in brackets.ú
{3.} After each declaration you must put point and comma.ú
{4.} If the length of the board of type {#1406,STRING} is not defined, it will be of{256 elementes}
(from {[0]} to {[255]}).ú
{5.} If is not defined the list of constants, the elements will be {initiated to 0}.ú

It is permited to acceed to {element 0} only with the name of the board, as it had been
a variable; it means, for the compiler {my_board[0]} will be the same as {my_board}.

{Note:} Will not be possible to obtain the {#1085,OFFSET} of an element of a board {#1404,BYTE}, {#1403,WORD} or
{#1406,STRING} (as {OFFSET tbyte[1]}), to acceed to this element externally you need to use 
such data as {#1405,POINTER}.

{/}

{The multidimensional boards.}

Can be declared boards {#1402,INT}, {#1403,WORD} or {#1404,BYTE} of {1, 2 or 3 dimensions}. As
its declaration so the access to them must be done {separating the
dimensions with commas}. For example, this declaration:

 {BYTE board[255,255];}

Will be defined the board of such type {#1404,BYTE} (for all its elements) of {2 dimensions}, with the
total of 65536 elements (256*256).

{Note:} The board as {#1403,WORD} and {#1404,BYTE} can significate an important saving of memory,
respect to the boards as {#1402,INT} (occupy 2 and 4 times less, respectively). But
{will be more fast the operations with data of such type} {#1402,INT}.

{/}See: {#1000,syntax} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1012,Declaration of structure}

{STRUCT} {#1001,<name>} {#1079,[} {#1005,<constant>} {#1079,]}ú
    {#1009,<declaration of data>} {#1068,;}ú
    ...ú
{#1091,END}

(or if the structure initiates)

{STRUCT} {#1001,<name>} {#1079,[} {#1005,<constant>} {#1079,]}ú
    {#1009,<declaration of data>} {#1068,;}ú
    ...ú
{#1091,END} {#1073,=} {#1013,<list of constants>}

To declare a structure inside one section {#1006,GLOBAL},
{#1007,LOCAL} or {#1008,PRIVATE} you must put the reserved word {STRUCT}
preceeding to its name; after it in brackets, (symbols {#1079,[ ]})
you must indicate the {number of registres} of the structure.

After the headline will be declared all data which belong to the structure, which
will conform its fields. And finally, to finish the declaration must appear
the reserved word {END}.

In continuation it is shown an example of structure:

{STRUCT enemy[9]}ú
{    INT energy;}ú
{    WORD x_initial,y_initial;}ú
{    WORD x_final,y_final;}ú
{    STRING name[15];}ú
{END}ú

As with the boards, the {number of registers} is expressed as the {maximum number of
register} of the structure, it means, all structures have from
0 register to the indicated one in the brackets (for example, the previous declaration
defines a structure of {10 registers}).

It is permited to acceed to the {resgister 0} of the structure only with the name of the
structure, it means, that for the compiler {enemy[0].y_final} will be the same as {enemy.y_final}.

{Note:} Each field of the structure can be a variable or board (of any type,
see the {#1401,types of data}) and other complete structure, with its different registers
and fields.

{/}

{Initiation of the structure.}

If you want to initiate the structure (fix the initial values of its fields in the
different registers), you must put the symbol {#1073,=} (assignation) after the 
reserved word {END} followed by the list of values.

If the structure does not initiated, all the fields will be put in 0 by 
default. For example, if is made such declaration:

{STRUCT a[2]}ú
{    b;}ú
{    c[1];}ú
{END = 1,2,3,4,5,6,7,8,9;}ú

First you must remember that the structure {a[]} has {3 registers} (from {a[0]}
to {a[2]}) and in each register are {3 fields} (b,c[0] and c[1]), then the previous declaration
will initiate the structure this way:

  {a[0].b=1;}ú
  {a[0].c[0]=2;}ú
  {a[0].c[1]=3;}ú
  {a[1].b=4;}ú
  {a[1].c[0]=5;}ú
 { ...}ú

{/}

{Global initiation of the fields.}

If you want all registers of the structure to have initially the same values
for each field, the structure can be initiated globally.

{STRUCT a[2]}ú
{    b=1;}ú
{    c[1]=2,3;}ú
{END}ú

In the previous example, all registers of the structure have initiated
the field {b} to {1}, {c[0]} to {2} and {c[1]} to {3}.

{/}

{Note:} See the {#1407,adjusting of the data in memory}, where is shown the occupation of memory of different types of data.

{/}See: {#1000,syntax} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1013,Definition of a list of constants}

A constant is a value or a numerical constant
expression (see {#1005,<definition of constant>}).

The lists of constants are basically a series of constants
separated by {#1059,commas (,)} and are used to initiate the values of boards or structures.

An example of a list of constants could be this one:

1, 2, 3, 4, 5;

But, more then this basically form of definition, is permited the use
of the operator {#1089,DUP} to repeat a determined number of
times a series of constants. For example this list:

0, 100 DUP (1, 2, 3), 0;

This is the list of 302 constants (0, 1, 2, 3, 1, 2, 3, ..., 1, 2, 3, 0), it means,
that the operator {#1089,DUP} (from duplicate) permits repeat the sequence which
appears after l, in parenthesis, the number if indicated times.

It is possible to see the operations {#1089,DUP}, for example in such list:

2 {DUP} (88, 3 DUP (0, 1), 99);

equivalent to:

88, 0, 1, 0, 1, 0, 1, 99, 88, 0, 1, 0, 1, 0, 1, 99;

Also it is permited the omition of the operator {#1089,DUP}, this 
{2 DUP (0, 1)} is equivalent to {2(0, 1)}.

The operator DUP is usefull especcially to initiate the
structures; if , for example, you want to initiate this
structure of 100 registers:

{STRUCT a[99]}ú
    {b;}ú
    {c[9];}ú
    {d[9];}ú
{END}

With the fields {b} initiated to {0}, the fields {c[9]} to {1} and the
fields {d[9]} to {2}, will be used this list of initiation:

100 {#1089,DUP} (0, 10 DUP(1), 10 DUP(2));

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1014,Declaration of libraries}

{IMPORT} {<name of archive>}

The creation of libraries of functions for the language is {very advanced} topic,
it is usefull only for the programers with big experience in the language {C} and/or {Ensamblador}.

The libraries are distributed with two archives: one, with extention {DLL} with the library inside
and another one with the same name with has the extension {TXT} which
must be the archive of text, with the explication of propose
and functions of the library; also there must be explications of proportional
functions and the process of installation and use of the library.

>From the languages must be imported the libraries putting the reserved word
{IMPORT} (after the headline of the program) followed by the route of access to the
archive {DLL}. If the archive with the extention {DLL} was copied to the
directory of {DIV Games Studio} so it is necessary to specify the route of the library.

{#9999,Example:}
PROGRAM my_game;

IMPORT "c:\tmp\3dtrans.dll";

CONST
  //...
GLOBAL
  //...
LOCAL
  //...
PRIVATE
  //...

BEGIN
    //...
END
{-}

>From the moment in each of the libraries of functions can be developed
in free way, {can not guarantee the correct functioning of DIV Games
Studio when are used external DLL libraries}. Can be normal the incorrect
functioning of the {sketcher of programs} when in the game is loading
a DLL which modifies vital parts of the library of functions or
of the manager of processes of DIV Games Studio.

{/}

{Note 1:} In the first version of the language of program DIV, this
declaration had to be done between the {LOCAL} and {PRIVATE} sections of the program.

{Note 2:} The libraries prepared for the first version of the language {will not
function correct} in the later versions, you must first re-compile
this libraries with the new archives of declarations. It means,
that the font code of the libraries continue being valid, but before
must be re-compiled with new archives of the headline (because they
contain the declarations of the new data and structures which exist in the language).

{Note 3:} If you are programming expert in C and Ensambler, you can receive more
information about the creation of new libraries in the archive DLL\SOURCE\LEEME.TXT de DIV.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1015,main code}

{#1086,BEGIN}ú
    {#1017,<statement>} {;}ú
    ...ú
{#1091,END}

The main code of the program begins with the reserved word
{#1086,BEGIN}, after it can appear any number of statement,
and finish with the reserved word {#1091,END}.

This code controls the main process of the program, which is the initiation of the
program, control the loops of menu and of game, and finish the program.

{#9999,Example:}
PROGRAM my_game;

GLOBAL
    option;             // Option selected of the menu.

BEGIN                   // Beginning of the main code.

    set_mode(m640x480); // Start.
    set_fps(24, 4);
    // ...              // Loading files, sounds, etc.

    REPEAT              // Beginning main loop.

        option=0;       // Loop of control of the menu of options.
        //...           // Initiates the menu of options.
        REPEAT
            // ...
            IF (key(_enter)) option=1; END  // Select to play.
            IF (key(_esc)) option=2; END    // Select to finish.
            FRAME;
        UNTIL (option>0);

        IF (option==1)  // Was selected the option to play.

            // Initiates regions, scroll, etc.
            // Creates the processes of game.
            // Loop of control of the game, waits the end.

        END

    UNTIL (option==2);  // End of the main loop.

    let_me_alone();     // Finish all processes.

END                     // End of pricipal code.

// ...                  // Declaration of the processes of the program.
{-}

The end of execution of the main code does not mean the end of
execution of the program, it will be continued if stay working processes; if you want to force
the termination of the program when this code is finished, you can use for example this function {#129,let_me_alone()} just before
of the {#1091,END} which marks the end of main code, to undo the rest
of processes which can stay working.

Also in any point of the program you can finish its execution
with help of the function {#109,exit()} which automatically undo all processes.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1016,The blocks PROCESS}

Exist two types of blockes of code (besides the {#1015, main code}):
the blocks {PROCESS} (which will be detailed in continuation), and the blocks {#1408,FUNCTION}.

{PROCESS} {#1001,<name>} {(} {#1018,<parameters>} {)}ú
{#1008,<Declaration of private data>}ú
{#1086,BEGIN}ú
    {#1017,<statement>} {;}ú
    ...ú
{#1091,END}

A process must begin with the reserved word {PROCESS} followed with its
name and its {#1018,parameters} in brackets.
This parameters are list of data where the process will receive different values.
The paranthesis are obligatory even when the process has not parameters.

After this headline optional can go a section {#1008,PRIVATE}
where are declared data which will use only this process.

And, finally, will be specified the code for the process, which is a
secuence of sentencies between the reserved words {#1086,BEGIN} and
{#1091,END}.

A process corresponds, normally, to non type of object of the game,
it can be ship, an explosion, a shot, etc.,
and inside the code of process is using implement a loop,
inside which are fixed all necessary values of
visualization of this object (graphic, coordinates, etc.) and
then with help of statement {#1029,FRAME}, will give the order to
visualize the object with established attributes.

{#9999,Example:}
PROGRAM my_game;
PRIVATE
    id2;
BEGIN
    id2=my_process(160, 100)
    // ...
END

PROCESS my_process(x, y)
PRIVATE
    n;
BEGIN
    graph=1;
    FROM n=0 to 99;
        x=x+2;
        y=y+1;
        FRAME;
    END
END
{-}

As it is seen in this example, when is calling one process
it returns its {#1039,identification code} (which in the example stays in the
variable {#1008,PRIVATE} of the main program{id2}); if you want
to implement a process to the style of the functions of other languages,
which returns the numerical result, then must be used the
statement {#1028,RETURN(}value{)} but not the statement {#1029,FRAME}
inside the process, because it returns to the process father (so called),
returning the {#1039,identification code} of the process as value of return.

{/}See: {#1000,syntax} - {#1408,The blocks FUNCTION}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1017,Relation of statements}

A statement is an order to execute one program in the pc.
These are possible types of statements:

Statements of assignationú
    {#1019,=}ú

Statements of controlú
    {#1020,IF}ú
    {#1021,SWITCH}ú

Statements of loopsú
    {#1024,LOOP}ú
    {#1043,FROM}ú
    {#1023,REPEAT}ú
    {#1022,WHILE}ú
    {#1025,FOR}ú

Statements of ruptureú
    {#1026,BREAK}ú
    {#1027,CONTINUE}ú
    {#1028,RETURN}ú

Special statementsú
    {#1029,FRAME}ú
    {#1030,CLONE}ú
    {#1031,DEBUG}ú

Statements of callú
    {#1033,Call to a process}ú

The statements always appear as a group of statements, from no one
(which has no sense) to the necessary number.

All the statements will be executed sequencelly (the first,
the second, the third, ...) except those which define
the statements which can control the flow of the program (the
statements of control, of loops and of rupture).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1018,Parameters of a process}

The parameters of a process are, basically, a list of data from which the
process will receive different information each time when is invoked
(called or used) from other process.

The processes can receive parameters in these types of data:

- A local predefined data (as {#1123,x}, {#1128,size}, {#1127,flags}, ...).

- A local defined data inside the section {#1007,LOCAL}.

- A global defined data inside the section {#1006,GLOBAL}.

- A private data of the process declared inside the section {#1008,PRIVATE}
of the proper process.

- A private data which {is not declared} inside the section {#1008,PRIVATE}.

Understanding that in all this cases a data can belong to a variable,
to one concrete position of a board or to an element inside the structure.

To show different types of parameters,
in continuation, you will see a program with a process which receives five different parameters
of the types indicated in the previous list, respectively.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
    points=0;
LOCAL
    energy=0;
BEGIN
    my_process(1, 2, 3, 4, 5);
    // ...
END

PROCESS my_process(x, energy, points, num)
PRIVATE
    n;
BEGIN
    // ...
END
{-}

The process {my_process} receives five parameters in five variables:
local predefined, local, global, {#1008,private} declared and {#1008,private} without
declaration.

To receive in one global data a parameter (as the variable {#1006,GLOBAL}
{points}) is equivalent to realize the assignation ({points=3;}) and then
call the process.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1019,statement of assignation}

The statements of assignation sirve to calculate expressions and
{assignate them} to a data.

{#1034,<Reference to a data>} {#1073,=} {#1035,<expression>} {#1068,;}

Must be indicated the data in which will be saved the result
of the expression, followed by the symbol {#1073,=} (symbol of the {assignation})
and numerical or logical expression to be evaluated when is executing
the statement. After this statement always have to be the symbol{#1068, ;(point and comma)}.

In one statement of assignation is permited only to assign values to such objects
as variables (of any type), to a {#1011,position of a board},
or to a  {#1012,element of a structure}.

It is impossible to assign a value of {#1004,constant}, of a function
or of a process, or, in general, of any {#1035,numerical or logical expression}.

Further you will see the program with different assignations.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    x=x+1;
    angle=(angle*3)/2-pi/2;
    size=(x+y)/2;
    z=abs(x-y)*3-pow(x, 2);
    // ...
END
{-}

This is the basic form of the assignations, if exist other symbols of assignation
which, in place of assignation of a new value to the refered data, modify its value.
These are symbols of {operative assignation}:

{#1058, +=} Sums to data the result of the expressionú
        {x=2; x+=2;} -> (x==4)

{#1062, -=} Subtracts from data the result of the expressionú
        {x=4; x-=2;} -> (x==2)

{#1055, *=} Multiplies the data by the result of the expressionú
        {x=2; x*=3;} -> (x==6)

{#1066, /=} Divides the data by the result of the expressionú
        {x=8; x/=2;} -> (x==4)

{#1049, %=} Put in the data the result of division of itself between the resul
of the expressionú
        {x=3; x%=2;} -> (x==1)

{#1052, &=} Realizes an AND (binary ad/or logical) between the data and the result of the
expression and assign it as new value of the dataú
        {x=5; x&=6;} -> (x==4)

{#1084, |=} Realizes an OR (binary and/or logical) between the data and the result of the
expression and assign it as a new value of the dataú
        {x=5; x|=6;} -> (x==7)

{#1081, ^=} Realizes an exclusive OR ( XOR binary and/or logical) between the data and the result of the
expression and assign it as a new value of the dataú
        {x=5; x^=3;} -> (x==3)

{#1078, >>=} Rotates to the right the data so many times as indicates the result of the
expression (each rotation to the right is equivalent to the divide the data by 2)ú
        {x=8; x>>=2;} -> (x==2)

{#1071, <<=} Rotates to the left the data so many times as indicates the result of the
expression (each rotation to the left is equivalent to the multiply the data by 2 )ú
        {x=2; x<<=2;} -> (x==8)

Also are admited inside the category of sentencies of assignation the
{increments} and {decrements} of a data. 
For example, if we want to sum with it the local variable {x} we can do it with the help of the statement {x=x+1;}, 
with the statement {x+=1;} or with the operator of increment: {x++;} or{ ++x;}.

It means, are accepted as statements of assignation {#1057,increments ( ++ )} or
{#1061,decrements ( -- )} of a data.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1020,statement IF}

{IF} {#1053,(} {#1037,<condition>} {#1053,)}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}

(or)

{IF} {#1053,(} {#1037,<condition>} {#1053,)}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1090,ELSE}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}

The statement {IF} sirves optional to execute a block of statements,
when is fulfilled one condition. In the second example which appears higher,
will execute also other block of statements (inside the section
{#1090,ELSE}) when is fulfilled the condition {no}.

Here is shown the program with different statements {IF}.

{#9999,Example:}
PROGRAM my_game;
BEGIN

    IF (key(_esc))
        exit("Bye!", 0);
    END

    IF (x>100 AND x<220)
        y=y+4;
    ELSE
        y=y-8;
    END

    IF (size>0)
        size=size-1;
    END

    IF (timer[5]>1000)
        z=1;
    ELSE
        z=-1;
    END

    // ...
END
{-}

It is possible to accumulate statements {IF} without any limit, it means, can be put
more statements {IF} inside those part which executes when is fulfilled
the condition (part {IF}) or inside that one which will execute when the condition is not fulfilled
(part {#1090,ELSE}).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1021,statement SWITCH}

{SWITCH} {#1053,(} {#1035,<expression>} {#1053,)}ú
    {#1087,CASE} {<rank of values>} {#1067,:}ú
        {#1017,<statement>} {#1068,;}ú
        ...ú
    {#1091,END}ú
    ...ú
    {#1088,DEFAULT} {#1067,:}ú
        {#1017,<statement>} {#1068,;}ú
        ...ú
    {#1091,END}ú
{#1091,END}

A statement {SWITCH} has a series of sections {#1087,CASE} and,
optional, a section {#1088,DEFAULT}.

When is executing a statement {SWITCH}, first is evalued the expression and
then, if the result is inside the rank of contemplated values in the first
section {CASE}, will execute the statements of the same and the statement will consider finished. 
In the case of not to be, the result of the expression
of the first {#1087,CASE} will pass to check it with the second {#1087,CASE}, the third,
etc. And, finally, if exists the section {#1088,DEFAULT} and the result of the
expression was not coincided with noone of the sections {#1087,CASE},
so will execute the statements of the section {#1088,DEFAULT}.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    SWITCH (x)
        CASE 1:
            x=-1;
        END
        CASE 2:
            x=-2;
        END
        CASE 3:
            x=-3;
        END
        CASE 99:
            x=-99;
        END
        DEFAULT:
            x=0;
        END
    END
END
{-}

The statement {SWITCH} of this program will change the sign of variable {x} if
it values {1}, {2}, {3} or {99}; in the contrary case will be put a {0}.

{Rank of values of a section case}{/}

In a section case can be specified a value, a rank of values
(minimum {#1064,..} maximum), or a list of values and/or separate ranks by {#1059,commas (,)}.
For example, the previous statement can be expressed this way:

  {SWITCH (x)}ú
      {CASE 1..3, 99:}ú
          {x=-x;}ú
      {END}ú
      {DEFAULT:}ú
          {x=0;}ú
      {END}ú
  {END}ú

Once one of the sections {#1087,CASE} of a statement {SWITCH} is executed
{no more sections can be executed}, but they also specify the
result of the expression, for example, in this statement:

  {SWITCH (2+2)}ú
      {CASE 3..5:}ú
          {x=x+1;}ú
      {END}ú
      {CASE 2, 4, 6:}ú
          {y=y-1;}ú
      {END}ú
  {END}

Will be executed the section {x=x+1;} and then will be finished the statement, without
execution of the section {y=y-1;} so although the result of the evaluated expression
({4}) is contemplating in it, it is contemplating in the previous section too,
(because 4 is inside the rank 3..5).

It is not necessary to order the sections {#1087,CASE} by their values (from smaller to bigger
or from bigger to smaller), but it is necessary the section
{#1088,DEFAULT} (if it is) to be the section. There can not be more then one section {#1088,DEFAULT}.

It is possible to accumulate statements {SWITCH} without any limit, it means, we can put new
statements {SWITCH} inside of one section {#1087,CASE} (and any other type of statement).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1022,statement WHILE}

{WHILE} {#1053,(} {#1037,<condition>} {#1053,)}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}ú

The statement {WHILE} is a statement which implements a {loop}, it
means, the capacity to {repeat a group of statements a determined number of times}.

To implement this loop you must specify in parenthesis the
condition which must be fulfilled to execute the group of statements in
continuation of the reserved word {WHILE}. After specify this condition,
will put all necessary statements which repeat and, finally,
will mark the end of the loop with the reserved word {#1091,END} (It is not
important that inside the loop appear more words {#1091,END} if they
form a part of internal statements of this loop).

When a statement {WHILE} executes, will be realized the checking which is
specified and, if it is certain, will execute the previous statements;
in contrary case, the program will continue beginning with {#1091,END} which markes the end with {WHILE}.

If were executed the previous statements (what denomines to realize
an {iteration} of the loop), will return to check the condition and if it is certain once more time
will be realized another {iteration} (will return to execute
the internal statements). This process will repeat checking the
condition of {WHILE}, till the moment when it will result false.

If while a statement {WHILE} is executing, the condition results false directly,
then the internal statements will execute noone time.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    x=0;
    WHILE (x<320)
        x=x+10;
        FRAME;
    END
END
{-}

In this example will be put the local variable {x} (coordinate x of the process) to
zero and then, while x is smaller than 320, to {x} will be sumed 10 and then will give a {#1029,FRAME}.

A statement {#1026,BREAK} inside a loop {WHILE} will finish it immidiatelly,
continuing the program by the next statement to named loop.

A statement {#1027,continue} inside a loop {WHILE} will force to the program to
check immidiatelly the initial condition and if it is certain,
to return to execute the internal statements from the beginning (after the {WHILE}).
If the condition results false, the statement {#1027,continue} will finish the loop.

The internal statements to a loop {WHILE} can be of any quantity and type,
including, of course, new loops {WHILE}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1023, statement REPEAT}

{REPEAT}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1097,UNTIL} {#1053,(} {#1037,<condition>} {#1053,)}

The statement {REPEAT} (REPEAT ... UNTIL( ... )) is a statement which implements
a {loop}, it means, that is capable to {repeat a group of statements a determined number of times}.

To implement this loop it must begin with the reserved word {REPEAT},
followed by the statements which can be repeated once or more times and the end
of the statement will be determined putting the reserved word {#1097,UNTIL}
followed by the condition which must be fulfilled to {consider finished the statement}.

When a statement {REPEAT} is executing, first will execute the internal statements
(which will be between the {REPEAT} and the {#1097,UNTIL}) and, after do it,
will check the condition specified in the {#1097,UNTIL} and if continues being
false, will return to execute the internal statements. The process will repeat
untill the condition of the {#1097,UNTIL} will result certain, and will continue
the execution of the program after this statement.

Each time when are executing the internal statements is said that was realized
a {iteration} of the loop. The statement {REPEAT} ... {#1097,UNTIL} 
(which fulfills the) {<condition>}) will always
execute the internal statements at least once, because it always checks the condition after its execution.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    x=0;
    REPEAT
        x=x+10;
        FRAME;
    UNTIL (x>320)
END
{-}

In this example the local variable {x} will be put (coordinate x of the process) on
zero and then {x} will be sumed with 10 and will give a {#1029,FRAME} {untill} 
{x} will be more than 320.

A statement {#1026,BREAK} inside the loop {REPEAT} will immediately finish it
continuing the program with the next statement to a named loop.

A statement {#1027,continue} inside of a loop {REPEAT} will force to the program
to realize the checking of the {#1097,UNTIL} immediatly and if it is false
will return to execute the internal statements from the beginning (after the
reserved word {REPEAT}). If the condition results are certain, the statement
{#1027,continue} will finish the loop.

The internal statements to a loop {REPEAT} can be of any quantity and type
including of course new loops {REPEAT}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1024,statement LOOP}

{LOOP}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}

The statement {LOOP} is a statement which implements a {infinite loop},
it means, it {repeats infinately a group of statements}.

To implement this loop you must begin with the reserved word {LOOP},
followed by the statements which will be repeated continuously and the reserved word {#1091,END} in the end.

When in program is found a statement {LOOP} ... {#1091,END} since that moment will
execute once and twice, all the internal statements to this loop.

To finish a loop {LOOP} you can use the statement {#1026,BREAK}
which after execution inside the loop of this  type, will force to the program to continue
after the {#1091,END}.

Each time when are executing the internal statements it is said that was realized
a {iteration} of the loop. The statement {#1027,continue}, inside the loop,
will finish the actual {iteration} and will begin the next (the program
will continue execution after the reserved word {LOOP}.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    x=0;
    LOOP
        IF (key(_esc))
            BREAK;
        END
        x=x+1;
        FRAME;
    END
END
{-}

In this example will be put the local variable {x} (coordinate x of the process) to
zero and, then, will be sumed with 1 and than will give continuously a {#1029,FRAME}. If
you press the button escape ({ESC}) will execute the statement {#1026,BREAK},
finishing the loop {LOOP}.

The internal statements to a loop{LOOP} can be of any quantity and type
including of course the new loops {LOOP}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1025,statement FOR}

{FOR} {#1053,(}<initiation>{#1068,;} <condition>{#1068,;} <increment>{#1053,)}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}

The statement {FOR} (replica of the language C) is a statement which implements
a {loop}, it means, it has capacities to {repeat a group of statements a determined
number of times}.

To implement this loop must be specified, in parenthesis, three different parts
separated by symbols {#1068,;} (point and comma) after 
the reserved word {FOR}. This three parts are optional (can be omited) and are these:

- {Initiation}. In this part often is coded a statement of assignation
which fixes the initial value of the variable which will be used as counter of
{iterations} of the loop (to each execution of the previous group of statements
is denomined an {iteration} of the loop). An example could be the statement of
assignation {x=0}, which will fix the variable {x} to zero in the beginning of the loop (value
fot the first iteration).

- {#1037,condition}. In this part is specified a condition; just
before each iteration will be checked to be certain to continue the execution
of group of statements. If the condition is evalueted as false, the loop {FOR} will be finished, 
continuing the program after the {#1091,END} of the loop {FOR}.
An example of condition can be {x<10}, which permits  to execute the internal group
of statements only when the variable {x} is the number smaller then {10}.

- {Increment}. In the last third part is indicated the increment
of the variable used as counter by each iteration of the loop; normally
it also is expressed by the statement of assignation. For example, the
statement {x=x+1} will be sumed {1} with the variable {x} after each iteration of the loop.

After definition of the loop {FOR} with its three parts there will appear
the group of internal statements to the loop which will repeat sequencially
while is fulfilling the condition of stay (second part). After this group of
statements the reserved word {#1091,END} will determine the end of the loop {FOR}.

When in a program comes the statement {FOR} it executes first the initiation part
and checks the condition; if it is certain
will execute the group of internal statements and, then, the part of the increment,
returning to check the condition, etc. If before any iteration the
condition results false, the statement {FOR} will be finished immediately.

In continuation, will show a program with a loop {FOR} with three followed parts
in the previous sections.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FoR ( x=0 ; x<10 ; x=x+1 )
        // Here would come the internal statements.
    END
END
{-}

This loop will execute first with the variable {x} with value {0}, the second time
with value {1}, ..., and the last one with value {9}; after this iteration will
execute the part of the increment, giving {x} to value {10} and, then,
after checking the condition of stay in the loop (that {x} must be smaller
than {10}) and false result, the loop will be considered finished.

As it was mencioned, the three partes in the definition of the loop are optional;
if the three were omited:

  {FOR ( ; ; )}ú
      // ...ú
  {END}

Then, this loop is equivalent to a loop {#1024,LOOP} ... {#1091,END}.

Besides, in a loop {FOR} can be put different partes of initiation,
condition or increment separated by commas ({#1059,,}), executing all the initiations in the beginning,
then checking all conditions of stay (if any of them results false, the loop will be finished), the
internal statements and, finally, after each iteration, all increments.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FOR ( x=0, y=1000 ; x<y ; x=x+2, y=y+1 )
        // Here would come the internal statements.
    END
END
{-}

A statement {#1026,BREAK} inside the loop {FOR} will finish it 
immediately, continuing the program with the next statement to the named loop.

A statement {#1027,CONTINUE} inside the loop {FOR} will force the program to
execute directly the part of the increment and, then, will realize the checking
of stay and,if it is certain, will return to execute the internal statements
from the beginning. If the condition results certain, the statement {#1027,CONTINUE}
will finish the loop {FOR}.

A loop {FOR} is, practically, equivalent to a loop {#1022,WHILE} implemented
this way:

{#9999,Example:}
PROGRAM my_game;
BEGIN
    x=0;
    WHILE (x<10)
        // Here would come the internal statements.
        x=x+1;
    END
END
{-}

With the only exception that a statement {#1027,CONTINUE}, inside this
loop {#1022,WHILE}, will not execute the part of the increment, while in a loop {FOR}
it would do it.

If in a loop {FOR}, after execute the initiation, the condition
directly results false, will never execute the internal statements.

The internal statements to a loop {FOR} can be of any quantity and any type
including of course new loops {FOR}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1026,statement BREAK}

A statement {BREAK} inside the loop will finish it
immediately, continuing the program with the following statement to the named loop.
You can not put this statement in other places as in these loops:

  {#1022,LOOP} ... {#1091,END}ú
  {#1043,FROM} .. {#1096,TO} .. {#1095,STEP} .. ... {#1091,END}ú
  {#1023,REPEAT} ... {#1097,UNTIL} {#1053,(} .. {#1053,)}ú
  {#1024,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
  {#1025,FOR} {#1053,(} .. {#1068;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú

A {BREAK} will provoke the program to continue executing after the {#1091,END}
or {#1097,UNTIL} of the nearest loop to the statement.

In case of have different accumulated loops (one inside the other) the statement
{BREAK} will start the most internal loop.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    LOOP
        REPEAT
            IF (key(_esc)) BREAK; END
            //...
        UNTIL (x==0);
        //...
    END
END
{-}

In this example the statement {BREAK} will exit from the {#1023,REPEAT} ... {UNTIL}
(when you press {ESC}), but not from the {#1022,LOOP} ... {#1091,END}.

{Important}{/}

The statement {BREAK} is invalid to finish the statements {#1020,IF}, nor
{#1021,SWITCH} (not the sections {#1087,CASE} of this statement), nor
statements {#1030,CLONE}.

{BREAK} can only finish the statements which implement a loop.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1027, statement CONTINUE}

A statement {continue} inside the loop will force the program to
finish its current iteration and begin the next one.

Is denominated {iteration} to each execution of the group of internal statements
to a loop (the statements between a {#1022,LOOP} and its {#1091,END}, for
example).

This statement must be situated only inside these loops:

{#1022,LOOP} ... {#1091,END}ú
A continue inside this loop will jump to the LOOP.

{#1043,FROM} .. {#1096,To} .. {#1095,STEP} .. ... {#1091,END}ú
A continue inside this loop will realize the increment (STEP) and, if was not
passed the value indicated in the To, will continue the program in the beginning of the
loop.

{#1023,REPEAT} ... {#1097,UNTIL} {#1053,(}..{#1053,)}ú
A continue inside this loop will jump to the UNTIL.

{#1024,WHILE} {#1053,(} .. {#1053,)} ... {#1091,END}ú
A continue inside this loop will jump to the WHILE.

{#1025,FOR} {#1053,(} .. {#1068,;} .. {#1068,;} .. {#1053,)} ... {#1091,END}ú
A continue inside this loop will realize the increment and the comparison;
if this last results certain,will continue the program to the beginning of the loop,
if it results false the program will continue after the END of the FOR.

In the case of accumulation of different loops (ones inside others) the statement
{continue} will have the efect only in the most internal loop.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FOR (x=0, y=0;x<10;x++)
        IF (x<5) continue; END
        y++;
    END
END
{-}

In this example, after the execution of the complete loop, {x} will value  {10} and {y}
will value  {5}, so while {x} is smaller than 5 the statement {continue}
prevent the execution of the statement {y++;}.

{Important}{/}

The statement {continue} is invalid inside the statements {#1020,IF}, nor
{#1021,SWITCH} (not the sections {#1087,CASE} of this statement), nor
statements {#1030,CLONE} (because this do not implement loops and,
therefore, do not realize iterations).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1028,statement RETURN}

The statement {RETURN} finishes the current process immediatelly, as it were in the
{#1091,END} of its {#1086,BEGIN}.

The statement will finish it in the main code, but if stay the working processes,
they will continue executing. To finish a program and all its
processes you can use, for example, the function {#109,exit()}.

A {RETURN} inside the process will finish it, killing the named process.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    LOOP
        IF (key(_esc))
            RETURN;
        END
        FRAME;
    END
END
{-}

In this example, after pressing the button escape ({ESC}) executes the
statement {RETURN}, finishing the program.

{Use of RETURN to return a value}{/}

It is possible to make processes with conduct similar to the functions
of other languages of programation, which {receive a series of parameters and
return a value}. For example, a process which receives two numerical values
and returns the major of them.

For it, you must use this statement with such syntax:

{RETURN(}{#1035,<expression>}{)}

Also it is important not to use the statement {#1029,FRAME} inside the process,
it will immediatelly return to the calling process. When the compiler
finds the statement {#1029,FRAME} inside a {#1016,PROCESS} it catalogues
directly as process, refusing its possible use as function.

{Important:} To return a value with the statement {RETURN} after execution one or more
statements {#1029,FRAME}, you must make a block of this type {#1408,FUNCTION}.

{/}

In continuation is shown an example proposed before: an implementation of
the mathematical function {max} which returns the major of its two parameters.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    x=max(2, 3)+max(5, 4);
END
PROCESS max(a, b)
BEGIN
    IF (a>b)
        RETURN(a);
    ELSE
        RETURN(b);
    END
END
{-}

After execution of this program, the variable {x} of the main process will value  {8} (3+5).

{/}

{Note:} by default, if is used the statement {RETURN} without the expression
in parenthesis or the statement {#1029,FRAME} in a process, the value of return of itself
will be in its {#1039,identification code} of process.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1029,statement FRAME}

The statement {FRAME} is the key-word inside the language. The functioning
of a program is, in outline, this:

- Begins to execute the main process, which can create more
processes (objects of the player) in any point. All processes can
finish in any moment, create or undo other processes.

- The games will always visualize frame by frame.
In each frame, the system executes all the existing processes in this
moment, one by one, until each one execute the statement {FRAME}, which
will indicate this list fot the next visualization (frame).

In the preparation of each frame all processes will be executed in
of the established order (the local variable {#1121,priority} of the
processes determines this order).

Then this statement is as the order of visualization of the processes.

If the process begin to execute and does not finish, not execute this
statement, so the program will be blocked, because exists
a process which is never prepared to the next visualization; 
therefore the system will be capable to show the next frame.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    my_process();
    my_process();
    LOOP
        IF (key(_esc))
            my_second_process();
        END
        FRAME;
    END
END
PROCESS my_process()
BEGIN
    LOOP
        FRAME;
    END
END
PROCESS my_second_process()
BEGIN
    LOOP
    END
END
{-}

In this program the main process (of type {my_game}) creates another two
processes (like {my_process}); beginning with that moment the three processes
will execute continually, each till its statement {FRAME}. But if
is pressed the button escape ({ESC}), the main process will create  a new
process (like {my_second_process}) which will be in a loop {#1024,LOOP}
unlimited, without execute any {FRAME}, therefore the program
will be  interrupted (the system will advert about this situation in 
any seconds, see {#1115,max_process_time}).

Basically, all processes which correspond with objects of a game
make a loop inside of which, each frame, fix all its values
of visualization ({#1123,x}, {#1124,y}, {#1126,graph}, {#1128,size}, {#1129,angle}, ...)
and, then, execute the statement {FRAME}.

{Synchronism of processes}{/}

Is possible to use this statement with this syntax:

{FRAME(}<percentage>{)}

Put a whole percentage, from 0 to 100 or major, in parenthesis after the reserved word {FRAME}.

This percentage will indicate the precentage of the next frame completed
by the process; it means, when is not specified this percentage
it is the same if would be {FRAME(100)} (was completed the 100% of the
previous work to the next visualization by the process).

For example, if a process executes in a loop the statement {FRAME(25)},
will need to execute it {4 times} to be prepared for the next
visualization (because 4*25% is the 100%).

In the other extreme, if a process executes inside its loop the statement
{FRAME(400)}, when is executing the first time will complete yet
a 400% of the visualization, therefore, even after visualization, will continue 
to be left a 300% of completed visualization. Therefore, in the preparation
of the next {3} frames the system does not execute this process, so 
it is yet prepared for the visualization. Then this process would execute
only one of 4 frames (on the contarary to the example of the last paragraph,
which was executing 4 times for each frame of the game).
The processes will not reach the next visualization till they have 
{at least the 100%}. For example, if a process always executes statements
{FRAME(80)}, executes them twice before the first visualization what will give
the 160% (2*80%) of the completed visualization. For the next
visualization will have , therefore, a 60% pre-completed (160%-100%); therefore, in the
second visualization will only require a statement {FRAME(80)} to
visualize, because this 80%, united with the 60% from the first, will make the total
of a 140% completed, with it will be visualized  immediatelly, and even
will be left another 40% for the preparation of the next frame.

{/}

A statement {FRAME(0)}, which completes a 0% of the next visualization,
can have a sense in this two cases:

- Can be a from to force the system to execute in this point all left
processes which have the same priority as the current and after them return to execute it.

- Or can be a form of initiation of functions as {#120,get_id()} or
{#104,collision()}, so these return some determined values to
each frame; if is necessary return to obtain the values, you can
execute a statement {FRAME(0)} which these functions will interpret 
as a new frame.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1030,statement CLONE}

{CLONE}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}

This statement creates a new process similar to the current, with exeption
that the statements between the reserved words {CLONE} and {#1091,END} 
will execute only in the new process and not in the current.

For example, if any process of the program, with the determined coordinates ({#1123,x},
{#1124,y})and a concrete graphic ({#1126,graph}) , executes this statement:

  {CLONE}ú
      x=x+100;ú
  {#1091,END}

To create a new process similar to it, with th same graphic and the same
values in all its variables, with exception of the coordinate {#1123,x}, which in the new
process will have {100} points more to the right.

This statement is used to create replicas of a process, dividing it in
two processes (almost) equal.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    // ...
    x=0;
    y=0;
    CLONE
        x=x+10;
    END
    CLONE
        y=y+10;
    END
    // ...
END
{-}

In this example, the {2} statements {CLONE} will create {3} copies of the main process
(and not 2, as it was expected).

After executing the first statement {CLONE} will be created  a new process, it will be
{2}: one in (x=0, y=0) and other in (x=10, y=0). And these two
processes will execute the second statement {CLONE}, the first (the original)
creating with it a new process in (x=0, y=10), and the second will create the new
process in (x=10, y=10).

To create only {2} copies of the original process can be made, 
for example, this program:

{#9999,Example:}
PROGRAM my_game;
BEGIN
    // ...
    x=0;
    y=0;
    CLONE
        x=x+10;
        CLONE
            y=y+10;
        END
    END
    // ...
END
{-}

The original process (x=0, y=0) will create one in (x=10, y=0) and this will make another one
in (x=10, y=10), creating only two copies of the original.

Therefore you must be very attentive using the statement {CLONE}
sequencially or inside the {loop}, remember that the first
'{clones}' can create a new '{clones}'.

This statement can be used without the need to put statements between the words
{CLONE} and {#1091,END}. But at least in the beginning, it seems to have no sense
the wish to have two similar processes, with the same coordinates,
the same graphic and executing the same code.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1031,statement DEBUG}

The statement {DEBUG} will invoke the interactive debugger when it is executing.

Often is used to clean the programs, it means, to find possible
errors which have the programs. Often are situated in this points.

- Where you want to check if one part of the program made what it had to do;
after executing of this part, {DEBUG} will invoke the
debugger, here can be checked all active processes and the
value of all its variables.

- When you are not very sure what can happen in the program, you can put
this statement in named point, to receive to announcement if something succeeds.

This statement must be put only temporally untill will be localized
the suposed error; once it is found it is no more neccesary therefore it can be deleted from the
program, because for other it has no effect.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    // ...
    IF (x<0)
        DEBUG;
    END
    // ...
END
{-}

In this Example in a determined point of the program is checking, the
coordinate {x} of the process not to be negative (smaller than zero); if
it succeeds, will be invoked the debugger to investigate why it had happened.

When this statement is executing closes a dialogue window which gives us these options:

- Disable the statement {DEBUG}, if do not want it returns to activate in this execution of the
program.

- Stop the program and enter in the debugger, to examine all
proceses and its variables.

- Or immediatelly stop the execution of the program, returning to its edition
in the graphic environment of windows.

Also if you press the button escape {ESC} of the named picture, will be only
ignored the named statement {DEBUG} and will be normally continued executing the program.

{/}

When is executing a program from the graphic environment of the windows, anytime can be
invoked the debugger pressing the button {F12}.

After invoke the debugger, the program always will be interrupt
before the beginning to process a new frame, with all
processes prepared to execute before the next visualitacion.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1032,List of functions of the language}{+4,1}{-}

Functions of interaction between processesú
  {#104,collision()}ú
  {#116,get_angle()}ú
  {#117,get_dist()}ú
  {#118,get_distx()}ú
  {#119,get_disty()}ú
  {#120,get_id()}ú
  {#129,let_me_alone()}ú
  {#158,signal()}ú

Functions about geometryú
  {#101,advance()}ú
  {#113,fget_angle()}ú
  {#114,fget_dist()}ú
  {#142,near_angle()}ú
  {#183,xadvance()}ú

Functions of search of waysú
  {#185,path_find()}ú
  {#187,path_free()}ú
  {#186,path_line()}ú

Mathematical functionsú
  {#100,abs()}ú
  {#246,acos()}ú
  {#245,asin()}ú
  {#247,atan()}ú
  {#248,atan2()}ú
  {#243,cos()}ú
  {#145,pow()}ú
  {#242,sin()}ú
  {#160,sqrt()}ú
  {#244,tan()}ú

Aleatory functionsú
  {#149,rand()}ú
  {#150,rand_seed()}ú

Graphic functionsú
  {#103,clear_screen()}ú
  {#123,get_pixel()}ú
  {#135,map_block_copy()}ú
  {#136,map_get_pixel()}ú
  {#137,map_put()}ú
  {#138,map_put_pixel()}ú
  {#139,map_xput()}ú
  {#188,new_map()}ú
  {#146,put()}ú
  {#147,put_pixel()}ú
  {#148,put_screen()}ú
  {#212,screen_copy()}ú
  {#173,xput()}ú

Functions of primitive graphicsú
  {#250,delete_draw()}ú
  {#249,draw()}ú
  {#251,move_draw()}ú

Functions of audio systemú
  {#256,change_channel()}ú
  {#102,change_sound()}ú
  {#175,reset_sound()}ú
  {#178,set_volume()}ú

Functions for sound effectsú
  {#221,is_playing_sound()}ú
  {#134,load_pcm()}ú
  {#134,load_wav()}ú
  {#159,sound()}ú
  {#167,stop_sound()}ú
  {#170,unload_pcm()}ú
  {#170,unload_wav()}ú

Functions for CD musicú
  {#127,is_playing_cd()}ú
  {#144,play_cd()}ú
  {#164,stop_cd()}ú

Functions for digital musicú
  {#220,get_song_line()}ú
  {#219,get_song_pos()}ú
  {#222,is_playing_song()}ú
  {#214,load_song()}ú
  {#218,set_song_pos()}ú
  {#216,song()}ú
  {#217,stop_song()}ú
  {#215,unload_song()}ú

Functions of enterú
  {#121,get_joy_button()}ú
  {#122,get_joy_position()}ú
  {#128,key()}ú

Functions for use of the paletteú
  {#105,convert_palette()}ú
  {#110,fade()}ú
  {#111,fade_off()}ú
  {#112,fade_on()}ú
  {#264,find_color()}ú
  {#266,force_pal()}ú
  {#133,load_pal()}ú
  {#154,roll_palette()}ú
  {#179,set_color()}ú

Functions for scroll and mode 7ú
  {#140,move_scroll()}ú
  {#152,refresh_scroll()}ú
  {#162,start_mode7()}ú
  {#163,start_scroll()}ú
  {#165,stop_mode7()}ú
  {#166,stop_scroll()}ú

Functions for the mode 8ú
  {#195,get_point_m8()}ú
  {#193,get_sector_height()}ú
  {#198,get_sector_texture()}ú
  {#200,get_wall_texture()}ú
  {#191,go_to_flag()}ú
  {#189,load_wld()}ú
  {#201,set_env_color()}ú
  {#196,set_fog()}ú
  {#194,set_point_m8()}ú
  {#192,set_sector_height()}ú
  {#197,set_sector_texture()}ú
  {#199,set_wall_texture()}ú
  {#190,start_mode8()}ú
  {#182,stop_mode8()}ú

Functions for print textsú
  {#107,delete_text()}ú
  {#131,load_fnt()}ú
  {#141,move_text()}ú
  {#177,unload_fnt()}ú
  {#171,write()}ú
  {#253,write_in_map()}ú
  {#172,write_int()}ú

Functions of text stringsú
  {#184,char()}ú
  {#210,lower()}ú
  {#203,strcat()}ú
  {#206,strchr()}ú
  {#205,strcmp()}ú
  {#202,strcpy()}ú
  {#211,strdel()}ú
  {#204,strlen()}ú
  {#208,strset()}ú
  {#207,strstr()}ú
  {#209,upper()}ú

Functions of conversion of stringsú
  {#254,calculate()}ú
  {#255,itoa()}ú

Functions for animationsú
  {#108,end_fli()}ú
  {#115,frame_fli()}ú
  {#153,reset_fli()}ú
  {#161,start_fli()}ú

Functions of regions of screenú
  {#106,define_region()}ú
  {#143,out_region()}ú

Functions of information about graphicsú
  {#124,get_point()}ú
  {#125,get_real_point()}ú
  {#126,graphic_info()}ú

Functions of initiationú
  {#156,set_fps()}ú
  {#157,set_mode()}ú

Functions of loading of resourcesú
  {#132,load_fpg()}ú
  {#174,load_map()}ú
  {#174,load_pcx()}ú
  {#169,unload_fpg()}ú
  {#176,unload_map()}ú
  {#176,unload_pcx()}ú

Functions of saving the mapsú
  {#241,save_map()}ú
  {#241,save_pcx()}ú

Functions of saving the dataú
  {#130,load()}ú
  {#155,save()}ú

Functions of archivesú
  {#224,fclose()}ú
  {#229,filelength()}ú
  {#230,flush()}ú
  {#223,fopen()}ú
  {#225,fread()}ú
  {#227,fseek()}ú
  {#228,ftell()}ú
  {#226,fwrite()}ú

Functions of directoriesú
  {#235,chdir()}ú
  {#238,disk_free()}ú
  {#231,get_dirinfo()}ú
  {#232,get_fileinfo()}ú
  {#233,getdrive()}ú
  {#236,mkdir()}ú
  {#237,remove()}ú
  {#234,setdrive()}ú

Functions of compressionú
  {#262,compress_file()}ú
  {#263,uncompress_file()}ú

Functions of encriptacionú
  {#261,decode_file()}ú
  {#259,encode()}ú
  {#260,encode_file()}ú

Functions of systemú
  {#109,exit()}ú
  {#240,ignore_error()}ú
  {#168,system()}ú

Functions of dynamic memoryú
  {#258,free()}ú
  {#257,malloc()}ú
  {#239,memory_free()}ú

Functions of netú
  {#181,net_get_games()}ú
  {#180,net_join_game()}ú

{/}

{Note:} To obtain help of one concrete function directly, put the
cursor on the name of the function (in the editor of programs)
and press {F1}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1033,Call to a process}

<name_of_process>{(}<list of parameters>{)}

A call to a process you must write the {#1001,name} of the
process (its name), followed by a list of some expressions
separated by {#1059,commas (,)}, which {#1018,parameters} has the process,
between {#1053,parenthesis (())}. The parenthesis are obligatorious even when
the process has no {#1018,parameters} of call.

A call of a process always return a value, which depends on which of the following
actions first realize the called process.

- If is executing the statement {#1029,FRAME} the process will return its {#1039,identification code}.

- If the process executes the statement {#1028,RETURN}{#1053,(}<expression>{#1053,)}
will return the result of this expression.

- If the process finished, or because it reachs the {#1091,END} of its {#1086,BEGIN}
or because executes a statement {#1028,RETURN} without expression, the process
will return the {#1039,identification code} but because the process is
finished (dead), you must remember that this
{#1039,identification code} can be used by any other process
which is created from this moment.

The value of return can be ignored, assigned to a variable or 
used inside any expression.

{#9999,Example:}
PROGRAM my_game;
PRIVATE
  id2;
BEGIN
    my_process(0, 0);
    id2=my_process(320, 200);
    // ...
END
PROCESS my_process(x, y)
BEGIN
    LOOP
        FRAME;
    END
END
{-}

In this example the main process {my_game} realizes two calls
to the process {my_process}, which receives two parameters in its local variables
{x} and {y}.

If the process executes the statement {#1029,FRAME} will return its
{#1039,identification code}.

You can see how the value returned in the first call to the process
is useless (it is not used), and how in the second is assigned
the {#1039,identification code} of {my_process(320, 200)} to the private variable
of the main process {id2}.

When is realizing a call to a process immediately stops the
execution of the current process and passes to execute the code of the called process,
untill this one returns by one of three enumerated cases (till
it finishes or executes a statement {#1029,FRAME} or {#1028,RETURN}).

If the process finished with a statement {#1029,FRAME} will be visualized 
in the next frame by the values established in its local variables
({#1023,x}, {#1024,y}, {#1026,graph}, ...) and, in the preparation of the
next frame, this process will continue executing beginning with the statement {#1029,FRAME}.

{/}See: {#1000,syntax} - {#1018,Parameters of a process}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1034,Reference to a data}

A reference to a data is any expression which makes reference to a
cell or position of the memory of the computor, normally it is understood
as one of these aspects:

- If a data is a variable, to refer to a data you must only
specify its name.

Example of a reference to a variable: {x}

- If the data is a board usually make reference to it
with its name followed by a expression in brackets ({#1079,[ ]}); this
expression will determine the position of the board which pretends to acceed.
If is omited in brackets in the first position of the board will acceed
the index (the position 0).

Example of a reference to a board: {timer[0]}

- If the data is a structure will make reference to it with its
name followed by one expression in brackets ({#1079,[ ]}) what will
determine the number of register where to acceed and, after it, will go 
the symbol{#1063, . (point)} preceded by the concrete name of the field
of the structure to each will acceed. If is omited the number of register
in brackets will acceed to a first register of the structure (the number 0).

Example of a reference to a structure: {scroll[0].z}

These three cases refer to accesses to data of the proper process or globals;
when is pretended to acceed to a another data (a local data of other process),
will precede by the {#1039,identification code} of the
another process and the symbol{#1063, . (point)}, operator of access to
local data and structures).

Example of a reference to a local allien variable: {father.x}

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1035,Definition of expression}

An expression is basically a mathematical formula which
involves one or more {numbers} ({x}, {2}, {id}, ...) with help of different
{operators} ({*}, {AND}, {>>}, ...); some examples of expressions:
{2}, {2+3} o {(x*4)/-3}.

As values can be used only whole numbers inside the rank
({#1177,min_int} ... {#1178,max_int}) and the result of the expression
always will stay truncated inside of this rank.

This expressions will be evaluated when will execute the statement which are contained inside the program.

The {numbers} which can be used in expession are:

    - {#1004,Constants}.ú
    - {Values numericals}.ú
    - {Literales} (texts in inverted commas).ú
    - Variables, boards or structures of any type.ú
    - Any type of function or process.ú
    - {#1039,Identification code} of the process.ú
    - Type of process ({#1042,type <name>}).ú

The {operators} which can be used in expression are (in
parenthesis are shown the synonyms of the operator, if they are):

    {#1056, +}    Sumú
    {#1060, -}    Subtraction (or subtraction mark)ú
    {#1054, *}    Multiplicationú
    {#1065, /}    Divisionú
    {#1048, MOD}  Modul ({#1048,%})ú
    {#1070, <<}   Rotation to the rightú
    {#1077, >>}   Rotation to the leftú
    {#1045, NOT}  Binary and logical negation ({#1045,!})ú
    {#1051, AND}  AND binary and logical ({#1050,&}, {#1051,&&})ú
    {#1083, OR}   OR binary and logical ({#1083,|}, {#1083,||})ú
    {#1082, XOR}  OR exclusive ({#1082,^^})ú
    {#1074, ==}   Comparisonú
    {#1046, <>}   Distinct ({#1046,!=})ú
    {#1076, >}    Majorú
    {#1075, >=}   Major or equal ({#1075,=>})ú
    {#1069, <}    Smallerú
    {#1072, <=}   Smaller or equal ({#1072,=<})ú
    {#1085, OFFSET} Direccion or dislocation ({#1050,&})ú
    {#1057, ++}   Operator of incrementú
    {#1061, --}   Operator of decrementú
    {#1079, ^}    Operator of indireccion ({#1054,*}, {#1079,[ ]})ú
    {#1053, ( )}  Parenthesisú

Press on "{#1036,Evaluation of expression}" to see the order in which are
realized the calculations inside the expression and when must be used the parenthesis.

In continuation are shown some examples of valid expressions:

{    -33}ú
{    44-2*22}ú
{    id}ú
{    x+1}ú
{    (angle*3)/2-pi/2}ú
{    (x+y)/2}ú
{    abs(x-y)*3-pow(x, 2)}ú
    ...

{/}See: {#1000,syntax} - {#1036,Evaluation of expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1036,Evaluation of expression}

Is important to know the form in which are evaluated the expressions to know
where is necessary or not to put parentheses which indicate the mode in which is
the expression is evaluated.

 In the language, an expression can contain operators of different levels
of priority.

In the evaluation of an expression will always first proceed
those of {priority 1} (if they are), then of the {priority 2}, after them
{priority 3} and, such way, successively.

Priority 1ú
    {#1053, ( )}  Parenthesis, start and end of a sub-expressionú

Priority 2ú
    {#1063, .}    Point, operator of access to local data and structuresú

Priority 3ú
    {#1045, NOT}  Binary and logical negation (#1045,{!})ú
    {#1085, OFFSET} Direccion or dislocation (#1050,{&})ú
    {#1079, ^}    Operator of indireccion ({#1054,*}, {#1079,[ ]})ú
    { -}  Subtraction markú
    {#1057, ++}   Operator of incrementú
    {#1061, --}   Operator of decrementú

Priority 4ú
    {#1054, *}    Multiplicationú
    {#1065, /}    Divisionú
    {#1048, MOD}  Modul ({#1048,%})ú

Priority 5ú
    {#1056, +}    Sumú
    {#1060, -}    Subtractionú

Priority 6ú
    {#1070, <<}   Rotation to the rightú
    {#1077, >>}   Rotation to the leftú

Priority 7ú
    {#1051, AND}  AND binary and logical ({#1050,&}, {#1051,&&})ú
    {#1083, OR}   OR binary and logical ({#1083,|}, {#1083,||})ú
    {#1082, XOR}  OR exclusive ({#1082,^^})ú

Priority 8ú
    {#1074, ==}   Comparisonú
    {#1046, <>}   Distinct ({#1046,!=}ú
    {#1076, >}    Majorú
    {#1075, >=}   Major or equal ({#1075,=>}ú
    {#1069, <}    Smallerú
    {#1072, <=}   Smaller or equal ({#1072,=<}ú

Priority 9ú
    {#1073, =}    Assignationú
    {#1058, +=}   Sum-assignationú
    {#1062, -=}   Subtraction-assignationú
    {#1055, *=}   Multiplication-assignationú
    {#1066, /=}   Division-assignationú
    {#1049, %=}   Modul-assignationú
    {#1052, &=}   AND-assignationú
    {#1084, |=}   OR-assignationú
    {#1081, ^=}   XOR-assignationú
    {#1078, >>=}  Rotation to the right-assignationú
    {#1071, <<=}  Rotation to the left-assignationú

The operatores of {priority 3} are their operators known as {unarios}; they are not
vinculated with two numbers (this is the case of the {binarys} operator as,
for example, a multiplication), but only affect to the value of 
operator. Inside the operatores {unarios} first execute the nearest to the
number, for example in the expression:

  {NOT -x}

The number {x} has two operatores {unarios}, the subtraction mark{ -} and
the {#1045,NOT} logical and/or binary; from these first execute the subtraction mark
then the nearest to the number.

All operators beginning with the {priority 4} are {binary} and
execute by their level of priority therefore, when in one expression are more than one
operator of the same level (for example, a multiplication and a division,
which are of the same priority 4), will proceed from the left to the right, it means,
in this expression:

  {8/2*2}

Executes first the division and then the multiplication (this is the
natural form in mathematic to evaluate the expressions).

The only exception ate the operatores of {priority 9} (operators of {assignation}),
will be evaluated from the right to the left , it means, in the expression:

  {x=y=0}

First, will proceed  {y=0} (will put  {y} in {0}) and, then {x=y} (also will put
{x} in {0}, because {y} now values  {0}).

As you can see the assignations function such way when the operator
returns, after realize the assignation, the value which was asigned as
result of the operation.

{/}See: {#1000,syntax} - {#1035,Definition of expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1037,Definition of condition}

The conditions are expressions which normally are as these:

  {x<320}ú
  {size==100 AND graph>10}ú
  {y==0 oR (x>=100 AND x<=200)}ú
  ...

In general, any expression is valid as condition. In the language
are interpreted all expressions {IMPARES} as {certain} and all {PARES}
as {falses}.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    IF (20*2+1)
        x=x+1;
    END
END
{-}

In this example the statement {x=x+1;} executes  always, the expression
{20*2+1} values {41}, which is number {odd}. All disposed operators
are valid inside the condition.

All {#1039,identification codes} of processes are numberes {odd},
it means, all are {certains}. It is possible, therefore, to implement conditions
as this one (assuming that {id2} was declared as variable,
and {shot} is a type of process of the program).

  {id2=get_id(type shot);}ú
  {WHILE (id2)}ú
      {id2.size=id2.size-1;}ú
      {id2=get_id(type shot);}ú
  {END}

In the condition {(id2)} is checking if the function {get_id()} returned
a {#1039,identification code), it always will be {odd} number and the condition will be evaluated
as {certain} (if {get_id()} there is no (more) identifiers of the processes
"type {shot}", so will return  {0} (which is {pair} number)
interpreting the condition as {false}, and finishing the statement {#1022,WHILE}.

The previous statements would decrement the variable {#1128,size} of all
processes of type {shot} which were in the in the program.

{/}See: {#1000,syntax} - {#1035,Definition of expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1038,Forms to obtain the identification code of a process}

All processes have its proper {#1039,identification code} in {#1092,ID}
(reserved word in the language which is equivalent to the {#1039,identification code} of the
process).

When is creating a process (is calling), it returns as value of return
its proper {#1039,identification code}, although it was finished with
{#1028,RETURN}{#1053,(}<expression>{#1053,)}. It means, a process returns 
its {#1039,identification code} always when finishes (reach its {#1091,END}), executes
the statement {#1029,FRAME} or the statement {#1028,RETURN} without expression
in parenthesis.

In this example, from the main program is created a process
(of type {my_process}) and is saved its identifier in the variable {id2}.

{#9999,Example:}
PROGRAM my_game;
PRIVATE id2;
BEGIN
    id2=my_process();
    // ...
END
PROCESS my_process()
BEGIN
    // ...
END
{-}

All processes have predefined the following local variables
with identifiers of other processes:

{#1117,father} - father, identifier of the process which created it (which made a call).

{#1118,son} - son, identifier of the last process created by it (the last
process which was called).

{#1120,bigbro} - identifier of the last process which created
the father before create this one.

{#1119,smallbro} - small brother, identifier of the following process which
created the father after create this one.

This variables can value {0} if they were not defined (for example
{#1118,son} will value  {0} until will be created a process, or if it yet disappeared).

The identification codes of the processes permit to acceed to their local variables
(<identifier>.<variable>), and such as {#1117,father},
{#1118,son}, etc., are local variables which can realize
combinations as {son.bigbro} to acceed to the identifier of the penultimate
process creating (becuase {#1118,son} is the last one, therefore its big brother will be 
the penultimate).

There are other forms to obtain identification codes of processes (besides when are creating
and by direct realtionship), such as:

- The function {#120,get_id()} to obtain the identifiers of the processes
of a determined type (ship, shot, etc.) which exist in a determined
moment of the game.

- The function {#104,collision()} to obtain the identifiers of the
processes with which they have the collision.

When a determined process needs to be acceeded from many others, because if its 
importance as, for example, the ship protagonista of a game,
then can be more usefull to assign its identifier to a variable
{#1006,GLOBAL} of the program (which can be acceeded by any process
in any point).
This way any process could interact with l, because would have its identifier.

{#9999,Example:}
PROGRAM my_game;
GLOBAL
  id_ship;
BEGIN
    id_ship=ship();
    // ...
END
PROCESS ship()
BEGIN
    // ...
END
PROCESS enemy()
BEGIN
    // ...
    id_ship.z=0;
    // ...
END
{-}

In this example the processes of {enemy} type can acceed in one determined
point to a variable {z} of the {ship} which creates the main program,
using for it its identifier which is in the global variable {id_ship}.

{/}See: {#1039,Identification codes of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1039,Identification codes of processes}

A process is an independent object of the program which executes its proper
code and which can have its proper coordinates, graphics, etc., for example
can be processes of a program: a ship, a shot or an enemy.

When inside one program is situated something similar to this:

{PROCESS shot(}...{);}ú
{#1086,BEGIN}ú
   { // }statements{ ...}ú
{#1091,END}

Are specifying the statements which will execute thes processes
"of type {shot}", it means, the code which will manage its conduct.

As you can see in a program there can be more than one process of type
{shot}, so how are they distinguished? Very simple, by
its identification code.

Each time when in a game creates a new process, it receives its
identification code; this code will be the exclusive reference of the
process until the moment when it disappears.

Two different processes will never have the same identification code at the same time;
but, the code which belonged to a process which yet dissapeared can be
assigned to a new process (as the number of the identification card).

The identification codes are always whole positive and odd numbers,
as 471, 1937 or 10823.

All processes have their own identification codes in {#1092,ID}, which is similar to
a local variable of the process, but it can not be modified.

The processes, also, have identification code of the process which 
created them (which called them) in {#1117,father}, of the last process
which they created (the last which they called) in {#1118,son}, etc.
(See {#1041,Hierarchy of processes}).

{What for sirve the identification codes?}{/}

Normally, all processess need the identification code of other
processes to interact with them (See where they are, modify them, ...).

You can not, for example, subtract the energy from the process "type {enemy}", 
processes of this type can not exist or be numerous; is necessary the
concrete identification code of the process {enemy} from which you want to subtract the energy.

A process acceeds to all of its proper variables only by its names, as
{#1123,x}, {#1128,size} or {#1126,graph}. It is good, if there is
the identifier of a process (in {#1118,son}, {#1117,father} or any other
variable defined by the user, as {id2}) you can, so, acceed
to a variables of the named process as ({son.x}, {father.size} or {id2.graph}),
it means, the syntax to acceed to local variables of other process is:

  <identification_code> . <variable_name>

You can normally use these variables to consult or modify them.

{It is not possible in any case to acceed to a variables of type {#1008,PRIVATE} of other
process}. If you want to acceed to a private variable of other process,
you must change the declaration of it in the section {#1007,LOCAL} to
convert it in a local variable; so, any process can acceed
to the named variable having the identification code of the process, because all
processes have such variable.

The identifiers have more spheres of use besides the access to other local variables,
for example the function {#158,signal()} which can send determined signals
to a process if has its identification code (for example, to
undo the process).

There are other functions, as {#104,collision()}, to detect collisions
with other processes which, if it is detected, return the
identification code of the process with each it had the collision. If you have this code
you can acceed to a variables of the process and send it the signals.

The function {#120,get_id()} functions the similar way to {#104,collision()},
obtaining the identification code of the process, but without necessity of the collision with l.

{/}See: {#1038,Ways to obtain the identification code of the process}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1040,States of a process}

The processes are different elements of a program (objects of the game);
they can go trough differentes states while are creating, destroying or receiving
determined signals with help of the function {#158,signal()}.

Process {working or awaked}

If a process is executing (is interpreting the statements
which were recognized between its {#1086,BEGIN} and its {#1091,END}) it means that the process is awaked.


Process {dead}

When a process finishes (because reaches its {#1091,END} in the execution,
because ejecutes a {#1028,RETURN} or because receives a signal {#1153,s_kill} or
{#1157,s_kill_tree}), it is said that the process is dead.

Process {slept}

A process can receive the signal {#1155,s_sleep} (or {#1159,s_sleep_tree}) and,
stay in the slept state; in this state the process is if it were dead,
but in any moment it can receive the signal
{#1154,s_wakeup} and return to working or awaked state.
Also you can kill the slept process.

Process {frozen}

The signal {#1156,s_freeze} (or {#1160,s_freeze_tree}) leaves the process in frozen state.
In this state the process stays without moving, but it continues to live
and the rest of the processes can detect it (in the collisions,
for example), but it not executes (stop to interpret its statements of
code). Will stay in this state untill receives another signal which changes the stay or kills it.


A frozen process can be controled (moved) by other process,
manipulating directly its variables.

{/}

Always when is sent a signal to a process with the goal to change its state,
will not have any effect if the process is executing until it reaches
its next visualization ({#1029,FRAME}). If the process was not executing,
so the signal immediately would have the effect.

Have not to be sent the signal to the unexistant processes (to a {#1039,identification code}
which do not correspond to any process).

If is intented to put one process in the state in which it is, the signal will be  ignored.

{/}See: {#1041,Hierarchy of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1041,Hierarchy of processes}

A process is an indepent object of the program which executes its proper
code and which can have its own coordinates, graphics, etc., for example,
can be processes of a program: a ship, a shot or an enemy.

When the program begins to execute only exists one process; the initial process
which begins to execute the statements of the main code
but from that moment, it can create new processes
and they can make, destroy, etc. another ones.

To clerify the events which are succeeding in a program is established
a comparison, the processes are seen as living being which are born
and dead (when are creating and destroying). Therefore, are established such terms:

{Father}, denomination which is given to a process which created the new one (it had to be named mather).

{Son}, the process which was created by other.

{Brothers}, processes which were created by the same father.

{Orphan}, process whose father is dead (was undone or finished).

And this vocabulary can be contunued, {grandparents},{grandson}, {uncles}, etc.

All processes have an access to the identification codes of the
processes with which they have direct likeness (See: {#1038,Ways to obtain
the {#1039,identification code} of a process}.

In ocasions, is made the reference to actions made by "{the system}"; this
process, denominated {div_main}, controls the rest of them, therefore
it is occupied to create the initial process in the beginning of the execution, to put in order
the speed of execution, the debugger, etc. All processes which stay
orphans become children of this process.

The {identifier of div_main} you can obtain with {#120,get_id(0)}. Can
serve to send a signal to tree to all processes,
but this process will not visualize in the screen although its
variables {#1123,x}, {#1124,y}, {#1126,graph}, etc. are defined.

{/}See: {#1040,States of a process}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1042,types of processes}

The blockes of the programs which begin with the reserved word {#1016,PROCESS}
determine the conduct of a concrete type of process. Then when
they ejecute the program in the determined moment can have any number of processes of such
type, each one with the different {#1039,identification code}
but all of the same type.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    // ...
END
PROCESS ship()
BEGIN
    // ...
END
PROCESS enemy()
BEGIN
    // ...
END
PROCESS shot()
BEGIN
    // ...
END
{-}

In this example are defined four types of processes, {my_game} (which will be 
the type of the initial process of the program}, {ship}, {enemy} and {shot}.

The number of processes of each of these types which will be then in the
game depends on the numbers of calls which are realized in these processes.

All processes of type {ship} will execute always the statements which
are defined in the block {PROCESS ship()} of the program.

A "type of process" is a numerical code which makes reference to the
name which has the PROCESS which determines the conduct of the
process during the game; this numerical code you can obtain with: {TYPE <name_of_process>}

{TYPE} is a operator defined in the language which, applicating to a name of process,
returns this numerical code.

For example, {TYPE ship} will be equivalent to a numerical determined constant and
{TYPE enemy} to another one.

All processes have a local variable which contain this numerical code and is: {reserved.process_type}.

{What does the type of process sirve for?}{/}

The type of the processes is used for different things, for example:

- For the function {#120,get_id()} which receives as parameter a type of process
(for example, {get_id(TYPE enemy)}) and returns the identification codes
of the processes of this type which exist in the game in this moment.

- For the function {#104,collision()} is similar to the last one, but this one returns
the identification codes of the processes with which is has collisions
(it means, the graphics of two processes partly overput).

- For the function {#158,signal()} which can send a signal to all
existent processes of determined type.

- Or beginning from the {#1039,identification code} of the process, can check
about which type of process is talking (if it is of type ship, of type shot, etc.).

{/}

The operator TYPE can be used only preceeding to a name of
process of the program or to the word {mouse}, to detect the collisions
with pointer of the mouse (with {collision(TYPE mouse)}).

{/}See: {#1039,Identification codes of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1043,statement FROM}

{FROM} <variable>{#1073,=}{#1005,<constant>} {#1096,To} {#1005,<constant>}{#1068,;}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}

(or)

{FROM} <variable>{#1073,=}{#1005,<constant>} {#1096,To} {#1005,<constant>} {#1095,STEP} {#1005,<constant>}{#1068,;}ú
    {#1017,<statement>} {#1068,;}ú
    ...ú
{#1091,END}

The statement {FROM} is a statement which implements a {loop}, it means, it is
capable to {repeat a group of statements determined number of times}.

To implement this loop you need a variable {#1006,GLOBAL}, {#1007,LOCAL} or
{#1008,PRIVATE} of the proper process which sirves as counter of the loop.

Before the statements which will conform the internal group of statements you must put
the reserved word {FROM} followed by the {name of the variable counter},
the symbol of assignation ({#1073,=}), the {initial value} of the variable, the
reserved word {#1096,To} and, finally, the {final value} of the variable.
After this declaration of the loop {FROM} you must put the symbol {#1068,;}
(point and comma).

After this headline defining the conditions of the loop will come 
the internal group of statements which is pretended to repeat the determined number of times
and finally, the reserved word {#1091,END}.

Is denominated {iteration} of the loop how many times executes the internal group of statements.

The first iteration will be made with the {initial value}
in the variable uses as counter, after this iteration this variable {will be sumed with 1}
(if the initial value {is smaller} than the final value)
or {will be subtracted 1} (in contrary case). After actualization of the value
of the variable, will pass to the next iteration always when the
value of this variable did not reach (or exceed) the {final value} of the loop.

As the second acception of the statement {FROM} you can put after the initial and final values
of the statement the reserved word {#1095,STEP} followed by 
a {constant value} which indicates the increment of the variable counter after each
iteration of the loop, in place of {1} or{ -1}, what are the increments
which will be made by default if is omited the declaration {#1095,STEP}.

In continuation, is shown a program with two loops {FROM}, one without declaration
{#1095,STEP} (with increment or decrement by default) and other with it.

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FROM x=9 To 0;
        // internal statements ...
    END
    FROM x=0 To 9 STEP 2;
        // internal statements ...
    END
END
{-}

The first loop executes  {10} times with the variable {x} with value
from {9} to {0} in the different iterations; by default, from the variable subtracts
one each time, because the initial value (9) is bigger than the final value (0).

In the second, indicates how increment of the variable the constant {2},
therefore the loop executes {5} times with the variable {x} with value
{0}, {2}, {4}, {6} and {8}, respectively, in the successive iterations.
As you can see will not be done any iteration with {x} with value {9},
although it would be the {final value} of the loop.

By default, if it had not specified as {#1095,STEP} of the loop {2},
it would have sumed {1} with the variable {x} after each iteration.

A loop {FROM} always can be realized with the statement {#1025,FOR},
as it is shown in continuation (with two loops which are equivalent to those from the last
example).

{#9999,Example:}
PROGRAM my_game;
BEGIN
    FOR ( x=9 ; x>=0 ; x=x-1 )
        // internal statements ...
    END
    FOR ( x=0 ; x<=9 ; x=x+2 )
        // internal statements ...
    END
END
{-}

The {initial} and {final} values of the loop {FROM} must be different.

If the initial value {is smaller} than the final, you can not
specify a negative value in the declaration {#1095,STEP}.

If the initial value {is bigger} than the final, you can not 
specify the positive value in the declaration {#1095,STEP}.

A statement {#1026,BREAK} inside the loop {FROM} will finish it
immediately, continuing the program with the next statement to the named loop
(after the {#1091,END}).

A statement {#1027,continue} inside the loop {FROM} will force the program to
increment immediately the variable used as counter and, then,
if the final value was not exceeded, will begin with the next iteration.

The internal statements to a loop {FROM} can be of any quantity and any type
including of course the new loops {FROM}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1044,Use of angles in the language}

All angles are specified in the language in thousandth of degree.
For example:

  {0} is {0 degrees} (to the right)ú
  {90000} are {90 degrees} (to the top)ú
 { -45000} are{ -45 degrees} (diagonally down to the right)ú

If to any angle are sumed or subtracted {360 degrees} (360000) we will
obtain the equivalent angle. For example, the angle -90000 and
270000 are equivalent (the angles of{ -90 degrees} and {270 degrees}
are two to the down).

You can use as reference the constant {#1179,PI} predefined as {180000},
{3.1415 radians} or, what is the same, {180 degrees}. For example {PI/2}
is equivalent to 90 degrees (90000).

Here are some functions for management of the angles:

  {#116,get_angle()}ú
  {#118,get_distx()}ú
  {#119,get_disty()}ú
  {#113,fget_angle()}ú
  {#142,near_angle()}ú
  {#101,advance()}ú
  {#183,xadvance()}ú

All processes have a local variable predefined denominated {angle}
which, by default, will value {0}; if its value is modified will change the angle
of visualization of the graphic of the process (the graphic will rotate in the indicated degrees
from the original graphic).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1045,NOT !}

Unary perator of logical and binary {negation} used in expressions and conditions.

The reserved word {NOT} and the symbol {!} are synonyms.

{NOT logical:} If the number is {certain}, after applicate it this operator, will obtain 
a {false} and contrary expression.

  certain  ->  falseú
  false   ->  certainú

{NOT binary:} Change all bit of the number, it means, transmits the 0 to 1 and
the 1 to 0.

{/}

{Note:} This operator functions as logical and binary, therefore
in the language are interpreted the logical {certains} expressions as which have
the last bit in 1 (the bit 0, weighing 1), it means, the odd numbers
(1, -1, 3, -3, ...), and as logical {false} expressions which
have the last bit in 0 (the pair numbers: 0, 2, -2, 4, -4, ...).

After change the operator {NOT} all the bit change the last too
converting the pair numbers in odd (false expressions
in certain) and odd in pair numbers (certain expressiones in false).

{/}See: {#1000,syntax} - {#1035,Expression} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1046,<>  !=}

Logical operator [{distinct that}] using in conditions. The symbols
{<>} and {!=} are synonyms.

Must be used between two numerical expressions and return a logical result:

{false} - If both expressions give the same result (if are two
equivalent expressions), so NO are distinct.

{certain} - If the expressions give distinct results, so YES are distinct.

{Examples:}

  {2+2 <> 4} return  {false}.ú
  {0 <> -1}  return  {certain}.ú

{/}See: {#1000,syntax} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1047,"  '}

Delimitation literal symbols.

The literals are the {texts in invert commas} which can begin and finish with the
character [{'}] or with the character [{"}] (must begin and finish
with the same character). If in one literal you want to put the character [{"}], you can do it in two ways;
lets suppose that we want to define a literal which contains the text: a"B"c

 - Duplicate the character: "a""B""c"

 - Define it with the simple comma: 'a"B"c'

The same succeeds with the character [{'}], which can be included in a literal
if it is duplicated, or if the literal is delimited with the character [{"}].

All literales must be closed in the same line in which they were begun, can not be defined
the literals more long than one line.

{/}

{Literals of several lines.}

It is possible to define the literals in several lines, for it you must only divide the
text in several, and put them successively (do not separate them by any symbol). For
example, you could define a constant as:

{saludo="­Ho"}ú
{       "la!";}

This also can be used to initiate the data of {#1406,STRING} type.
There is no limit in number of lines. Between two successive literals
could only appear {#1002,explication commentaries}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1048,MOD  %}

Arithmetical operator of {modul} or whole {the rest of a division}. The reserved word
{MOD} and the symbol{ %} are synonyms.

This operator is used in the {#1035,arithmetical expressions} between two numbers,
to obtain the modul of first division by the second.

For example {7 MOD 3} returns  1, because after realize the whole division of 7
by 3 results 2 as quotient and {1} as {the rest}.

It means, that {n MOD m}will always return a number inside the rank (0..m-1).

To understand how we obtain the rest of a operation
{n MOD m} you can follow these steps:

{Step 1} - If {n} is smaller than {m}, the result of the operation {MOD} is {n}.

{Step 2} - (When {n} is bigger or equal {m}) we rest {m} from {n} and return to the {step 1}.

{/}

{Use:} This operator is used in ocasions in such programs where is
required that the counter variable always changes between {0} and {other number}; 
if you want for example the variable {x} changes
between 0 and 319 indefinitely (x=0, x=1, x=2, ..., x=319, x=0, x=1, ...)
can be made such way:

  {x=0;}ú
  {LOOP}ú
  {    x=x+1;}ú
  {    IF (x==320) x=0;}ú
  {    // ...}ú
  {END}ú

But many programs substitute this statements by these:

  {x=0;}ú
  {LOOP}ú
  {    x=(x+1) MOD 320;}ú
  {    // ...}ú
  {END}ú

which realize exactly the same function, because the operator {MOD} will truncate 
the expression when will be bigger or equal 320 to smaller value.

{/}

The whole {equotient} of the division is obtained with the operator {#1065,/}
(division).

{/}See: {#1000,syntax} - {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1049,%=}

Operative assignation. Operation of {modul} or whole {the rest of division}.

The {#1019,statements of assignation} sirve to calculate expressions and
{assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If it is used the symbol {%=} in place of {=} to realize the assignation,
will be assigned to the data the following {modul} or {the rest of the division}:

  [{prevoius_value_of_data}] / [{result_of_the_expression}]

Example: {x=3; x%=2;} -> (x=1)

{/}

{Note:} This symbol is a simple derivative abreviatura of the {language C},
in any case a statement of type {n %= m;} will be equivalent to this one {n = n MOD m;}.

See the operator {#1048,MOD} for more information about the {module}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1050,&}

Bifunctional symbol which has two spheres of use as unary or binaty operator.

A operator {UNARY} appears inside the expression preceeding to a
number (if it were the sign of this one); in this case
the operator{ &} will be synonym to {#1085,OFFSET}.

{Example: &x} is equivalent to {OFFSET x}

A operator {binary} appears inside the expression linking two
numbers (indicating an operation between both), in this case the
operator{ &} will be synonym to {#1051,AND}.

{Example: x&2} is equivalent to {x AND 2}

{/}See: {#1000,syntax} - {#1085,OFFSET} - {#1051,AND}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1051,AND  &&}

Binary operator of the {logical product} used in expressions and conditions.

The reserved word {AND} and the symbol{ &&} are synonyms.

{AND logical:} Are evaluated, first, the conditions from right to left
of the operator and, if both are {ceratain}, this operator returns  {certain},
in contrary case the operator always returns {false}.

  false  AND false  = falseú
  false  AND certain = falseú
  certain AND false  = falseú
  certain AND certain = certainú

Is used to check which are fulfilling obligatory more than one condition,
for example:

  {(x>0 AND x<100)}

To check if the variable is bigger than 0 {Y} or is smaller than 100.

{AND binary:} Evaluetes the bit of the results of the last and next 
to the operator expressions generating, as a result, a value which will have only the
bit which had in one two expressions.

  0 AND 0 = 0ú
  0 AND 1 = 0ú
  1 AND 0 = 0ú
  1 AND 1 = 1ú

This rule applicates to all bits of the numbers (in the language
are whole of 32 bits).

{/}

{Note:} This operator functions as logical and binary, therefore
in the language are interpreted the logical {certain} expressions as which have
the last bit in 1 (the bit 0, weighing 1), it means, the odd numbers
(1, -1, 3, -3, ...), and as logical {false} expressions which
have the last bit in 0 (the pair numbers: 0, 2, -2, 4, -4, ...).

The operator {AND} will only leave in 1 the last bit (will only return {certain}
as result} when the two ones had the {certain} expressions.

{/}

{Note:} the symbol{ &} also can be used as another synonym besides
{AND} and{ &&}.

{/}See: {#1000,syntax} - {#1035,Expression} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1052,&=}

Operative assignation. Binary operation of {logical product} ({AND}).

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If is used the symbol {&=} in place of {=} to realize the assignation,
will be assigned to the data the following {logical product}:

  [{previous_value_of_data}] AND [{result_of_the_expression}]

Example: {x=5; x&=6;} -> (x=4)

{/}

{Note:} This symbol is a simple derivative abreviatura of the {language C},
in any case a statement of type {n &= m;} will be equivalent to this one {n = n AND m;}.

See the operator {#1051,AND} for more information about the {logical product}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1053,(  )}

The symbols {(} and {)}, denominated parenthesis, must appear always
in pair and in such order.

Are used to delimitate determined calculations, parameters or conditions
of the programs, marking its beginning with the symbol {(} and
the end with the symbol {)}.

{/}

Inside one expression indicate that the calculation of its interior must be done before the calculation of its exterior.

For example, the expression {2*3+2} will be evaluated as {8}, because first
will be realized the multiplication (2 by 3, that is 6) and then will be sumed
(6 with 2, which will give a result 8).

Using parenthesis you can force to realize first the sum,
expressing the calculation as {2*(3+2)}, what will be evaluated as {10}, because
now first will be realized the sum (3 with 2, that is 5) and then
the multiplication (2 by 5, that is 10).

{/}

The parenthesis also are used to delimit the parameters of call
of the processes or functions and inside the syntax of different statements of the language.

{/}See: {#1000,syntax} - {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1054,*}

Arithmetical operator of whole {multiplication}. This operator is used in the
{#1035,arithmetical expressions} between two numbers, to obtain as result
its product (the multiplication).

For example {2 * 8} will return  {16}, {99 * 0} will return  {0}, {2 * -1}
will return { -2}, etc.

All variables are {whole} with sign of 32 bit in the language.
therefore, can be used only whole numbers inside the rank
({#1177,min_int} ... {#1178,max_int})} so, when the result of
the {multiplication} must exceed this rank, {will be shown incorrect results}.
In this case, the system will not advert to any error, here must be taken the precautions.

{/}

This symbol is bifunctional, it means, it has two different spheres of use 
as unary or binary operator.

An operator {UNARY} appears inside one expression preceeding
only to one number; in this case
the operator {*} will be synonym of {#1079,^}.

{Example: *x} is equivalent to {^x}.

A operator {binary} appears inside the expression linking two
numbers (indicating an operation between both), in this case the
operator{ *} will be the arithmetical operator of {multiplacation} explained before.

{/}See: {#1000,syntax} - {#1035,Expression} - {#1079,^}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1055,*=}

Operative assignation. Arithmetical operation of {multiplication}.

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

It is used the symbol {*=} in the place of {=} to realize the assignation,
will be assigned to the data the following {multiplication}:

  [{previous_value_of_data}] * [{result_of_the_expression}]

Example: {x=2; x*=3;} -> (x=6)

{/}

{Note:} This symbol is a simple derivative abreviatura of the {language C},
in any case a statement of type {n *= m;} will be equivalent to this one {n = n * m;}.

See the operator {#1054,*} for more information about the {multiplication}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1056,+}

Arithmetical operator of {sum}. This operator is used in the
{#1035,arithmetical expressions} between two numbers, to obtain its sum.

For example {2 + 6} returns 8, the sum of 2 and 6.

All variables are {whole} with sign of 32 bit in the language.
Therefore, can be used only whole numbers inside the rank
({#1177,min_int} ... {#1178,max_int})} so, when the result of
the {multiplication} must exceed this rank, {will be shown incorrect results}.
In this case, the system will not advert to any error, so you must be very
cautious.

{/}See: {#1000,syntax} - {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1057,++}

Operator of increment, this operator, derivated from the language C, permits
to increment the value of a data (to sum 1) without require, for it, a
{#1019,statement of assignation}.

The data can be a variable, a {position of a board}, or
{field of structure}.

This operator can be included inside the expression in two modalities:
{preincrement} and {postincrement}.

{operator of preincrement}

When you put the symbol { ++} just before the data, it will be sumed with 1
{before to execute the statement}, for example, see these statements:

{ ++x;} - statement which sums 1 to the variable {x}.

{ z=++x+y;} - statement which sums 1 to the variable {x} and, then, assigns 
to the variable {z} the sum of {x} (incremented yet) and {y}.

{operator of postincrement}

When you put the symbol { ++} just before the data, it will be sumed with 1
{after to execute the statement}, for example, see these statements:

{ x++;} - statement which sums 1 to the variable {x}.

{ z=x+y++;} - statement which assigns the sum of {x} and {y} to the variable {z},
and, then, increments the variable {y}.

{/}

{Resume:}

In general, a statement of type{ ++data;} or {data++;} is always equivalent
to the following statement: {data=data+1;} (or {data+=1;}).

The difference between the {preincrement} and the {postincrement} is that in the first case
is taken the value of data incremented yet to evaluate the rest of the expression,
while in the second case is evaluated the expression with the value which the data had before to be
incremented.

{/}See: {#1000,syntax} - {#1035,Expression} - {#1061,Decrement(--)}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1058,+=}

Operative assignation. Operation arithmetical of {sum}.

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If it is used the symbol{ +=} in place of {=} to realize the assignation,
will be assigned to the data the following {sum}:

  [{previous_value_of_data}] + [{result_of_the_expression}]

Example: {x=2; x+=2;} -> (x=4)

{/}

{Note:} This symbol is a simple derivative abreviatura of the {language C},
in any case a statement of type {n += m;} will be equivalent to this one {n = n + m;}.

See the operator {#1056,+} for more information about the {sum}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1059,,}

The symbol comma ( {,} ) is using inside the language of programming,
in different points of the program, {to separate} two consecutive elements
of one list.

Is used, for example, in these points:

- In the {#1013,lists of constants} to separate its different numerical values.

- In the definition of the {#1018,parameters of process} to separate
the names of the different parameters.

- In the {#1033,call a process} to separate the different expressions which will be assigned
to the parameters.

- In the {#1025,statement FOR} to separate different initiations, conditions or increments.

- In the {#1021,statement SWITCH} to define the different values accepted in block {CASE ... END}.

{/}

The symbol comma can be also used to separate different
{#1009,declarations of data}, in place to finish each one
with the symbol {point and comma} ({#1068,;}).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1060,-}

Arithmetical operator of {subtraction}. This operator is used in the
{#1035,arithmetical expressions} between two numbers, to obtain its sum.

For example {2 - 6} returns -4.

All variables are {whole} with sign of 32 bit in the language.
Therefore, can be used only whole numbers inside the rank
({#1177,min_int} ... {#1178,max_int})} so, when the result of
the {multiplication} must exceed this rank, {will be shown incorrect results}.
In this case, the system will not advert to any error, so you must be very
cautious.

{/}

This symbol is bifunctional, it means, it has two differentes spheres of use
as unary or binary operator.

An operator {UNARY} appears inside the expression preceeding only to
one number, this case the operator{ -} will be the {sign minus}.

{Example: -7} the whole negative number {minus seven}.

A operator {binary} appears inside the expression linking two
numbers (indicating an operation between both), in this case the
operator{ -} will be the arethmetical operator of {subtraction} explained before.

{/}See: {#1000,syntax} - {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1061,--}

Operator of decrement, this operator, derivated from the language C, permits
to decrement the value of a data (to subtract 1) without require, for it, a
{#1019,statement of assignation}.

The data can be a variable, a {position of a board}, or
{field of structure}.

This operator can be included inside one expression in two modalities:
{predecrement} and {postdecrement}.

{operator of predecrement}

When you put the symbol { --} just before the data, from it will be subtracted 1
{before to execute the statement}, for example, see these statements:

{ --x;} - statement in which subtracts 1 from the variable {x}.

{ z=--x+y;} - statement which subtraces 1 from the variable {x} and, then, assigns 
to the variable {z} the sum of {x} (decremented yet) and {y}.

{operator of postdecrement}

When you put the symbol { ++} just before the data, from it will be subtracted 1
{after to execute the statement}, for example, see these statements:

{ x--;} - statement which subtactes 1 from the variable {x}.

{ z=x+y--;} - statement which assigns the sum of {x} and {y} to the variable {z},
and, then, decrements the variable {y}.

{/}

{Resume:}

In general, a statement of type{ --data;} or {data--;} is always equivalent
to the following statement: {data=data-1;} (or {data-=1;}).

The difference between the {predecrement} and the {postdecrement} is that in the first case
is taken the value of data decremented yet to evaluate the rest of the expression,
while in the second case is evaluated the expression with the value which the data had before to be
decremented.

{/}See: {#1000,syntax} - {#1035,Expression} - {#1061,increment(++)}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1062,-=}

Operative assignation. Operation arithmetical of {subrtaction}.

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If it is used the symbol{ -=} in place of {=} to realize the assignation,
will be assigned to the data the following {subtraction}:

  [{previous_value_of_data}] + [{result_of_the_expression}]

Example: {x=4; x-=2;} -> (x=4)

{/}

{Note:} This symbol is a simple derivative abreviatura of the {language C},
in any case a statement of type {n -= m;} will be equivalent to this one {n = n - m;}.

See the operator {#1060,-} for more information about the {subtraction}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1063,.  ->}

Operator of access to local allien structures or data. The symbols{ .} and{ ->}
are synonyms, therefore can be used both.

{/}

{Access to structures}

To acceed to a field of one structure you must use this operator:

<name of the structure>{[}<n§ register>{]}{ . }<name of field>

(or using other symbol)

<name of the structure>{[}<n§ register>{]}{ -> }<name of field>

{Examples:}ú
  {scroll[0].camera}ú
  {m7[1]->z}ú

{Note:} Remember that the number of register in brackets can be omited
when is acceeding to the register number 0, for example {scroll[0].camera} is equivalent 
always to {scroll.camera}.

{/}

{Access to local allien data (of other process)}

To acceed to a data {#1007,LOCAL} of a process from the other, you must have
the {#1039,identification code} of the process which data you want to read
or modify, so you can acceed there this way:

<identification code>{ . }<name data local>

(or, using the other symbol)

<identification code>{ -> }<name data local>

{Examples:}ú
   {father.x}ú
   {son->graph}ú

{/}See: {#1012,Declaration of a structure} - {#1039,Identification codes} - {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1064,..}

{Rank of values of one section CASE}{/}

The symbol{ ..} (doble point) is used to define a rank of values,
it means, to express the group of numbers recognized between two values
(including these ones).

This symbol is used {only in the statements} {#1021,SWITCH}, inside
the {sections CASE}, to specify a rank of values.

It results indifferent to express a rank as {minimum..maximum} or as {maximum..minimum}.

For example, the rank defined with{ -2 .. 1} would be the numbers{ -2},{ -1}, {0} and {1}.

{/}See: {#1000,syntax} - {#1021,statement SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1065,/}

Operator arithmetical of whole {division}. This operator is used in the
{#1035,expressions aritemetical} between two numbers, to obtain the quotient
from the first division by the second.

For example {7 / 3} returns  2, because after realize the whole division of 7
by 3 is obtained {2} as {quotient} (and 1 as the rest).

It means, the {n / m} always returns the result of the division
of {n} by {m}, but without the tenth (because all variables are
{whole} with sign of 32 bits in the language).

{/}

The {rest} of the whole division will be obtained with the operator {#1048,MOD}
(modul).

{/}See: {#1000,syntax} - {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1066,/=}

Operative assignation. Operation arithmetical of {whole division}(quotient).

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If it is used the symbol{ /=} in place of {=} to realize the assignation,
will be assigned to the data the {whole result} (quotient) of the following {division}:

  [{previous_value_of_data}] / [{result_of_the_expression}]

Example: {x=8; x/=2;} -> (x=4)

{/}

{Note:} This symbol is a simple derivative abreviatura of the {language C},
in any case a statement of type {n/= m;} will be equivalent to this one {n = n / m;}.

See the operator {#1065,/} for more information about the {whole division}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1067,:}

The symbol {:} (two points) is used to finish a declaration
{#1087,CASE} or a declaration {#1088,DEFAULT} of a {#1021,statement SWITCH}.

In reality, the symbols {:} (two points) and {;} (point and comma) are synonyms
in this language, it means, that you can use both of them.

Even so, because of equaty with other languages of programing, normally, is used
the symbol {point and comma} as the finisher of statements and the symbol {two points}
inside the syntax of the {#1021,statement SWITCH}.

{/}See: {#1000,syntax} - {#1087,CASE} -  {#1088,DEFAULT} - {#1021,statement SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1068,;}

The symbol {;} (point and comma) is used un multiple points of the program
to indicate, always, that finishes a statement or any type of declaration.
This denominates the symbol {finisher} which has only to mark the end of something.

In the language must be indicated with point and comma the following points of the program:

- The end of the {#1003,declaration PROGRAM}.

- The end of a {#1009,declaration of a data}.

- The end of a {#1014,declaration IMPORT}.

- The end of the following statements:ú
    {#1019,Assignations or increments of data}.ú
    {#1033,Calls to processes}.ú
    {#1032,Calls to functions}.ú
    {#1029,FRAME}, {#1028,RETURN}, {#1031,DEBUG}, {#1026,BREAK} and {#1027,CONTINUE}.ú

- The end of the beginning of loop {#1043,FROM}.

- And as separator of the differentes parts of one statement {#1025,FOR}.

The compiler indicates when there is no symbol {;} in any of these points.

Also this symbol can be put in other determined points of the
programs, after any other type of statement, although in this case
it is optional and, therefore, the compiler will not advert its absence.

{/}

In reality the symbols {;} (point and comma) and {:} (two points) are synonyms
in this language, it means, it is indifferent which to use.

Even so, because of equaty with other languages of programing, normally, is used
the symbol {point and comma} as the finisher of statements and the symbol {two points}
inside the syntax of the {#1021,statement SWITCH}.

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1069,<}

Logical operator [{smaller than}] used in conditions. Must be used between
two numerical expressions and return a logical result:

{false} - If the first expression No is smaller than the second.

{certain} - If the first expression YES is smaller than the second.

{Examples:}

  {2+2 < 4} returns  {false}.ú
  {1 < 2}   returns  {certain}.ú

{/}See: {#1000,syntax} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1070,<<}

Binary operator of {rotation to the left}. This operator is used in the
{#1035,arethmetical expressions}, between two numbers, to obtain the result
of rotation of the first number to the left the number of times how it indicates the second one. 
For example, the following rotation:

  {n} << {m}

Returns {n} rotated to the left {m} times; each rotation to the left
is equivalent to multiplicate by 2 the number. It means, to rotate to the left 1
time, is equivalent to multiplicate by 2, to rotate to the left 2 times is to multiplicate
by 4, 3 times is to multiplicate by 8, and successively.

Or which is equivalent (the {#145,function POW}{(2, m)} returns {2} lifted {m} times):

  {n} * POW(2, {m})

For example, {2<<3} returns  16, {4<<1} returns  8, {100<<0} returns  100, etc.

All variables are {whole} with sign of 32 bits in the language.
Therefore can be managed only whole numbers inside the rank
({#1177,min_int} ... {#1178,max_int})}, therefore when the result of the
{rotation} must exceed to the named rank, {will be shown the incorrect results}. 
In this case the system will not advert any error, so you must be very cautious.

{/}

The operator of rotation to the right (contrary operation to this one) is the
{#1077,symbol >>}.

{/}See: {#1000,syntax} - {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1071,<<=}

Operative assignation. Binary operation of {rotation to the left}.

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If is used the symbol{ <<=} in place of {=} to realize the assignation,
will be assigned to the data the result of the following rotation:

  [{previous_value_of_data}] << [{result_of_the_expression}]

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1072,<=  =<}

Logical operator [{smaller or equal}] used in conditions. The symbols {<=} and {=<} are synonyms.
Must be used between two numerical expressions and return a logical result:

{false} - If the first expression NO is smaller or equal than the second.

{certain} - If the first expression YES is smaller or equal than the second.

{Examples:}

  {2+2 < =3} returns  {false}.ú
  {2+2 < =4}   returns  {certain}.ú

{/}See: {#1000,syntax} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1073,=}

The symbol {=} (symbol of {assignation}) is used in the language inside
the {#1009,declarations of data} to initiate them, it means, to
define its initial value and in the {#1019,statements of
assignation} to separate the reference to the data, of the assigned expression.

Inside one expression this operator can be used as 
arithmetical binary conventional operator, which must be situated between two numbers,
and returned as result the value of the second number (besides the realization
of the assignation of this result to the data reflexing as first number).

This operator represents one {imperative order}; orders after execute
the statement which it contains, the first number (anterior to the symbol) to take
the value which has the second number (or posterior expression posterior to the symbol).

In the evaluation of expression the numbers of assignation are always
those of {smaller priority} (the last which are interpreted in the expression),
so you can use the parenthesis to force the bigger priority. If in one
expression (or statement) were used different operatores of assignation,
they will be evaluated (executed) from the right to the left.

For example, in the statement:

  {x=y=x+y;}

First will be realized the sum ({x+y}), after assignation of result as
new value of the variable {y} ({y=x+y}) and, lastly, will be assigned as
value to the variable {x} ({x=y}).

{/}See: {#1000,syntax} - {#1009,Declarations of data} - {#1019,statements of assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1074,==}

Logical operator [{equal as}] used in conditions. Must be used between two
numerical expressions and returned a logical result:

{false} - If the expressions give different results, than NO are equals
(not equivalent).

{certain} - If both expressions give the same result (if are two
equivalent expressions), than YES are equal.

{Examples:}

  {0 == -1}  returns  {false}.ú
  {2+2 == 4} returns  {certain}.ú

{/}

{Note:} The symbol {#1073,=} can be used to compare two expressions
or numerical values, because it is the symbol of assignation.

{/}See: {#1000,syntax} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1075,>=  =>}

Logical operator [{bigger or equal}] used in conditions. The symbols
{>=} and {=>} are synonyms.

Must be used between two numerical expressions and will return a logical result:

{false} - If the first expression No is bigger or equal than the second.

{certain} - If the first expression YES is bigger or equal than the second.

{Examples:}

  {2+2 >= 5} returns  {false}.ú
  {2+2 >= 4} returns  {certain}.ú

{/}See: {#1000,syntax} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1076,>}

Logical operator [{bigger than}] used in conditions.
Must be used between two numerical expressions and will return a logical result:

{false} - If the first expression No is bigger than the second.

{certain} - If the first expression YES is bigger than the second.

{Examples:}

  {2+2 > 4} returns  {false}.ú
  {2 > 1} returns  {certain}.ú


{/}See: {#1000,syntax} - {#1037,condition}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1077,>>}

Binary operator of {rotation to the right}. This operator is used in the
{#1035,arethmetical expressions}, between two numbers, to obtain the result
of rotation of the first number to the right the number of times how it indicates the second one. 
For example, the following rotation:

  {n} >> {m}

returns  {n} rotated to the right {m} times; each rotation to the left
is equivalent to multiplicate by 2 the number. It means, to rotate to the left 1
time, is equivalent to divide in 2, to rotate to the left 2 times is to divide
in 4, 3 times is to divide in 8, and successively.

Remember that all numbers used in the language are {whole}(without tenth)
therefore always will return the {whole} result of the division (7 divided in 2 will return 3, for example).

or which is equivalent (the {#145,function POW}{(2, m)} returns {2} lifted {m} times):

  {n}/ POW(2, {m})

For example, {16>>3} returns  2, {2>>1} returns 1, {100>>0} returns  100, etc.

{/}

The operator of rotation to the left (operation opposed to this) is the {#1070,symbol <<}.

{/}See: {#1000,syntax} - {#1035,Expression}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1078,>>=}

Operative assignation. Binary operation of {rotation to the right}.

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If is used the symbol{ >>=} in place of {=} to realize the assignation,
will be assigned to the data the result of the following rotation:

  [{previous_value_of_data}] >> [{result_of_the_expression}]

or which is equivalent (the {#145,function POW}{(2, n)} returns {2} lifted in {n}):

  [{previous_value_of_data}] / POW(2, [{result_of_the_expression}])

It means, if the result of the expression is:

  0 -> the data will maintain its value.ú
  1 -> the data will be divided in 2.ú
  2 -> the data will be divided in 4.ú
  3 -> the data will be divided in 8.ú
  ...

Example: {x=8; x>>=2;} -> (x=2)

The result of the rotation to the right will always be a whole number,
without the tenth, it means, the quotient of the whole previous division.

Example: {x=9; x>>=2;} -> (x=2)

{/}

{Note:} This symbol is a simple abreviatura derivated of the {language C};
in any case, a statement of the type {n >>= m;} will be  equivalent to this other {n = n >> m;}.

See the operator {#1077,>>} for more information about the {rotation to the right}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1079,^  [  ]}

Operator of indireccion. This operator requires simple advanced level
technics of programing. The use of pointers is the
characteristic of other languages which, although are very usefull,
does not result necessary to realize the programs because of their difficulty.

The symbol {^} sirves to make reference to a determined position of the memory of the pc.

{Practical case}{/}

For example, if there is one determined variable {my_variable}
with the value {3}, it will be in a direccion of the memory (all
variables have its direccion), the operator {#1085,OFFSET} sirves
to obtain this direccion.

Supposing that exists other denomined variable {direccion_of_my_variable}
in which is contained the direccion of the previous variable, will would be done with the following statement:

  {direccion_of_my_variable = OFFSET my_variable;}

This direccion will be a whole number, for example {12345}; to 
obtain the value of the variable ({3}) or modify it, if we only have
the direccion (position) of the variable in memory (but not its name),
so must be used the operator {^}, the statement will obtain the
value of the variable with help of its direccion:

  {my_variable = ^ direccion_of_my_variable;}

To explain the concepts of {name of variable}, {direccion of the
variable} and {value of the variable} in continuation is shown a
series of expressions and its numerical equivalents.

  {my_variable} = {3}ú
  {OFFSET my_variable} = {12345}ú
  {direccion_of_my_variable} = {12345}ú
  {^ direction_of_my_variable} = {3}ú

The direction of a variable can be changed during it is in use
(adding to it new data and statements).

As resume, {the operator ^ acceeds to the value which is in the
position of the memory of the pc indicated after l}, it means:
  {^ 12345} = {3}ú

That means, that in the direccion {12345} of the memory of the pc
there is a value {3}, because in this direccion {accumulates}
the value of the variable {my_variable} and this is its value.

{/}

The {#1054,symbol *} can be used as {synonym} of {^}
(in the previous example {*12345} = {3}).

The brackets (symbols {[ ]}) function the similar way as operator
{^}, with the only difference, they acceed to the data which direccion is indicated
between of them (in the previous example {[12345]} = {3}).

The brackets also are used to specify the index in the boards and structures.

{/}See: {#1000,syntax} - {#1085,OFFSET}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1081,^=}

Operative assignation. Logical and binary operation of {OR exclusive} ({XOR}).

The {#1019,statements of assignation} is used to calculate expressions and
{assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If is used the symbol{ ^=} in place of {=} to realize the assignation,
will be assigned to a data the following {OR exclusive}:

  [{previous_value_of_data}] XOR [{result_of_the_expression}]

Example: {x=5; x^=3;} -> (x=3)

{/}

{Note:} This symbol is a simple short form derivated of the {language C};
in any case, a statement of the type {n ^= m;} will be  equivalent to this other {n = n XOR m;}.

See the operator {#1082,XOR} for more information about the {OR exclusive}.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1082,XOR  ^^}

Logical and binary operator of {OR exclusive} used in expressions and
conditions.

The reserved word {XOR} and the symbol{ ^^} are synonyms.

{XOR logical:} First are evaluated the conditiones from right to left
of the operator and if {only one} of both is {certain}, this operator returns 
{certain}; in contrary case the operator returns  always {false}.

  false  XOR false  = falseú
  false  XOR certain = certainú
  certain XOR false  = certainú
  certain XOR certain = falseú

Is used to check to be comleted one, only one, of the two
conditions which are specified, for example:

  {(y>0 XOR x>0)}ú

To check the first variable to be bigger than 0, or
('o' exclusive), to be the second one (but not the first).

{XOR binary:} Evaluates the of the results of the anterior
and posterior expressions to the generating operator, as result, a value which will have in 1
only the bits which had in 1 one, and only one, of the expressions.

  0 XOR 0 = 0ú
  0 XOR 1 = 1ú
  1 XOR 0 = 1ú
  1 XOR 1 = 0ú

This rule will applicate to all bits of the numbers (in the language
are whole of the 32 bits).

{/}

{Note:} This operator functions as logical and binary, therefore
in the language are interpreted the logical {certains} expressions as which have
the last bit in 1 (the bit 0, weighing 1), it means, the odd numbers
(1, -1, 3, -3, ...), and as logical {false} expressions which
have the last bit in 0 (the pair numbers: 0, 2, -2, 4, -4, ...).

The operator {XOR} will only leave in 1 the last bit (will only return {certain}
as result} when the both will have it in 1 (when both will be the
expressions {certain}).

{/}

{Note:} The symbol{ ^} can also be used as another synonym of {XOR} and { ^^}.

{/}See: {#1000,syntax} - {#1035,Expression} - {#1037,condition} - {#1083,OR}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1083,OR  ||  |}

Binary operator of {logical sum} used in expressions and
conditions.

The reserved word {OR} and the symbols { ||}and {|} are synonyms.

{OR logical:} First are evaluated the conditiones from right to left
of the operator and if {only one} of both is {certain}, this operator returns 
{certain}; in contrary case the operator returns {false}, (when two conditions are false).

  false  OR false  = falseú
  false  OR certain = certainú
  certain OR false  = certainú
  certain OR certain = certainú

Is used to check to be completed at least one of the 
conditions which are established, for example:

  {(y>0 OR x>0)}ú

To check at least one variable to be bigger than 0, it means 
to be completed the first condition {0} the second.

{OR binary:} Evaluates the bits of the results of the previous and following 
expressions of the operator, generating as result, a value which will have in 1
the bits which had in 1 any of the expressions.

  0 OR 0 = 0ú
  0 OR 1 = 1ú
  1 OR 0 = 1ú
  1 OR 1 = 1ú


This rule will applicate to all bits of the numbers (in the language
are whole of the 32 bits).

{/}

{Note:} This operator functions as logical and binary, therefore
in the language are interpreted the logical {certains} expressions as which have
the last bit in 1 (the bit 0, weighing 1), it means, the odd numbers
(1, -1, 3, -3, ...), and as logical {false} expressions which
have the last bit in 0 (the pair numbers: 0, 2, -2, 4, -4, ...).

The operator {OR} will only leave in 1 the last bit (will only return {certain}
as result} when any of nubers will have it a 1.

{/}See: {#1000,syntax} - {#1035,Expression} - {#1037,condition} - {#1082,XOR}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1084,|=}

Operative assignation. Binary operation of {logical sum} ({OR}).

The {#1019,statements of assignation} sirve to calculate expressions and
to {assign them} to a data.

{#1034,<reference to a data>} {=} {#1035,<expression>} {;}

If is used the symbol{ |=} in place of {=} to realize the assignation,
will be assigned to the data the following {logical sum}:

  [{previous_value_of_data}] OR [{result_of_the_expression}]
Example: {x=5; x|=6;} -> (x=7)
{/}

{note:} This symbol is a simple short form of the {C language},
anyway, a statement of the type {n |= m;} will be equivalent to this
other one {n = n OR m;}.

See the operator {#1083,OR} to further information about the {logic addition}.

{/}

{Note:} Do not confuse this symbol with the [{distinct than}] which is
expressed as {#1046,!=}, and sirve to compare if two expressions
defers in their result.

{/}See: {#1000,syntax} - {#1019,Assignation}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1085,OFFSET}

The reserved word {OFFSET} permits to obtain the direccion of a
data inside the memory of the pc.

All data of a program correspond to one concrete position
of the memory in which it is accumulating its value; the
operator {OFFSET} permit to obtain this position as a numerical value.

This operator is used, mainly, in the parameters of some
functions of the language; it is made to permit to these
functions to modify these parameters.

If there is a variable, for example denominated {my_variable},
with the value {321} and it passes, as parameter, to a function
parameter, to the function passes the number 321; with it,
the function won`t have the possibility to  modify the variable because it knows its value
but not {where it is situated} (there can be a lot of values
{321} in all memory of the pc, and it won`t know which of them is the variable).

If to this function passes as parameter {OFFSET my_variable}
it will be informed from the place in which was accumulated the
value of the variable, so the function can acceed to this value to consult or modify it.

For more information about this operator you can acceed to the
{#1079,operator ^} which realizes the operation inverse to the operator
{oFFSET} (it means, obtains the value which is in determined position of the memory).

{/}

The {#1050,symbol &} can be used as {synonym} of the reserved word {OFFSET}.

{/}See: {#1000,syntax} - {#1079,^}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1086,BEGIN}

This reserved word indicates the beginning of the program, process or function.

It means, the word {BEGIN} is used to separate a zone
of declaracion of data of the main program or of one process,
from the zone of statements.

It is obligatory the declaracion {BEGIN} in the main program and in all processes.

When a program or process is executing, it will be always begun by
the statement which comes in continuation of {BEGIN}.

The statement {BEGIN makes nothing}, sirves only as delimitator
inside of the structure of the programs.

{/}

Each {BEGIN}is vinculated with the {#1091,END} which markes the end of the zone of statements
of the program or process.

{/}See: {#1000,syntax} - {#1015,main code} - {#1016,PROCESS} - {#1408,FUNCTION}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1087,CASE}

This reserved word forms part of the statement {#1021,SWITCH};
is used as beginning of the different sections of statements
which execute or not, depending on the result of the evaluated expression.

Each {CASE} must contain a word {#1091,END} which indicates the end of the section.

The statement {#1021,SWITCH} evaluates an expression and the signification
which has the word {CASE} is "{in the case when the result of
the expression is ..., then must be executes the following statements ...}".

{/}See: {#1000,syntax} - {#1021,statement SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1088,DEFAULT}

This reserved word forms part of the statement {#1021,SWITCH} which
is used as the beginning of a section of statements which must be executed
when the result of the evaluated expression is not contemplated in any of the sections {#1087,CASE} of the statement.

Each {DEFAULT} must put the word {#1091,END} which indicates the end of the section.

The statement {#1021,SWITCH} evaluates an expression; each section
{#1087,CASE} of the statement will contemplate one or more results in which must be
executed the named section and, finally, if appears a
section {DEFAULT} is to express "{in the case when the result of the
expression is not as anyone previous, then must be executed the following statements ...}".

{/}See: {#1000,syntax} - {#1021,statement SWITCH}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1089,DUP}

This word sirves to define {#1013,lists of constants} (numerical values),
repeating one simple model. Is used to initiate the initial values of boards and structures.

Its syntax is the following:

<number of times> {DUP (}<sequence to repeat>{)}

Is equivalent to put the <sequence to repeat> the <number of times> which is indicated.

For example, the sequence {1, 2, 3, 1, 2, 3, 1, 2, 3} will be equivalent to
the sequence {3 DUP (1, 2, 3)}.

{/}See: {#1000,syntax} - {#1013,Definition of a list of constants}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1090,ELSE}

This word forms part of the statement {#1020,IF}, and sirves
to specify where begins the block of statements which must be
executed when the condition specified in the statement {#1020,IF} does not complete.

The format of the statement {#1020,IF} is the following:

{IF (<}condition{>)}ú
    // Code to execute when the condition is completedú
{ELSE}ú
    // Code to execute when the condition {does not} completedú
{END}ú

The semantic signification of {ELSE} is "{in the contrary case ...}".

{/}

The section {ELSE} is optional, the statement {#1020,IF}can be formulated this way:

{IF (<}condition{>)}ú
    // Code to execute when the condition is completedú
{END}ú

When it is not required any statement to be executed {in the contrary case}.

{/}See: {#1000,syntax} - {#1020,statement IF}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1091,END}

This reserved word markes the end of one of the following statements:

  {#1086,BEGIN}ú
  {#1020,IF}ú
  {#1022,WHILE}ú
  {#1021,SWITCH}ú
  {#1087,CASE}ú
  {#1087,DEFAULT}ú
  {#1025,FOR}ú
  {#1043,FROM}ú
  {#1024,LOOP}ú
  {#1030,CLONE}ú

It means, the function of the word {END} is {to delimitate where finishes the statement}.

You must remember that the statements can not be included
ones inside the others, therefore if the program is not 
structured well (tabulating the code), it can result
difficult to understand to which statement corresponds each {END}.

For example, in the following code you can see clearly to which statement belong each {END}.

{BEGIN}ú
    {IF (x>0)}ú
        {x=x-1;}ú
    {END}ú
{END}ú

But this same code can be expressed this way:

{BEGIN}ú
    {IF (x>0)}ú
    {x=x-1;}ú
{END}ú
    {END}ú

resulting more difficult to read the program, although
for the compiler of the language {the both blockes of code are
equal} (the compiler will continue interpreting that the first
{END} belongs to the statement {IF} and the second to the
{BEGIN}, although they are tabulated incorrectly).

{/}See: {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1092,ID}

The reserved word {ID} is used to obtain the {#1039,identification code} of the process during the execution.

A {#1039,identification code} is a numerical value which
{identificates} each active process in each moment.

It means, {ID} is as a numerical constant, but its value
will be different for each process which consults it.

It is not possible to change the value of {ID}, because it is only the object of reading.

Normally, the process acceeds to this value when wants to inform
another processes which is its {#1039,identification code}.

{/}See: {#1000,syntax} - {#1039,Identification codes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1093,SETUP_PROGRAM}

This reserved word sirves to design a special type of
programs, of {configuration of hardware of sound}.

These programs identificate with the reserved word {SETUP_PROGRAM} in place of {#1003,PROGRAM}.

This is really advanced, for users with experience.

You can observe a program of this type in the directory {SETUP}
of DIV Games Studio; these programs, when are compiled, will be included
automatically in the installations of the rest of programs, when
in the process of installation activates the blosk "{Include setup of sound}".

{Note:} In the installations always will be included the last program
of setup which was compiled in DIV Games Studio.

{/}

However, remember that it is not necessary to create programs
of configuration of the sound system, because the games created by DIV Games
Studio will detect automatically if the PC in which are executing
has the sound card compatible with {Sound Blaster}
or {Gravis Ultrasound}, always when it is proper configurated.

{/}

This type of programs often modify the {#1104,global structure setup}, 
which controls the parameters of the sound system.

{/}See: {#1000,syntax} - {#1104,Structure setup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1094,SIZEOF()}

{SIZEOF(}<name of data>{)}

{Return:}

The number of elements which contains the data.

{Descripcion:}

The reserved word {SIZEOF} is used to calculate the number
of elements which has a board or structure.

This reserved word {is used as it were a function} of the language,
indicating, in parenthesis, the {#1001,name} of the data and returning its
number of elements (positions).

It is possible to use it to obtain the number of elements of a
variable but, in this case, {SIZEOF} returns always {1}
as number of elements (because a variable is the only element).

{#9999,program example:}
PROGRAM Example_sizeof;

PRIVATE
    board1[]=0, 1, 2, 3;
    board2[]=4, 5, 6, 7, 8;
    variable=9;

BEGIN
    // ...

    save("help\help.dat", OFFSET board1, SIZEOF(board1)+SIZEOF(board2)+SIZEOF(variable));

    // ...
END
{-}

In this example is used {SIZEOF} to obtain the number of elements
of three different data; they are:

{board1} of {4} elements.ú
{board2} of {5} elements.ú
{variable} ({1} element).ú

In this case is used to record in the archive {help.dat} the
contains of these three data with the function {#155,save()} which
requires, as the third parameter, the number of elements which it wants to save in the archive.

In this case will be saved {10} elements in the archive {help.dat},
which as they are initiated the data in the example will be numbers from {0} to {9}.

The statement {#155,save()} from the previous example could be 
also expressed without using {SIZEOF}:

  {save("help\help.dat", OFFSET board1, 10);}

The only difference is if in the program from the example are added
elements to one of two boards, it will not be necessary to modify the
call to the function {#155,save()}, because {SIZEOF} always returns 
its current size.

{/}See: {#1000,syntax} - {#1011,Declaracion of board} - {#1012,Declaracion of structure}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1095,STEP}

The reserved word {STEP} forms part of the statement {#1043,FROM} and sirves
to indicate the increment which must be made in each iteration of the loop.

The statement {#1043,FROM} implements a loop, it means, a group of
statements which will be repeated the determined number of times; for it,
is used a variable as counter of times of repetions.

Defines the initial value of the variable as the final value, and the
loop repeats until the variable reaches the final value, beginning from the initial value.

By default, the variable will pass by all whole numerical values
found between the initial and final value, but you can indicate a declaracion {STEP} to establish an increment of the
different variable.

For example, if is defined a loop in which the variable {x} will change the
values from {1} to {10}, executes the named loop totally
{10} times, but if is established the step ({STEP}) as {2}
the loop executes only {5} times, when the variable
{x} will have the values {1}, {3}, {5}, {7} and {9}, was 
established that the variable must increment from {2} in {2}. This loop implements this way:

{FROM x=1 To 10 STEP 2}ú
  // statements which will be repeated five timesú
{END}ú

If is omited the declaracion {STEP} of the statement {#1043,FROM}, the
increment will be always from 1 in 1, suming 1 to the variable after each
iteration of the loop (or subtracting 1, when the final value is smaller than initial).

{Note:} Can be established only whole increments.

{/}See: {#1000,syntax} - {#1043,statement FROM}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1096,TO}

The reserved word {TO} forms part of the statement {#1043,FROM} and sirves
to separate the constants which indicate thes initial and final values which will have
variable which is used as the counter of loop.

The statement {#1043,FROM} implements a loop, it means, a group of
statements which will be repeated a determined number of times; for it
is used a variable as counter of the number of repetitions.

Defines the initial value of the variable as the final value, and the
loop repeats until the variable reaches the final value, beginning from the initial value.

{Example:}

  {FROM x=1 TO 10}ú
    // statements which will be repeated 10 timesú
  {END}ú


By default, the variable will pass by all whole numerical values
found between the initial and final value, but you can indicate a declaracion {#1095,STEP} to establish an increment of the
different variable.

{/}See: {#1000,syntax} - {#1043,statement FROM} - {#1095,STEP}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1097,UNTIL}

The reserved word {UNTIL} forms part of the statement {#1023,REPEAT},
which syntax is, in outline, the following:

{#1023,REPEAT}ú
    {#1017,<statement>};ú
    ...ú
{UNTIL (<}condition>}{)}

The statement {#1023,REPEAT} implements a loop, it means, it is capable
to repeat a group of statements a determined number of times.

The end of the statement determines with the reserved word {UNTIL}
followed by the condition which must be completed to {finish the statement}.

{/}See: {#1000,syntax} - {#1023,statement REPEAT}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1100,GLOBAL STRUCT mouse}

{STRUCT mouse;}ú
    {x, y;}                // Coordinatesú
    {graph;}               // Graphic codeú
    {file;}                // File codeú
    {z;}                   // Plan of depthú
    {angle;}               // Anglesú
    {size;}                // Size (%)ú
    {flags;}               // Indicator smoothú
    {region;}              // Region of cutú
    {left, middle, right;} // Mouse stateú
    {cursor;}              // Emulation with cursorsú
    {speed;}               // Speed of mouseú
{END}ú

This global structure sirves to control the mouse; contains
a series of fields relationed with the programing of this
dispositive, as the position of screen, the graphic of pointer,
the state of buttons, etc.

To acceed to these fields must be preceeded the name of the field
by the word {mouse} and the symbol {#1063,. (point)}; for example, to
acceed to the field {x} (coordinate horizontal of the pointer of the mouse)
must be used {mouse.x}.

{/}

{x}, {y} - Coordinates, horizontal and vertical, of the mouse. These two fields
({mouse.x} and {mouse.y}) are the only ones which is necessary to read to
know the position of cursor of mouse in the screen.

To {put the mouse in other coordinates} (force its position),
you only need to assign the new coordinates in these two fields.

{/}

{graph} - {graphic code} assigned as pointer of mouse. By default
{the mouse will be invisible}; to make it visible must be created
the graphic which will serve as pointer in the {graphical editor},
load it in the program (with the function {#132,load_fpg()}, {#174,load_map()} or {#174,load_pcx()}, 
as this graphic was saved in the {file FPG} or in {archive MAP/PCX}), and
assign its {graphical code} to this variable ({mouse.graph}). Then it will be 
visible in the screen.

In the coordinates {mouse.x}, {mouse.y} appears the center of the graphic,
although was defined its {#1136,checkpoint} number {0} 
in the {graphical editor}. If this point defines, commonly denominated
"{hot spot}", will be itself what will appear in the
coordinates indicated in the fields {mouse.x} and {mouse.y}.

For example, if is creating as a picture for a pointer of mouse the
typical arrow (as the pointer of mouse DIV Games Studio), the "hot
spot" (checkpoint number {0}) will be defined in the
superior left corner of the graphic, this is the{active point}
in side the graphic. Then, when the mouse was, for example,
in the coordinates (0, 0), exactly the "{point of arrow}"
will be in these coordinates.

{/}

{file} - {file code} which contains the graphic. In this field defines
the {file code} which contains the graphic of the pointer of mouse.
{It is not necessary}to indicate here the value if the file was loaded from the
{archive MAP or PCX}, or if it is in the first {archive FPG} loaded in the
program. In contrary case, must be assigned to {mouse.file} the
{file code} which returns the function {#132,load_fpg()} after loading the file
which contains the graphic of the pointer of mouse.

{/}

{z} - priority of impression of the graphic. Indicates in which plane of depth
must be painted the graphic of the pointer of mouse. {By default} this field
will value { -512}, that implicates that {the pointer is seen over the rest
of graphics and texts}. As bigger is this field, more depth will have the pointer of mouse. 

If you want the graphic of one process appears
over the pointer of the mouse, must be assigned to the variable
{#1125,local z} of this process a whole number smaller than { -512},
for example{ -600}.

{/}

{angle} - angle with which is seen the graphic of the pointer of mouse.
The value of {mouse.angle} by default is {0}, which implicates that the graphic will not be seen rotated.

Remember than the angles must be specified in
thoundeth of degree, for example, the statement {mouse.angle=90000;} will make the pointer to appear
rotated {90 degree} (see the {#1044,use of angles in the language}).

{/}

{size} - size of the graphic in percentage. By default, this field
will value {100} (the graphic is seen in 100% of its size), and it is not
necessary to indicate here other value if you don`t want the graphic to be changed
(to be enlarged or diminished).

If for example you want the graphic to be twice bigger
as its original size(in 200%), you must use the statement {mouse.size=200;}.

{/}

{flags} - in this field are indicated different values when is
pretended the graphic of mouse to appear smooth (inverted
horizontal or vertical), or you want visualize it as
graphic (semi) transparente. The possible assignable values to the variable {mouse.flags} are:

 {0}-Normal graphic(value by default).ú
 {1}-Inverted horizontal.ú
 {2}-Inverted vertical.ú
 {3}-Inverted horizontal and vertical (180ø).ú
 {4}-Transparent graphic.ú
 {5}-Transparent and inverted horizontal.ú
 {6}-Transparent and inverted vertical.ú
 {7}-Transparent, inverted horizontal and vertical.ú

{/}

{region} - region of the graphic. To this field must be assigned
the value {only when you want the pointer of mouse to be
visible only inside one region} (rectangular zone of the screen);
to reach it you must first define this region with the function
{#106,define_region()} and, then, assign to this field ({mouse.region})
the number of the region which was defined.

By default this value will be {0}, which is the number of region which
refers to the whole screen, therefore the graphic will be visible in all screen.

{/}

{left}, {middle} and {right} - these three fields accumulate logical values
({0} or {1}) by the buttons of mouse are pressed or
not (correspond to the buttons left, middle and right
of mouse). Normally, are activated only two buttons of mouse
({left} and {right}) ignoring the state of the middle button. This
depends on the {driver} of the mouse which is installed in the pc.

For example, to realize in one program an action {when is pressed the left button of the mouse} 
({mouse.left}) must be included the following in the code of statement:

  {IF (mouse.left)}ú
    // Action to realize (statements)ú
  {END}ú

{/}

{cursor} - indicates if is it active the emulation of the mouse with the key
of {Cursors} and {Enter}; when this emulation is activated, you can move the 
pointer with the mouse or with cursors. By default,
this emulation will be disactivated ({mouse.cursor=0;}) if the
program doesn`t detect the mouse connected to the system, in this case
will be activated the emulation automatically (it means, if {mouse.cursor} values
{1} in the beginning of the program, it means there is no mouse connected to the pc).

{/}

{speed} - now it is possible to regulate the speed
of dislocation of the pointer of the mouse in the programs. This is the value
between {0} (maximum speed) and {9} (minimum), by default {mouse.speed}will value  {2}.

{/}See: {#1200,global data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1101,GLOBAL STRUCT scroll}

{STRUCT scroll[9];}ú
    {x0, y0;}    // Coordinates of the first planú
    {x1, y1;}    // Coordinates of the second planú
    {z;}         // Plane of depthú
    {camera;}    // {#1039,Identification code} of the camaraú
    {ratio;}     // Relative speed of the second planú
    {speed;}     // Max speed of the first planú
    {region1;}   // First region of screenú
    {region2;}   // Second region of screenú
{END}ú

This structure of {10} registers contains certain fields relationed
with modificable parameters of the {windows of scroll}. The ten
registers have the same names of fields, but each one
modifies the parameters of one window of scroll different
(because can be activated till 10 windows of this type).

One {window of scroll} can be defined as a region of screen which shows
only one part of the graphic, bigger than this window (this
graphic often is the {decoration} or {background} of the game). The {scroll} is
the movemant of this window in the graphic in any direccion,
visualizing step by step the whole graphic, section by section.

For a register (from {0} to {9}) of the {structure scroll} has sense,
first must be activated this {window of scroll} (from {0} to {9}) with the
function {#163,start_scroll} (see this function for more information about the windows of scroll}.

Remember that the windows of this structure are complementary to the
parameters of call of this last function.

{/}

{Form of use of the structure scroll:}

To acceed to these fields must be preceeded the name of the field
by the word {scroll}, the number of register in brackets and the symbol
{#1063,.} (point).

For example, if are initiating two windows of scroll, the number 0 and the
number 1, we can acceed to the field {camera} from both windows as
{scroll[0].camera} and {scroll[1].camera}, respectively. When we acceed to the window
number 0 of scroll we can, also, omit the number of
windows in brackets, it means, the variable {scroll.camera} and the variable
{scroll[0].camera} are in all senses the same by the language.

{/}

{In continuation is shown a descripcion in details of each field}

{x0, y0} - Coordinates of the first plane of scroll, when it the scroll {NO} is
automatical (didn`t define the fiels {camera}), {these are fields which
must be modified to move the first plane of the window of scroll}.

These two fields accumulate the horizontal and vertical coodinates of the 
superior left coner of the window of scroll (the point of graphic of the first
plane which will be seen in the superior left corner of the window).

When was defined the field {camera} of this structure, the movement
of the window of scroll will be automatical, these fields will be only for read; 
to check where is it situated the scroll in each moment (see the function {#140,move_scroll()}).

{/}

{x1, y1} - Coordinates of the second plan, when were defined a graphic
for the second plan. When the scroll {NO} is automatical (was not defined the
field {camera}), {these are the fields which must be modified to move
the background plane of the window de scroll}.

When was defined the field {camera} of this structure, the movement
of the window de scroll will be automatical, and these fields will be only for read, 
determining the speed of movement of the second plane in function of the field {ratio} of this structure.

{/}

{z} - Priority of impression of the scroll, here indicates in which plane of depth
must be painted this window, with respect of the rest of processes. By default, this
variable will value  {512}, this means, as the processes by default
have their variable {#1125,local z} in {0}, the window of scroll will be painted  in the plan
of more depth, visualizing the graphics of the processes
over the window. To change this situation can be modified the
variable {z} of the window (for example, put it in{ -1}) or the variable {z} of the processes (for example, put it in {600}).

{/}

{camera} - This field is not necessary to initiate it, initiates when
you want the scroll to be {automatical}, the system charges for it
to follow always the process (a graphic of player). For it,
in this field must put the {#1039,identification code} of the process; only
with it, the dislocation of the window of scroll will be controled
automaticaly by the system, intenting to center the graphic of this process
always in the window. This process must have the local variable {#1122,ctype}
with the value {#1168,c_scroll}.

By default, this field will value {0}, this implicates that the scroll will not follow to 
any process, although it assigned the {#1039,identification code} of one to a {camera}. 
When this is made, will denominate this process as the {process camara} of the scroll.

{Note:} In continuation is shown a series of fields {only for windows of
scroll automatical}; it means they will have the sense for the named fields
(and effect) first must be defined the field
{camera} of this structure with the {#1039,identification code} of the process
which will center in the scroll. These values will affect to the form in which will
be done this continuation of the denominated process {camara of the scroll}.

{/}

{ratio} - {Windows of scroll automatical}. When were defined two plans
of scroll in the call to a function {#163,start_scroll()}, in this field
can be defined the {speed of movement of the plane of the background} wth respect
to the first plan. By default, this value will be {200} what will implicate 
the plane of background to be moved in a half of speed of the first plan;
if it is defines as {400} will be moved in a quater part (four times more slow),
{100} to the same speed, {50} to the half of speed than the first plan, etc.

{/}

{speed} - {Windows of scroll automatical}. Speed max of the first plan
of scroll, by default will value  {0}, it means that there is no
limit of speed. If there is the limit, specifying the number of max points
which can dislocate the first plane for each image of the player,  
the {process camara} of the window of scroll will be uncentred when it moves with the bigger speed.

{/}

{region1} - {Windows of scroll automatical}. Region of blocking of the scroll, which
value, by default, is{ -1} which implicates that there is no region of block.
If this field defines with the number of region (a rectangular zone of the screen
defined before with the function {#106,define_region()}), then
the system will not move the scroll while the {process camara} is inside it.

{/}

{region2} - {Windows of scroll automatical}. Exterior region of the scroll; by
default its value is{ -1}, which implicates that there is no exterior region.
If this field defines with the number of region and was defined a {max speed}
in the field {speed}, then the system will ignore this limit of
speed when the process{ camara} will exit from this region (it is made to
lose sight of the process (for its graphic to be always visible inside the window of scroll).

{Note:} If are defined two regions ({region1} and {region2}), normally the region
1 is smaller than the region 2 (is contained in it), this implicates that:

- The graphic will not be dislocated in the depth (won`t make scroll) while the graphic
of the process camara is inside the region 1.

- If was defined a max ({speed}), then will make scroll to
intent to return the graphic of the process camara to the region 1, but without exceeding the imposed limit of speed.

- If the graphic of the process camara intents to exit from the region 2, will ignore the imposed limit of speed, not permit it.

{/}See: {#1200,global data} - {#163,start_scroll()} - {#166,stop_scroll()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1102,GLOBAL STRUCT m7}

{STRUCT m7[9];}ú
    {camera;}   // {#1039,identification code} of the camaraú
    {height;}   // Height of the camaraú
    {distance;} // Distance of the camaraú
    {horizon;}  // Height of horizonú
    {focus;}    // Focus of visionú
    {z;}        // Plane of depthú
    {color;}    // Color of the exteriorú
{END}ú

This structure of {10} registers contains certain fields relationed
with modificable parameters of the {windows of mode 7}. The ten
registers have the same names of fields, but each of them
modify the parameters of a window of mode 7 different
(because can be activated till 10 windows of this type).

A {window of mode 7} can be defined as a region of screen which
shows a graphical three-dimensional plan. For example as
a paper with picture which we put horizontal, visualizing
in screen as virtual floor (or ceiling).

For register (from {0} to {9}) of the {structure m7} has sense,
first must be activated this {window of mode 7} (from {0} to {9}) with the
function {#162,start_mode7()} (see this function for more information about the windows of mode 7}.

The fields of this structure are complementary to the
parameters of call of this last function. To observe an practical example
of the mode 7, you can acceed to the help about the function{#162,start_mode7()}.

{/}

{Form of use of the structure m7:}

For acceed to these fields must be preceeded the name of the field
by the word {m7}, the number of register in brackets and the symbol
{#1063,.} (point).

For example, if are initiating two windows of mode7, the number 0 and the
number 1, we can acceed to the variable {camera} from both windows as
{m7[0].camera} and {m7[1].camera}, respectively. When we acceed to the window
number 0 of mode7 we can, also, omit the number of
windows in brackets, it means, the variable {m7.camera} and the variable
{m7[0].camera} are in all senses the same by the language.

{/}

{In continuation is shown the detailed descripcion of each field}

{camera} - {#1039,Identification code of the process} followed by the camara. To move
the camara which controls the vision of the mode 7, you must only create a process
of the mode 7, a process which has its local variable {#1122,ctype} {=} {#1169,c_m7}, and put
its {#1039,identification code} in the variable {camera} of this structure.
After it, must be only modified the local variables {#1123,x}, {#1124,y} and {#1129,angle} of
this process and, for example, used the function {#101,advance()} to move the camara forward.

The field {camera} is {necessary} to initiate it to
activate the window of mode 7; without this field, the window can be determined
from where must be {seen} the plan.

{/}

{height} - Height of camara. This variable of the structure regulates the
distance in which from the floor is situated the camara, by default its value is {32}.
Any positive number wich put the camara higher when the number is increasing.
If the value in the field {height} of this structure
is negative, smaller than zero, then the camara will be situated under this plane, 
showing the "{ceiling}" instead of "{floor}".

Inside the same region can be created two modes-7 : one
as ceiling and other as floor (one with {height} positive and other with negative). In this case,
it is important to fix the variable {z} of the {#1102,structure m7} of the two,
to determine in which plane of depth must be painted each other.

{/}

{distance} - Distance of the camara from the followed process. The point of view
of the camara is always situated a little bit behind the process which identifier
is put in the field {camera} of the structure. It is made to see the graphic
of the process using as camara, in the case when this process has it defined
(in its local variable {#1126,graph} or {#1132,xgraph}).

By default, the camara is situated in {64} points behind the process. 
"behind" is a point situated in the indicated distance of the graphic
in the contary angle to which is oriented the process; for example, if the
process is looking to the right, 64 points to the left from it.

{/}

{horizon} - Height of horizon. This is the same value which was indicated as
the last parameter of the function {start_mode7()}; its initial value will be which was
indicated in the call to the function. The utility of this variable is the possibility
of horizon to go up and down in each visualization (image) of the player by its necessaty.

After change the{height of horizon} in the {window of mode 7}
will be archieved the effect of "{look up}" and "{look down}".

{/}

{focus} - Focus for the camara. This variable controls the perspective of the
camara; by default, its value is 256 but you can put any value between
{0} and {512}, you will archieve different effects of deformation of the three-dimensional plan.

It means, this field controls the angle which makes the focus of the camara; as bogger is this
value more near will be seen all object (processes) situated in the plan.

{/}

{z} - Priority of impresion of the mode 7, here indicates in which plane of depth
must be painted this window, with respect to the rest of processes. By default, this
variable will value {256} that means, as the processes by default
have their variable {#1125,local z} in {0}, the window of mode 7 will be painted in the plan
of the most depth, visualizing the graphics of the processes
over the window. To change this situation you can modify the
variable {z} of the window (for example put it in{ -1}) or the variable {z} of
the processes (for example put it in {257}).

{/}

{color} - Color for the exterior of the mode 7. When in the call to the function {start_mode7()}
doesn`t specify any {exterior graphic} (is put in {0} the fourth parameter of call), this variable will control in which color you want to paint
the exterior, it means, of which color must be screen excepting the graphic (out of its limits).

This field is initiated by default in {0} which, normally, is the black color
in the palette of colores, therefore, if is not assigned to this field another
value (and is not defines an external graphic) the screen will be seen in black
out of the main plan.

{/}See: {#1200,global data} - {#162,start_mode7()} - {#165,stop_mode7()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1103,GLOBAL STRUCT joy}

{STRUCT joy;}ú
    {left;}    // Control leftú
    {right;}   // Control rightú
    {up;}      // Control upú
    {down;}    // Control downú
    {button1;} // First buttonú
    {button2;} // Second buttonú
    {button3;} // Third buttonú
    {button4;} // Fourth buttonú
{END}ú

This global structure sirves to control the {joystick};
contains a series of logical fields relationed with the programing
of this dispositive that are the state of the buttons (if are pressed or not)
and the state of the four main direcciones of control.

To acceed to theses fields must be preceeded the name of the field
by the word {joy} and the symbol {#1063,. (point)}, for example, to
acceed to the field {left} (which indicates if is it pressed the control left)
you must use {joy.left}.

{/}

{left} - This field will be in {1} when the {joystick} is oriented to the
{left}, and in {0} in contrary case.

{right}  - This field will be in {1} when the {joystick} is oriented to the
{right}, and in {0} in contrary case.

{up}  - This field will be in {1} when the {joystick} is oriented 
{up}, and in {0} in contrary case.

{down}  - This field will be in {1} when the {joystick} is oriented
{down}, and in {0} in contrary case.

For example, to realize in a program an action {when is moving the
joystick to the right} ({joy.right}) in the code must be included the following statement:

  {IF (joy.right)}ú
    // Action to realize (statements)ú
  {END}ú

For the positions in diagonal must be checked two fields which
conform this diagonal; for example, to realize an action when the
{joystick} is in the superior right diagonal will be used the following statement:

  {IF (joy.up AND joy.right)}ú
    // Action to realize (statements)ú
  {END}ú

{/}

{button1}, {button2}, {button3} and {button4} - These fields indicate the state
of four buttons of joystick, being in {1} when is pressed the respective button 
and in {0} when it is not.

Some joystick have only 2 buttons; in this case, will be buttons
number 0 and 1. In the PC with two connected joystick the second joystick
will have the buttons 2 and 3.

{/}

{Note:} When is required analogical reading of the {joystick} (to know the
exact coordinates in which is sutuated the "handle" of the joystick), must be used
the function {#122,get_joy_position()}. This function will be usefull only in
analogical {joystick}, will not function in the digitals.

{/}See: {#1200,global data} - {#122,get_joy_position()} - {#121,get_joy_button()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1104,GLOBAL STRUCT setup}

{STRUCT setup;}ú
    {card;}     // Type of cardú
    {port;}     // Port of accessú
    {irq;}      // Interruption requiredú
    {dma;}      // Channel of access to memoryú
    {dma2;}     // Channel of access of 16 bitú
    {mixer;}    // Type of mixerú
    {rate;}     // Max frequencyú
    {bits;}     // Quality 8 or 16 bitsú
    {master;}   // Master volume (general)ú
    {sound_fx;} // Volume of the effectsú
    {cd_audio;} // Volume of music CDú
{END}ú

This structure of data is very advanced level it is not necessary
to create a game, because of its complicity, the
manager of processes of DIV Games Studio will encharge of the hardware
of sound the transparente way.

All fields referent to the hardware of sound actualize 
automaticaly by the program if it has the sound card, always and
when it has the initiated variable of environment {BLASTER} or {GRAVIS}.

This structure of only one register contains a series of fields divided
in two groups: the first to activate new parameters of the hardware of
sound installed in the PC and the second to put in order the different
controls of volume managed by the mixer ({mixer}) of the sound system.

{/}

{Important:}

To activate the new parameters of the hardware of sound which are introduced
in this structure must be called to the function {#175,reset_sound()}.

To activate the new levels of volume which are introduced in the structure
(in the fields {master}, {sound_fx} and {cd_audio}) must be called to the function {#178,set_volume()}.

This structure is used generally inside the programs of configuration
of the sound system (See {#1093,setup_program}).

{Note:} To acceed to these fields must be preceeded the name of the field
by the word {setup} and the symbol {#1063,. (point)}; for example, to
acceed to the field {master} (which indicates the level of general volume of the mixer) must be used {setup.master}.

{/}

It is shown, in continuation, more detailed description of each of the
fields of this structure.

{card} - Indicates the type of sound card installed in the PC.
The program admits cards of the families {Sound Blaster} (tm) and {Gravis Ultra
Sound} (tm) and all which are compatible {100%} with these.

The values which can take this field are the following, depending on the type
of sound card:

    Without card or sound = {0}ú
    Sound Blaster 1.5        = {1}ú
    Sound Blaster 2.0        = {2}ú
    Sound Blaster Pro        = {3}ú
    Sound Blaster 16         = {4}ú
    Sound Blaster AWE        = {5}ú
    Gravis Ultra Sound       = {6}ú
    Gravis Ultra Sound MAX   = {7}ú

{/}

{port} - Indicates the port of comunications of the PC in which must be written
and read the data of the sound card.

The values which can have this field are the following, depending on the
port assigned to the hardware of sound:

    0x210 = {0}ú
    0x220 = {1}ú
    0x230 = {2}ú
    0x240 = {3}ú
    0x250 = {4}ú
    0x260 = {5}ú

{/}

{irq} - This field indicates the number of interruption or IRQ (Interrupt request)
assigned to the active sound card.

The values which can have this field are, depending on the interruption
used by the card, the following:

    IRQ 2   = {0}ú
    IRQ 3   = {1}ú
    IRQ 5   = {2}ú
    IRQ 7   = {3}ú
    IRQ 10  = {4}ú
    IRQ 11  = {5}ú
    IRQ 12  = {6}ú
    IRQ 13  = {7}ú
    IRQ 14  = {8}ú
    IRQ 15  = {9}ú

{/}

{dma} - In this field must be indicated the number of channel of direct access
to memory (DMA) which uses the sound card.

This field can have values from 0 to 10, depending directly on the number of channel.

{/}

{dma2} - Some sound cards dispose of a second channel of direct
access to memory faster than the previous, of 16 bits, denominated
commonly HDMA, DMA2 or DMA16.

As the last field of this structure, it can have values from 0
to 10 depending on the number of channel of 16 bits used by the card.

{/}

{mixer} - Type of mixer used by the sound system, can be one of these two constants:

  {fast_mixer} - Fast mixer of two channels of sound (1).ú
  {quality_mixer} - Max quality mixer (2).ú

By default, all programs will have activated the fast mixer
({setup.mixer=fast_mixer;}) because this is the faster mode, and the difference
in quality is very big.

{/}

{rate} - Max permited frequency (bit rate), between {11025} (the min permited quality of sound)
and {44100} (quality CD). By default, all programs configurate
in 44100 ({setup.rate=44100;}), but it can be changed, because with the best quality, 
the sound system will be slower, and processor consumes more time.

The value specified in {setup.rate} is the {max quality}
of sound, it means all loaded effects of sound will
adapt to this quality if they have one bigger. It means, the effects
saved to a frequency of 11025 will play with poor quality, although
the max permited frequency is bigger.

{/}

{bits} - Resolution of the examples of the digital effects and musical moduls,
this field can have as value one of these constants:

  {sound_bits_8} - Examples of 8 bit.ú
  {sound_bits_16} - Examples of 16 bit.ú

The effect is similar to the value specified in the field {rate}, the sounds with {8 bit} sound
worse (and occupy less space) and those of {16 bit} are of higher quality. The value
indicated in {setup.bits} indicates the max depth of example.

By default, all programs activate the examples of {16 bit}
({setup.bits=sound_bits_8;)), because the difference in quality is very considerable.

{/}

{master} - This field contains the general volume or master of
exit from the card. Here must be indicated the number between 0 (min volume) and 15 (max volume)
The value by default is {15}, the max volume.

If is diminished the master volume will affect on the volume of the sound effects
and on the volume of reproduccion of the music of CD and audio.

{/}

{sound_fx} - This field controls the volume from which the sound effects which
execute with the function {#159,sound()} are reproduced.

This volume is independent from the used with the function of sound
being, this volume, general for all the sound effects and indicating
in the functions the specifity of each sound.

This field also can be changed from 0 (min volume) to 15 (min volume)
being the value by default the max volume.

{/}

{cd_audio} - This field controls the volume of the music which is reproduced
by the tracks of audio of a CD ROM or of a Compact disk.

Equally as two previous fields, this field also can be changed between
0 (min volume) and 15 (max volume) being the value by default the max volume.

{/}See: {#1200,global data} - {#175,reset_sound()} - {#178,set_volume()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1105,GLOBAL timer[]}

{timer[9];} // Counter of time{/}

This a global board with 10 positions, from {timer[0]} to {timer[9]},
and each one of these 10 positions is a counter of {hundredth of second} which
increment automatically.

In the beginning of the program these 10 counteres will be put in zero. It is used
to count the time inside one program, for it can be put in zero each moment.

There are 10 counters for user can dedicate each one of them
to realize different counts of game; it is indifferent which of
10 counters to use. Normally, if the program needs only one counter
(in the major of ocassions) normally is used the number {0} ({timer[0]}), because the
language permits to omit the zero in brackets in this case, it means,
if it needs only one counter, can be simple used {timer}.

For example, to implement a process which  5 seconds later after  the beginning of its
execution (after being called) realizes a determined action, 
it will be made in the similar way (using, for example,the counter timer[9]):

 {PROCESS process_Example();}ú
 {BEGIN}ú
     {timer[9]=0;}ú
     // ...ú
     {LOOP}ú
         {IF (timer[9]>=500)}ú
             // Action to realize ...ú
         {END}ú
         // ...ú
         {FRAME;}ú
     {END}ú
 {END}ú

{/}

{Note 1:} As the account realizes in hunderdth of second, in each image of the game
these counters can be incremented in {1} hunderdth, {2}, {3}, {4}, etc., it means,
as in the previous example we can not wait the {timer[9]} to be
exactly the same as {500}, because the image could indicate {497} passed hunderdth
(from it stay in zaro with {timer[9]=0;}) and the following
image {502} hunderdths, without passing by the value {500}.

{/}

{Note 2:} It is also important to say that must be taken the precaution measures
in the program not to be some processes using the same counter for different things.

If, for example, creates a {process_example()} (as the last), in each image of the game
they will never execute the action of the five seconds, because
each one of them would put in {0} the counter {timer[9]} in the beginning
of their invalid execution.

Remembering that the counter timer[9] is {#1006,GLOBAL}, it means, it is the same for
all processes of the game, if one process put it in {0}, the rest of processes put it also in {0}.

{/}

{Note 3:} Be carefull with the conditions similar
to those of the last example ({IF (timer[9]>=500) ... }) because these conditions
will never activate {once in 5 seconds}, but will activate
{all the times after the firsts 5 seconds}.

To understand this problem better, in continuation is shown a process
which realizes an action, {only once}, five seconds later after the begin of the execution.

 {PROCESS process_example();}ú

 {PRIVATE}ú
     {action_realized=FALSE;}ú

 {BEGIN}ú
     {timer[9]=0;}ú
     // ...ú
     {LOOP}ú
         {IF (timer[9]>=500) AND NOT action_realized)}ú
             // Action to realize ...ú
             {action_realized=TRUE;}ú
         {END}ú
         // ...ú
         {FRAME;}ú
     {END}ú
 {END}ú

Is used a private variable denominated {action_realized} which, in the beginning,
will be {false}. To realize the action now will require 
to pass more than five seconds and {the action not to be realized}.
After realize it will put the variable {action_realized} in {certain}.

For in the last example execute the action {each five seconds}
(indefinitely), all you need is to put the statement {timer[9]=0;}
after the {action to realize}, in this case it is not necessary the private variable
{action_realized} because will be necessary other {5} seconds for
{timer[9]} to be once more bigger or equal than {500}.

{/}See: {#1200,global data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1106,GLOBAL text_z}

{text_z=-256;} // plane of depth of the texts{/}

In the global variable indicates the plane of depth in which must appear
the texts in screen, which must appear over and down the texts.

The plans of depth can be of any whole number inside of
the rank ({#1177,min_int} ... {#1178,max_int}) and, as bigger is the number so 
bigger will be the depth of the text or graphic.

The graphics of the processes have their variable {#1125,local z} in {0} by
default, the texts {text_z} in{ -256} and the pointer of mouse has
{#1100,mouse.z} in{ -512} by default.

That means, that by default, if these values don`t modify,
will appear the texts over the graphics of the processes and the pointer of the mouse over the texts.
For example, if you want the texts to appear over the pointer
(the contrary to the established by default), can be made two things:

{a)} Situate the plane of the pointer down the plane of texts (a
bigger number), as for example: {mouse.z=-200;} (because{ -200} is the bigger number
than{ -256}).

{b)} Situate the plane of the texts over the plane of the pointer, as
for example {text_z=-600;} because{ -600} is the smaller number than{ -512} and,
therefore, a smaller plane of depth.

{/}

{Note 1:} The variable {text_z} is {#1006,GLOBAL} for all texts, it means, 
can not be defined texts in different plans of depth.

{Note 2:} The texts can be printed only with the function {#171,write()}
(texts alfanumerical) or with the function {#172,write_int()} (numerical values of the variables).

{/}See: {#1200,global data} - {#171,write()} - {#172,write_int()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1107,GLOBAL fading}

{fading=FALSE;} // indicator of fading of screen{/}

This global variable indicates if it is realizing fading of screen
(a gradual variation of the palette of colores of the game) in the determined moment
which value will be :

{#1152,false (0)} - If is {not} realizing the fading.

{#1151,true (1)} - If is realizing a fading.

The goal of this variable is to determine when was finished
a fading of screen initiated with the functions {#110,fade()} or {#112,fade_on()}.

After using these functions wil be initiated a fading of the colors of the palette
which will gradually approach to the definitive colors in the following
frames of the game, it means, each statement {#1029,FRAME} realize  one
part of the fading.

When is initiating a fading, the variable {fading} will automatically pass to
value {certain} (1) and after finishing it will return to its original value,
{false} (0).

{/}

{Note 1:} Generally, this variable is use to control the function {#110,fade()},
and check if it finished to execute (if it finished realize
the fading); when you want, for example, stop the execution of the program
before is finished the fading, this can be done with the statement as
the following (just in continuation of the call to the function {#110,fade()}):

  {WHILE (fading)}ú
      {FRAME;}ú
  {END}ú

Literally this statement defines: "{while is realizing the
fading, must be visualized other new frame}".

{Note 2:} All programs realize a fading ({#112,fade_on()}) in the beginning
of their execution (automatically), therefore this variable will be put in
{certain (1)} in the beginning of all programs before is finished this initial
fading (while continues the "{ignition}" of screen).

{/}See: {#1200,global data} - {#110,fade()} - {#112,fade_on()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1108,GLOBAL shift_state}

{shift_state=0;} // state of the special keys{/}

In this global predefined variable global indicates the state of different special keys
as the keys [{ALT}], [{control}], etc.

Each one of them has an assigned code which is the following:

key SHIFT or capital right          = {1}ú
key SHIFT or capital left        = {2}ú
keys CONTROL                            = {4}ú
keys ALT and/or ALT GR                     = {8}ú
key BLOQ DESPL or block dislocation = {16}ú
key BLOQ NUM or of numerical block       = {32}ú
key BLOQ MAYUS or block of capital  = {64}ú
key INSERT                               = {128}ú

The variable {shift_state} will contain the {sum of all codes of the
keys which are pressed or activated}.

For example, if we press the key [{ALT}] and activate the key
[{BLOQ MAYUS}], the variable {shift_state} will have the value {72} (8+64).

To check if one key as [{ALT}] is pressed, you can not check
{shift_state} to be equal to {8}, because this implicates that [{ALT}] is
the {only} special key which is pressed or activated.

To realize this checking correctly it must be realized this way:

  {IF (shift_state AND 8 == 8)}ú
      // Is pressed the key [ALT] ...ú
  {END}ú

{/}

{Note:} normally, to check if one key is pressed, is used the
function {#128,key()}. But with this function we can determine if
keys as {BLOQ MAYUS} are activated, only if are pressed or not.

Exist two variables which contain the code of the last key which was pressed;
{#1110,scan_code} and {#1109,ascii}.

{/}See: {#1200,global data} - {#128,key()} - {#1109,ascii} - {#1110,scan_code}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1109,GLOBAL ascii}

{ascii=0;} // Code ASCII of the last pressed key{/}

This global variable indicates always the code ASCII of the {last pressed key}
in the thes frame of the game.

The variable {ascii} will be in {0} if was not pressed any key in the last frame of the game.

The codes ASCII are the relation of the characters (letters, digits and symbols)
from {0} to {255} which were converted in standart. The codes
inferior than 32 are the denominated character of control, from 32 to
127 are the game of international character and, beginning with 128,
appears the game of extended character (by the standard of PC).In
continuation, are shown the characters ASCII, international and extended.

{Resume of codes ASCII standard of PC}{/}033 21{ !}³097 61{ a}³161 A1{ ¡}³225 E1{ á}ú
034 22{ "}³098 62{ b}³162 A2{ o}³226 E2{ â}ú
035 23{ #}³099 63{ c}³163 A3{ £}³227 E3{ ã}ú
036 24{ $}³100 64{ d}³164 A4{ ¤}³228 E4{ ä}ú
037 25{ %}³101 65{ e}³165 A5{ ¥}³229 E5{ å}ú
038 26{ &}³102 66{ f}³166 A6{ ¦}³230 E6{ æ}ú
039 27{ '}³103 67{ g}³167 A7{ §}³231 E7{ ç}ú
040 28{ (}³104 68{ h}³168 A8{ ¨}³232 E8{ è}ú
041 29{ )}³105 69{ i}³169 A9{ ©}³233 E9{ é}ú
042 2A{ *}³106 6A{ j}³170 AA{ ª}³234 EA{ ê}ú
043 2B{ +}³107 6B{ k}³171 AB{ «}³235 EB{ ë}ú
044 2C{ ,}³108 6C{ l}³172 AC{ ¬}³236 EC{ ì}ú
045 2D{ -}³109 6D{ m}³173 AD{ ­}³237 ED{ í}ú
046 2E{ .}³110 6E{ n}³174 AE{ ®}³238 EE{ î}ú
047 2F{ /}³111 6F{ o}³175 AF{ ¯}³239 EF{ ï}ú
048 30{ 0}³112 70{ p}³176 B0{ °}³240 F0{ ğ}ú
049 31{ 1}³113 71{ q}³177 B1{ ±}³241 F1{ ñ}ú
050 32{ 2}³114 72{ r}³178 B2{ ²}³242 F2{ ò}ú
051 33{ 3}³115 73{ s}³179 B3{ ³}³243 F3{ ó}ú
052 34{ 4}³116 74{ t}³180 B4{ ´}³244 F4{ ô}ú
053 35{ 5}³117 75{ u}³181 B5{ µ}³245 F5{ õ}ú
054 36{ 6}³118 76{ v}³182 B6{ ¶}³246 F6{ ö}ú
055 37{ 7}³119 77{ w}³183 B7{ ·}³247 F7{ ÷}ú
056 38{ 8}³120 78{ x}³184 B8{ ¸}³248 F8{ ø}ú
057 39{ 9}³121 79{ y}³185 B9{ ¹}³249 F9{ ù}ú
058 3A{ :}³122 7A{ z}³186 BA{ º}³250 FA{ ù}ú
059 3B{ ;}³123 7B{ {{}}³187 BB{ »}³251 FB{ û}ú
060 3C{ <}³124 7C{ |}³188 BC{ ¼}³252 FC{ ü}ú
061 3D{ =}³125 7D{ {}}}³189 BD{ ½}³253 FD{ ı}ú
062 3E{ >}³126 7E{ ~}³190 BE{ ¾}³254 FE{ ş}ú
063 3F{ ?}³127 7F{ }³191 BF{ ¿}³255 FF{ ÿ}ú
064 40{ @}³128 80{ }³192 C0{ À}ú
065 41{ A}³129 81{ }³193 C1{ Á}ú
066 42{ B}³130 82{ }³194 C2{ Â}ú
067 43{ C}³131 83{ }³195 C3{ Ã}ú
068 44{ D}³132 84{ }³196 C4{ Ä}ú
069 45{ E}³133 85{ }³197 C5{ Å}ú
070 46{ F}³134 86{ }³198 C6{ Æ}ú
071 47{ G}³135 87{ }³199 C7{ Ç}ú
072 48{ H}³136 88{ }³200 C8{ È}ú
073 49{ I}³137 89{ }³201 C9{ É}ú
074 4A{ J}³138 8A{ }³202 CA{ Ê}ú
075 4B{ K}³139 8B{ }³203 CB{ Ë}ú
076 4C{ L}³140 8C{ }³204 CC{ Ì}ú
077 4D{ M}³141 8D{ }³205 CD{ Í}ú
078 4E{ N}³142 8E{ }³206 CE{ Î}ú
079 4F{ o}³143 8F{ }³207 CF{ Ï}ú
080 50{ P}³144 90{ }³208 D0{ Ğ}ú
081 51{ Q}³145 91{ }³209 D1{ Ñ}ú
082 52{ R}³146 92{ }³210 D2{ Ò}ú
083 53{ S}³147 93{ }³211 D3{ Ó}ú
084 54{ T}³148 94{ }³212 D4{ Ô}ú
085 55{ U}³149 95{ }³213 D5{ Õ}ú
086 56{ V}³150 96{ }³214 D6{ Ö}ú
087 57{ W}³151 97{ }³215 D7{ ×}ú
088 58{ X}³152 98{ }³216 D8{ Ø}ú
089 59{ Y}³153 99{ }³217 D9{ Ù}ú
090 5A{ Z}³154 9A{ }³218 DA{ Ú}ú
091 5B{ [}³155 9B{ }³219 DB{ Û}ú
092 5C{ \}³156 9C{ }³220 DC{ Ü}ú
093 5D{ ]}³157 9D{ }³221 DD{ İ}ú
094 5E{ ^}³158 9E{ }³222 DE{ Ş}ú
095 5F{ _}³159 9F{ }³223 DF{ ß}ú
096 60{ `}³160 A0{ }³224 E0{ à}{/}

A code ASCII makes reference, therefore, to the {character which was produced
with the last press on key-board} (or combination of presses, for example
letters with accent).

{/}

{Important:} Exists other global predefined variable, denominated {#1110,scan_code}, which
also contains the code of the last pressed key but, in difference from {ascii},
it saves the {scan code} of the key, it means,
it indicates {which key was pressed} and but not {which character was enerated} by itself(as {ascii}).

Exists a serie of constants which design these {#1176,code of keys} (scan codes of
key-board). Acceed to the help about these {#1176,codes of keys}
to observe, also, a {program example} with the variables {ascii} and {scan_code}.

Normally, to check if one key is pressed, is used
only the function {#128,key()} of the language, which receives as parameter
one of these {#1176,code of keys}, and returns {0} if the key wasn't pressed 
or {1} if it was.

{/}See: {#1200,global data} - {#1110,scan_code} - {#128,key()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1110,GLOBAL scan_code}

{scan_code=0;} // Scan code of the last pressed key{/}

This global variable indicates always the scan code of the
{last pressed key} in the last frame of the game.

The variable {scan_code} will be in {0} if was not pressed any key in the last frame of the game.

This variable is used many times to wait in a program for the user
to press a key (any), with such statement:

  {WHILE (scan_code == 0)}ú
      {FRAME;}ú
  {END}ú

This statement indicates that while was pressed one key in the last frame
(while {scan_code} was equal than {0}), the frames of the game must continue
visualizing.

The {scan codes} are a numerical relation of the 
keys of the PC; these can be changed (of one key)
from one key-board to another, because there are key-boards of different languages, with the
different number of keys, etc.

But are maintained constants almost all codes of the main
keys. There is predefined list of constants (synonyms for these codes)
in the language which can be seen acceeding to the help about {#1176,key codes}
(or scan codes of the key-board); are these numerical values
which will be assigned to the variable {scan_code} when the
respective keys will be pressed in the program.

{/}

{Important:} Exists other global predefined variable, denominated {#1109,ascii}, which also
contains the code of the last pressed key but, in difference with {scan_code},
it saves the {code ASCII} (character) generated by the key, it means,
it indicates {which character generated the last pressed key} and not which {key
was pressed} (as {scan_code}).

Acceed to the help about the {#1176,key codes} to observ a
{program example} with the variables {ascii} and {scan_code}.

Normally, to check if one key is pressed, is used
only the function {#128,key()} of the language, which receives as parameter
one of these {#1176,code of keys}, and returns {0} if the key wasn't pressed 
or {1} if it was.

{/}See: {#1200,global data} - {#1109,ascii} - {#128,key()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1111,GLOBAL joy_filter}

{joy_filter=10;} // Filter applied to the joystick{/}

This global variable is used to define the filter applied to the
written coordinates of the joystick.

It defines as a percentage from {0 %} to {99 %}; by default {joy_filter}
will value {10} (will apply a filter of 10%).

The utility to apply this filter to the coordinates of the joystick is to soften the
movements and avoid possible "{tops}" in the reading
of the coordinates; these coordinates of the joystick must be obtained with the
function {#122,get_joy_position()}. The variable {joy_filter} will be only usefull 
when is using this last function.

As bigger is the applied filter more soft will be its movements, 
but also will respond slowly.

Because the function of this "{filter}" is something difficult to understand,
it is shown here an example.

{#9999,Program example:}
PROGRAM Example_joy_filter;
BEGIN
    write(0, 0, 0, 0, "joy_filter=");
    write_int(0, 70, 0, 0, offset joy_filter);
    write(0, 160, 180, 1, "The graphic shown in the coordinates of the joystick");
    write(0, 160, 190, 1, "Use keys up/down to change the filter");
    load_fpg("help\help.fpg");
    put_screen(0, 1);
    graph=100;
    LOOP
        IF (scan_code==_up AND joy_filter<99)
            joy_filter++;
        END
        IF (scan_code==_down AND joy_filter>0)
            joy_filter--;
        END
        x=get_joy_position(0);
        y=get_joy_position(1);
        FRAME;
    END
END
{-}

This program prints the graphic of a ball in the coordinates returned by
the main joystick with help of the function {#122,get_joy_position()}.

You can see how, for small values of {joy_filter}, are produced
many "{tops}" (irregutherities) in the reading, and how for very big values
(as 95%) produces a reading of the coordinates much more soft, but a little bit later.

{Note:} It is obligatory to have a joystick (or gamepad) connected to the PC
for this variable has the utility. If the joystick connects during the
execution of the program, the system will not detect it (must be connected from the beginning). 
See the global variable {#1112,joy_state}.

{/}See: {#1200,global data} - {#122,get_joy_position()} - {#1112,joy_state}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1112,GLOBAL joy_state}

{joy_state=0;} // state of the joystick{/}

In this global variable indicates the state of the joystick (or gamepad) connected
to the PC. The values which takes this variable by default are:

{0} - If the system of reading of the joystick is disactivated. This value
means that was found any joystick connected to the PC in the beginning
of the execution of the program, or that it was disconnected.

{1} - If the system of reading of the joystick is active. This is the initial value
by default, but if disconnects the joystick (or there is noone
connected), disactivates the system of reading (indicating a {0}
in the variable joy_state).

If the system is disactivated, you can return to activate it assigning
once more one {1} to {joy_state} (with the statement {joy_state=1;}), but if in a limited time
was not detected a joystick, the system will return to disactivate.

{/}

Exists a {special mode} in which the system of reading of the joystick {will never
disactivate}; this mode defines {assigning a 2 to joy_state}.

  {joy_state=2;} // Active special modeú

However, you must be carefull because if the system of reading of the
joystick is activated of this mode, without connected joystick to the PC, {can
slow down the execution of the game}.

{/}

{Note:} The reading of the joystick is often realized in the programs acceeding
to the {#1103,global joy structure} which indicates, always, its direccion
and the state of its buttons (if are pressed or not).

{/}See: {#1200,global data} - {#1103,structure joy} - {#1111,joy_filter}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1113,GLOBAL restore_type}

{restore_type=complete_restore;} // type of restoration{/}

This global variable indicates the type of restoration which must be realized
after each frame in the screen.

Is called {restoration of the background} to recuperate the zones of screen
in which were painted graphics or written texts in the anterior image,
it means, "{dispaint}" the graphics and "{diswrite}" the texts (rub out them).

There are three types of applicable restoration which correspond, directly,
with three constants which can be assigned to the variable {restore_type}.

{#1172,no_restore}       - The faster, does not restore the background (-1)ú
{#1173,partial_restore}  - Middle, restore partial (0)ú
{#1174,complete_restore} - The slower, complete restore (1)ú

By default, the value of {restore_type} is {complete_restore}, it means,
if doesn`t indicate other value in this variable realizes a complete restoration
of screen after each frame of the game.

This modality of restoration (complete) is the faster of the three, therefore
can be won the speed of execution in the game (to go more fluent
in the slow PC), if assigns other value to this variable.
For example, to indicate a partial restore, must be used the following statement:

  {restore_type=partial_restore;}

With it indicates to the manager of processes de DIV Games
Studio which after the next frames of the game, must be restored partial
in the background of the screen (only the zones over which were put
graphics and texts).

The faster modality is {no_restore} (no restore the background of the screen);
but, this is applicable only when the game develops inside one
window of scroll or of mode 7 which occupies all screen. In contary case
the graphic will leave shadows (of the last frames) after moving by screen.

Can be changed the modality of restoration during the execution of a
program so much times as are necessary, by the requirement of the
fases (or sections) which executes in each moment.

{/}

{Note:} Exists other global variable relationed also with management which DIV
Games Studio realizes of the screen; this is {#1114,dump_type} which defines
the type of {overturn} of frames which must be realized (which information must be
sent to screen after each frame of the game).

{/}See: {#1200,global data} - {#1114,dump_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1114,GLOBAL dump_type}

{dump_type=complete_dump;} // type of overturn{/}

This global variable indicates the type of dump of frames to screen
which must be realized in each frame of the game.

Is denomined {dump} when are sent the frames of the game
to the monitor (to the video memory of the graphical card).

{/}

There are two applicable types of dump which correspond, directly,
with two constants which can be asigned to the variable {dump_type}.

{#1170,partial_dump} - Will realize {partial dump} if it indicates
with the following statement:

  {dump_type=partial_dump;}

In this mode, will overturn in screen only the graphics which actualize,
which changed with respect of the last frame. This dump it is necessary to activate it
{to win the speed} when programs a game (or its section) 
without a window of scroll or mode 7 which occupies all screen,
it means, when the game shows the movements of graphics on the fixed
background or when the active windows of scroll or mode 7 are smaller than screen.

{#1171,complete_dump} - Will realize {complete dumps} if it is indicated with the following statement:

  {dump_type=complete_dump;}

In this mode, will be overturned all screen without import if the graphics
were changed or not. This is too slow as the {partial dump}, but
exactly it must be used when the game will have a window of scroll or mode 7
which occupies all screen.

{/}

By default, the value of {dump_type} is {complete_dump}, it means,
which is not indicated other value in this variable will realize {complete dumps} 
of the screen after each frame of the game (it is often {more slow} than the partial dumps}).

Can be changed the modality of dump during the execution of a
program so much times as it is necessary, by the requirements of the
fases (or sections) which are executing each moment.

{/}

{Note:} Exists other global variable relationed also with the management which DIV
Games Studio realizes of the screen; this is {#1113,restore_type} which defines
the type of {restoration} which must be realized in the screen after each frame
of the game (which graphics and which texts must be rubed out).

{/}See: {#1200,global data} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1115,GLOBAL max_process_time}

{max_process_time=500;} // Max time of execution{/}

The programs have  a {anti-block} mechanism which
makes the manager of processes of DIV Games Studio interrupt its
execution when a process exceeds its {max time of execution}
in a frame of the game.

This max time is indicated in the global variable
{max_process_time} in {hunderdth of second}; its value by
default is from {500 hunderdth} ({5 seconds}).

It means, when a process lates the time indicating it 
during the execution of statement {#1029,FRAME} (which indicates that the process
is yet prepared for the next frame of the game), will be produced an error of execution.

{Note:} The utility which has the possibility to change this variable, asigning
to it the new value, in the programs in which exists a
process, must be realizing the calculations during enough time,
to be not produced this error.

To indicate the manager of processes, for example, which must not
interrupt a process, although tey are more than 30 seconds 
executing in a frame must be used a statement as the following:

  {max_process_time=3000;}

Because 30 seconds are 3000 hunderdth of second.

{/}

{Important:} Remember that all PCs
are late the same time realizing the calculations of the program, therefore this value must be defined
with certain margin, not to exceed {the max time of execution}
when the game is executing in the slow PCs.

{/}See: {#1200,global data} - {#1029,statement FRAME}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1116,LOCAL STRUCT reserved}

{STRUCT reserved;}ú
    {process_id;}     // Identifier of the processú
    {id_scan;}        // Index of processesú
    {process_type;}   // Type of processú
    {type_scan;}      // Index of typesú
    {state;}         // State of the processú
    {param_offset;}   // Direccion of the parametersú
    {program_index;}  // Counter of programú
    {is_executed;}    // Process executedú
    {is_painted;}     // Rrocess paintedú
    {distance_1;}     // Reserved mode 7ú
    {distance_2;}     // Reserved mode 7ú
    {frame_percent;}  // Percentage of frameú
    {box_x0, box_y0;} // Beginning of the graphic of processú
    {box_x1, box_y1;} // End of the graphic of processú
    {m8_object;}      // Object inside the world m8ú
    {old_ctype;}      // Old Ctypeú
    {f_count;}        // Counter of accumulating of functionú
    {caller_id;}      // Process or function callerú
    {stack_pointer;}  // Stack pointer of the processú
{END}ú

In this structure there are distinct {variables of internal use}
(used by the {manager of processes of DIV Games Studio}).

Are local variables reserved for a system. It is not necessary
to know these variables because the major part are not usefull
in the creation of programs.

{Important:} Modify the values of these variables will provoke,
very probable, a {block} of the PC, unnecessary function of
the {manager of processes} or problems using many of the
internal functions. We don't take any responsability
about the possible problems from the incorrect use
of the {reserved} structure.

{/}

Will be shown therefore a {short descripcion} of each one of these
fields, only with documentary goals.

{process_id} - {#1039,Identification code} of the process; this value is
obtained normally with the reserved word {#1092,ID} and must not be
modified the value of this field.

{id_scan} - is used internally after detect the collisions to
save the register of the {#1039,identification code} of the last process which had
the collision with the current process.

{process_type} - type of the current process, which is
normaly obtained with the operator {#1042,TYPE}, indicating the name
of the process in continuation (See {#1042,types of processes}).

{type_scan} - is used internally to detect collisions
and obtain identification codes of processes of one determined type.

{state} - current state of the process. The values which can
adopt this field are the following:

  {0} - process unexistent.ú
  {1} - process which received the signal {s_kill}.ú
  {2} - process working or awaken (s_wakeup).ú
  {3} - process slept (s_sleep).ú
  {4} - process frozen (s_freeze).ú

{param_offset} - direccion of the memory of the PC in which are
situated the parameters which received the process.

{program_index} - counter of program. Direccion of the memory of the PC
in which is situated the first statement which must execute the process in the next frame.

{is_executed} - indicates if this process yet executed the current frame.

{is_painted} - indicates if the graphic of the process was yet painted in the current
frame of the.

{distance_1} - vertical distance of the process (reserved for processes
which visualize in the window of mode 7).

{distance_2} - horizontal distance of the process (occures the same as in the last statement).

{frame_percent} - percentage of the next frame completed by the
process; this value will be usefull when is used the statement
{#1029,FRAME} indicating a percentage. In contrary case will value
0 (0%) when the process was not executed and 100 (100%) when it was.

{box_x0, box_y0} - superior left coordinate of the graphic in the
last frame of the game (where was situated the graphic in coordinates of screen).

{box_x1, box_y1} - inferior right coordinate of the graphic in the last frame of the game.

{m8_object} - number of object inside the mode 8, indicates an ordinal
relative to the map of sectors.

{old_ctype} - old value of the local variable ctype, is used to
control changes in the coordinates of the process.

{f_count} - counter of accumulation of function, to control the number
of returns and level the battery for each process.

{caller_id} - identification code of the process or function which invoked
this.

{stack_pointer}  - pointer of local stack of each process, maintains
the direccion of the stack in the start of the process, with the stacked parameters

{/}See: {#1201,local data} - {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1117,LOCAL father}

{father;} // {#1039,Identification code} of the process father{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {father}.

This variable contains always the {#1039,identification code} of the process
which created (called) the current process (which has this variable), it means
it indicates which process invoked it.

Inside the language denominates process father which calles other
process, and process son which was called. For more information
See the {#1041,hierarchy of processes} in the language.

The {manager of processes} of DIV is the process denominated {div_main}
and is in charge to create the main process of the program ({PROGRAM})
in the beginning of the execution of the game. Therefore, this will be the father of the main
program, the same as father of all processes
which stay orphans (processes which father died or was finished
before them, See {#1040,states of a process}).

{/}

{Note:} The {#1039,identification code} of the process son indicates
in the predefined local variable {#1118,son}.

{/}See: {#1201,local data} - {#1039,Identification code} - {#1041,Hierarchies of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1118,LOCAL son}

{son=0;} // {#1039,Identification code} of the process son{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {son}.

This variable contains always the {#1039,identification code} of the
{last} process which created (called) the current process , it means,
indicates which is the {last} invoked process.

Inside the language denominates process father which calls another
process, and process son which was called. For more information
See the {#1041,hierarchies of processes} in the language.

This variable will be by default in {0} untill the process realizes
a call to other process, moment in which will be created the new process
indicating its {#1039,identification code} in {son}.

{/}

{Note:} The {#1039,identification code} of the process father indicates
in the predefined local variable {#1117,father}.

{/}See: {#1201,local data} - {#1039,Identification codes} - {#1041,Hierarchies of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1119,LOCAL smallbro}

{smallbro=0;} // {#1039,Identification code} of the small brother{/}

This predefined variable is {#1007,LOCAL}, which means that each
process will have its proper value in its variable {smallbro}.

This variable contains always the {#1039,identification code} of the
next process which created the father of the current process, it
means, when the process which invoked the current invokes another
then this variable will indicate which one.

To this process denomines {small brother} inside the language.
For more information see the {#1041,hierarchies of processes} in the language.

This variable will be by default in {0} until the process father
realizes a call to other process, moment in which creates the
new process (the small brother of this one), indicating its {#1039,identification code} in {smallbro} (from "small brother").

{/}

{Note:} The {#1039,identification code} of the {bigger brother} indicates
in the predefined local variable {#1120,bigbro}.

{/}See: {#1201,local data} - {#1039,Identification code} - {#1041,Hierarchies of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1120,LOCAL bigbro}

{bigbro=0;} // {#1039,Identification code} of the big brother{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {bigbro}.

This variable contains always the {#1039,identification code} of the
process which created the father just before create the current process, it
means, when the process which invoked the current had created other one before
this variable would show which one.

To this process denomines {big brother} inside the language.
For more information see the {#1041,hierarchies of processes} in the language.

This variable would be in {0} if the process father (which invoked the
current process) didn't created any other before. In case
when it created one or more, {bigbro} (from "big brother")
will indicate the {#1039,identification code} in the last of them.

{/}

{Note:} The {#1039,identification code} of the {small brother} indicates
in the predefined local variable {#1120,smallbro}.

{/}See: {#1201,local data} - {#1039,Identification code} - {#1041,Hierarchies of processes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1121,LOCAL priority}

{priority=0;} // level of priority of the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {priority}.

In the preparation of each frame all processes will be executed in
the order of priority established by the local variable {priority}.

As bigger is the value of {priority} in a process, before it will be 
processed in each frame. The value of priority can be fixed
as any whole number inside the rank ({#1177,min_int} ...
{#1178,max_int}); for example, to establish the level of priority
of a process in {10} must be used the following statement:

  {priority=10;}

All active processes in the program which have {the same level
of priority} will be executed in {indetermined order} which,
also, can be changed from one to another executions of the game.

By default the local variable {priority} will be initiated in {0}
in all processes created in the program, therefore they
can be executed in any order, if is not defined the value of this variable.

If the {priority} of only one process fixes in a 
positive number, as 1, it will be executed before other
processes, and if it fixes in negative number, as -1, so
will be executed after the others (supposing that the variable {priority}
of the rest was not modified, continues to value {0}).

{How must be fixed the priority of the processes}{/}

When a process needs to use in its calculations data of other
process, often it is convenient to execute it after l, defining 
its less priority, because after read the data of other process,
these to be yet actualized.

For example, if the process {B} must situate its graphic 8 points down
the graphic of the process {A}, must be fixed the priority
of {A} bigger than of the {B}, for this to be executed first.

This way, when the process {B} obtains its coordinate {y} suming
8 with the process {A}, realizes this calculation with the coordinate {y} of the process {A}
yet actualized for the next frame (to be sure that in each frame
first fixes the coordinate {y} of the process {A} and then of the process {B}).

To archieve it, as both priorities are by default in {0}, you must
define the priority of {A} as {1}, or define the priority of {B} as{ -1}.

{/}

{Note:} The level of priority of the process is not vinculated with
the plane of depth in which appears its graphic in screen,
because it indicates in the variable {#1125,local z}. It means, 
the graphic processed before doesn't implicate its graphic to be painted before.

{/}See: {#1201,local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1122,LOCAL ctype}

{ctype=c_screen;} // system of coordinates{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {ctype}.

In this variable indicates the {system of coordinates} used by
the process, it means, how must be interpreted the coordinates
of the process (situated in the local variables {#1123,x} and {#1124,y}).

Can be used three systems with different coordinates,
which correspond directly to three constants which can be asigned to the variable {ctype}.

  {#1167,c_screen} - coordinates of screenú
  {#1168,c_scroll} - coordinates of scrollú
  {#1169,c_m7}     - coordinates of mode 7ú
  {#1412,c_m8}     - coordinates of mode 8ú

{The value by default of ctype is} {#1167,c_screen}, is used for
the coordinates of the graphic of the process to be interpreted as refered to the
screen, where the superior left corner is the (0, 0).

{#1168,c_scroll} will be assigned to {ctype} with the following statement:

 {ctype=c_scroll;}

For the coordinates of the
graphic of the process to be interpreted as refered to the window of
scroll, the coordinates over the graphic of the first plan.

{#1169,c_m7} will be assigned to {ctype} with the following statement:

 {ctype=c_m7;}

For the coordinates of the
graphic of the process to be interpreted as refered to the window of
mode 7, the coordinates over the main graphic, situated three-dimensional
in this window.

{#1412,c_m8} will be assigned to {ctype} with the following statement:
 {ctype=c_m8;}

For the coordinates of the
graphic of the process to be interpreted as refered to the window of
mode 8, to coordinates over the map of three-dimensional sector.

{/}

{Note:} Exists other local variable which also affects to the mode in which must
be interpreted the coordinates of the process; this is
{#1135,resolution} and establishes the resolution (scale) in which are
defined the coordinates.

{/}See: {#1201,local data} - {#1167,c_screen} - {#1168,c_scroll} - {#1169,c_m7} - {#1412,c_m8}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1123,LOCAL x}

{x=0;} // horizontal coordinate of the graphic{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {x}.

The local variables {x} and {#1124,y} of the processes define where
must be situated their graphics (defined in the local variable {#1126,graph}).

The local variable {x} defines the {horizontal coordinate} of the process,
which can be defined as whole number inside the rank ({#1177,min_int} ...
{#1178,max_int}), situating the positive coordinates to the right
and the negatives to the left.

By default, these coordinates will be specified in {points} (pixels),
refered to the coordinates of screen, where the superior left corner
is the point situated in ({0}, {0}).

{type of coordinates}{/}

There are different systems of coordinates which can be used by the
processes and are defined with the local variable {#1122,ctype}, the
system by default are the coordinates relative to the screen.

{Resolution of the coordinates}{/}

The local variable {#1135,resolution} indicates the necessaty of the coordinates
of the process; by default, this variable will value {0} and the coordinates ({x}, {#1124,y})
are specified in points.

As bigger is the value of {#1135,resolution}, smaller (and necessary) is 
the unity in which are interpreted the coordinates, in continuation are shown some examples:

{resolution=1;} - The coordinates are specified in points.

{resolution=10;} - Are specified in tenth of point.

{resolution=100;} - Are specified in hunderdth of point.

{resolution=2;} - Are specified in half of the point.

...

{/}

{Note:} Can be defined for each process a type and resolution of coordinates
different, or change them during the execution when it is necessary.

{/}

{Important:} When the graphics is situated in the determined coordinates,
normally the {center} of the graphic will be situated in this coordinates.

This can be changed defining in the {graphical editor } the {#1136,point
of control} number {0} of the graphic of the process (which {code of graphic}
indicates in the variable {#1126,graph}).

If was defined the checkpoint, it will be situated in the specified coordinates.

For example, if we put the checkpoint {0} in the
superior left corner of the graphic and then put the graphic in the
coordinates (100, 100), will be situated in the superior
left corner of the graphic in these coordinates.

{/}See: {#1201,local data} - {#1122,ctype} - {#1135,resolution}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1124,LOCAL y}

{y=0;} // vertical coordinate of the graphic{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {y}.

The local variables {y} and {#1123,x} of the processes define where
must be situated their graphics (defined in the local variable {#1126,graph}).

The local variable {y} defines the {vertical coordinate} of the process,
which can be defined as whole number inside the rank ({#1177,min_int} ...
{#1178,max_int}), situating the positive coordinates down
and the negatives up.

By default, these coordinates will be specified in {points} (pixels),
refered to the coordinates of screen, where the superior left corner
is the point situated in ({0}, {0}).

{type of coordinates}{/}

There are different systems of coordinates which can be used by the
processes and are defined with the local variable {#1122,ctype}, the
system by default are the coordinates relative to the screen.

{Resolution of the coordinates}{/}

The local variable {#1135,resolution} indicates the necessaty of the coordinates
of the process; by default, this variable will value {0} and the coordinates ({y}, {#1123,y})
are specified in points.

As bigger is the value of {#1135,resolution}, smaller (and necessary) is 
the unity in which are interpreted the coordinates, in continuation are shown some examples:

{resolution=1;} - The coordinates are specified in points.

{resolution=10;} - Are specified in tenth of point.

{resolution=100;} - Are specified in hunderdth of point.

{resolution=2;} - Are specified in half of the point.

...

{/}


{Note:} Can be defined for each process a type and resolution of coordinates
different, or change them during the execution when it is necessary.

{/}

{Important:} When the graphics is situated in the determined coordinates,
normally the {center} of the graphic will be situated in this coordinates.

This can be changed defining in the {graphical editor } the {#1136,point
of control} number {0} of the graphic of the process (which {code of graphic}
indicates in the variable {#1126,graph}).

If was defined the checkpoint, it will be situated in the specified coordinates.

For example, if we put the checkpoint {0} in the
superior left corner of the graphic and then put the graphic in the
coordinates (100, 100), will be situated in the superior
left corner of the graphic in these coordinates.

{/}See: {#1201,local data} - {#1122,ctype} - {#1135,resolution}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1125,LOCAL z}

{z=0;} // plane of depth of the graphic of the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {z}.

The local variable {z} defines in which plane of depth must be situated
the graphic of the process in the screen (the graphic is defined in the local variable
{#1126,graph}). It means, what must appear over and under the graphic of the process.

The plans of depth can be of any whole number inside the
rank ({#1177,min_int} ... {#1178,max_int}), and as bigger is the number
more deeply will be situated the graphic (major depth).

{/}

By default, the plans of depth are disposed of the following form:

{ (+) Major depth}

{ +512} - Windows of scroll (See {#1101,scroll[].z})ú
{ +256} - Windows of mode 7 (See {#1102,m7[].z})ú
{  0}   - Graphics of the processes (local {z})ú
{ -256} - Texts (See {#1106,text_z})ú
{ -512} - Pointer of mouse (See {#1100,mouse.z})ú

{ (-) Smaller depth}

It means, the local variable {z} which defines the plane of depth
of the graphics of the processes will be initiated in {0}. The graphics
of the processes will be situated under the pointer of mouse
and the texts, and over the windows of scroll and mode 7 (if are not
modified the values by default).

{/}

All objects (texts, graphics, windows, ...) which are situated in the same
plane of depth will appear in screen (ones put over others)
in the {indetermine order}, which can be changed from one to other executions.

If you want, for example, the graphic of the process to appear
over all objects of the program, for it can be fixed the
plane of depth over the rest (as -1000}, with the following statement:

  {z=-1000;}

initially, all processes have their variable {z} equal in {0},
then the graphics of the processes will appear in any order
if it is not defined in which plane must be situated each one.

Can be changed the plane of depth of a process (assigning 
new value to its variable {z}) so many times as it is necessary inside the program.

The plans of depth of the rest of objects (windows, texts
and pointer of mouse) also can be changed in any moment of the program.

{/}

{Note 1:} The processes which belong to the {window of scroll} (which have their
variable {#1122,ctype}{=}{#1168,c_scroll}) will be painted in the
{plane of depth of the window of scroll}; however, inside this
window, all graphics of the processes will appear
{by their plane of depth}.

It means, the plane of depth of the process (indicating it as always
in the variable {z}) will be then {relative to the window of scroll}
in which appears the process (See {#163,start_scroll()}).

{/}

{Note 2:} The processes which belong to the {window of mode 7} (which have their
variable {#1122,ctype}{=}{#1167,c_m7}) appear in this window
{by exact order of depth in the three-dimensional plan}
ignoring the value of its local variable {z}.

The only sense which has the local variable {z} in processes of the
{mode 7} is to define the order in which must be overput the
processes which are {exactly} in the same coordinates of the plan
brought down, it means, if two processes are situated in the three-dimensional plan
in the same coordinates then with the variable {z} can be
defined which of them must appear over the other (See {#162,start_mode7()}).

{/}See: {#1201,local data} - {#1100,mouse.z} - {#1101,scroll[].z} - {#1102,m7[].z} - {#1106,text_z}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1126,LOCAL graph}

{graph=0;} // Code of the graphic of the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {graph}.

Normally, the majority of processes correspond to the graphical object
visualized in screen which will be situated in the coordinates
indicated in the local variables {#1123,x} and {#1123,y}. Must be
defined which graphic corresponds to this process asigned a
{code of graphic} to the local variable {graph}.

By default, this variable will value {0} that implicates that will not be
visualized any graphic of this process.

The graphics must be created first in the {graphical editor} of DIV
Games Studio (with the option "{new...}" of menu of maps) and, then,
must be saved in the {archive MAP or PCX} (which will contain this graphic),
or in the {file FPG} with other graphics (can be created a
new file with the option "{new...}" of the menu of files).

It means, the graphics used in the program can come from
a {archive MAP or PCX} (which contains only one graphic) or from one {file FPG}
(which can contain many graphics).

{Note:} The same graphic can be at the same time used by many processes of the program.

{Archives MAP or PCX}{/}

To use one graphic from {archive MAP or PCX} it must be loaded 
calling to the functions {#174,load_map()} or {#174,load_pcx()}, which will return
the {code of graphic} which must be assigned to the variable {graph}.

Normally is used a variable {#1006,GLOBAL} to save this
{code of graphic} and then assigns to the variable {graph}.

{#9999,program example:}
PROGRAM Example_graph;

GLOBAL
    graphic1;

BEGIN
    graphic1=load_map("help\help.map");

    graph=graphic1; // Defines the graphic of process.

    LOOP
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
{-}

Also in the last example could be ignored the global variable
{graphic1} but assign directly the code returned
by the function {#174,load_map()} to the variable {graph} with the following statement:

  {graph=load_map("help\help.map");}

The {code of graphic} which return this function are whole numbers beginning from {1000}.

{Files FPG}{/}

To unclude in graphic which was realized in the {graphical editor}
in a {files FPG} must {stretch the window of graphic to the
window of the file} (press in the graphic, move to the file
and let go of), then the program will ask for the {code of graphic}, here must be
introduced a whole number between {1} and {999}.

So to use the graphic in the program, first must be loaded
the {file FPG} which it contains with the function {#132,load_fpg()}
and then assign the {code of graphic} to the variable {graph}.

It is shown, in continuation, an example in which before it is necessary to know
that the graphic of {brow ball} introduced in the {file HELP.FPG}
indicating the {code of graphic 100}.

{#9999,program Example:}
PROGRAM Example_graph;
BEGIN
    load_fpg("help\help.fpg");

    graph=100; // Defines the graphic of the process.

    LOOP
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
{-}

Can be loaded {different files FPG} in the program; in this case
must be indicated besides the {code of graphic} in the local variable
{graph}, the {code of file} which returns the function {#132,load_fpg()}
in the local variable {#1131,file}.

If it is only loaded the file it will not be necessary, because the variable
{#1131,file} values {0} by default in all processes and {0} will be always
the {code of the first file} which loads the program.

{/}

Exist more local variables relationed with the graphic of a
process, the mains are the following:

  {graph}  - Code of graphicú
  {#1131,file}   - Code of fileú
  {#1123,x}, {#1124,y}   - Coordinates of the graphicú
  {#1125,z}      - Plane of depthú
  {#1129,angle}  - Angle of the graphicú
  {#1128,size}   - Size of the graphicú
  {#1127,flags}  - Reflection and transparenciesú
  {#1130,region} - Window of visualizationú

{/}See: {#1201,local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1127,LOCAL flags}

{flags=0;} // Indicator of reflections and transparences{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {flags}.

The local variable {flags} indicates the reflections and transparences with
which will be printed the graphic of the process; the possible values are:

 {0}-Normal graphic.ú
 {1}-Horizontal reflection.ú
 {2}-Vertical reflection.ú
 {3}-Horizontal and vertical reflection(180ø).ú
 {4}-Transparente graphic.ú
 {5}-Transparente and reflected horizontal.ú
 {6}-Transparente and reflected vertical.ú
 {7}-Transparente, reflected horizontal and vertical.ú

The value by default of the variable {flags} is {0}, it means, if the graphic is not
modified the graphic will be shown opaque (without transparence) and without reflection.

Are defined in continuation the terms of {reflection} and {transparence}:

- {Horizontal reflection}, the graphics inverts horizontal, it means,
if it was looking to the left, will look to the right and vice versa.

- {Vertical reflected}, the graphic inverts vertical, it means,
if was looking up will look down and vice versa.

- {Transparence} (or {ghost-theyering}), the graphic will be shown  semi-transparente,
it means, will be seen what is behind the graphic, in contraposition to the 
opaque graphics which are shown normally.

For example, for the graphic of one process to be shown transparent
must be used the following statement:

  {flags=4;}

{/}

{Note:} The graphic of one process can be indicated assigning the {code
of graphic} to the local variable {#1126,graph}.

{/}See: {#1201,local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1128,LOCAL size}

{size=100;} // Size (in percentage) of the graphic{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {size}.

The local variable {size} defines the size
in which must be seen the graphic of the process, 
in the percentage relative to its original size.

The value by default of this variable will be {100} (100%) for all
the processes, and when the graphics will be modified {will be scaled}
(increasing or decreasing) to fit to new size.

It means, to show the {doble} size of the graphic must be 
specified {200%}, which can be done with the following statement:

  {size=200;}

therefore, if this value is less than {100} the graphic will be seen smaller, 
and if more, so bigger.

In the beginning there is no limit for the size of the graphic, but
we put the local variable {size} to {0} (0%), then the graphic 
of the process will not be seen.

{/}

{Note:} The graphic of the process must be indicated assigning the {code
of the graphic} to the local variable {#1126,graph}.

{/}See: {#1201,Local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1129,LOCAL angle}

{angle=0;} // Angle of the graphic of the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {angle}.

The local variable {angle} defines the angle in which must be seen
the graphic of the process, indicating an angle respective to the original graphic
in {hunderdth of degree} (see {#1044,Use of angles in the language}).

The value by default of this variable will be {0} (0 degrees) for all
processes, but when it is modified the graphic {will rotate} to make a new angle.

The angle can be defined as any whole number inside the rank ({#1177,min_int} ... {#1178,max_int}).

In continuation are shown some examples of angles which
define certain values in the local variable {angle} (remember that the angles are expressed in hunderdth of degree):

      ...ú
 { -180000} - {#1044,Angle} to the leftú
 {  -90000} - {#1044,Angle} downú
 {  -45000} - {#1044,Angle} of the diagonal down/rightú
 {       0} - {#1044,Angle} to the rightú
 {  +45000} - {#1044,Angle} of the diagonal right/upú
 {  +90000} - {#1044,Angle} upú
 { +180000} - {#1044,Angle} to the leftú
 { +270000} - {#1044,Angle} downú
      ...ú

{Important:} When is it pretended to rotate the graphic of one process,
{is convenient paint it oriented to the right}, because this way it will be shown
by default (with the local variable {angle} equal in {0}).

With way, when is specified other angle, the graphic will appear oriented exactly to l.

For example, for one graphic to be painted to the
right and oriented up (to the angle of 90 degrees),
it must be indicated in the following statement:

  {angle=90000;} // 90 hunderdth of degree (90 degrees).

It means, if a graphic is painted oriented to another angle,
for example down, it will stay oriented down by default,
{in the angle 0}, this can provoke confusions in the moment to orient this graphic to another angle.

{/}

To make the graphic of one process advance one determined distance its coordinates ({#1123,x}, {#1124,y})
to the angle (specified in the local variable {angle} of the process)
can be used the function {#101,advance()}.

{/}

{Note:} The graphic of the process indicates assigning a {code of graphic} to the local variable {#1126,graph}.

{/}See: {#1201,Local data} - {#1044,Use of angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1130,LOCAL region}

{region=0;} // Region of screen assigned to the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {region}.

The local variable {region} defines in which zone of screen must be
visible the graphic of the process, indicating the {number of region}.

A region is rectangle zone of screen, as a window,
which is associated to a number.

By default, this variable will value {0} in all processes making
reference to the {region number 0} which is {the whole screen}.

It means, that by default the graphics of the processes will be visibles
in the whole screen (in its any point in which they are).

First, it is defined only the {region number 0}.
To define new regions must be used the function {#106,define_region()}.

{/}

For example, for one graphic of one process to be visible only
inside the box of 100 by 100 points situated in the superior
left corner of the screen (in the coordinates 0, 0), first must be
defined the new region, supposing that it defines the region number {1}:

  {define_region(1, 0, 0, 100, 100);}

and, then, must be assigned the number of region ({1}) to the local variable
{region} of the process with the following statement:

  {region=1;}

The regions can be re-defined in any moment inside one
program; can change the position or the size always when it is necessary.

{/}

{Note:} The graphic of a process indicates asigning a {code of graphic} to the local variable {#1126,graph}.

{/}See: {#1201,local data} - {#106,define_region()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1131,LOCAL file}

{file=0;} // Code of file of the graphic of the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {file}.

The local variable {file} indicates, in the case when were loaded many
{files FPG} of the graphics of the program, which the file
contains the graphic which is using the process.

The graphic of a process indicates assigning a {code of graphic} to the local variable {#1126,graph}.

If was loaded only one file in the program, won't be  necessary
to assign any value to {file}, because the {code of the first loaded file}
will be {0} and this is the value by default of the variable.

If the graphic was loaded with the functions {#174,load_map()} or {#174,load_pcx()}, 
also is not necessary to assign any value to {file}, because the graphics
loaded with these functions will be used as they belong to the file number {0}
(to the first which loads the program).

When is loading more than one file, must be indicated in each process
in which of them situates the graphic; this must be done assigning
the {code of file} which returned the function {#132,load_fpg()}
(after load this {file FPG}) to the local variable {file}.

{Note:} Normally, if are loading many files in one program sequencially,
the first will have the code {0}, the second {1}, the third {2} and so on.

{/}

In general, it is a good practice, if are used many files,
to have the same number of global variables (denominated for example
{file1}, {file2}, ...) which contain the code of each one of the
files, to use them in the processes when must be defined
its variable {file} (must be used the {file FPG}).

The variables define inside the section {#1006,GLOBAL} this way:

  {GLOBAL}ú
      {file1;} // Code of the first fileú
      {file2;} // Code of the secondú
      ...

Then after loading to this variables will be assigned the {codes of file}
with the function {#132,load_fpg()} the following way
(supposing that the name of the files is {name1.fpg},{name2.fpg}, etc.):

  {file1=load_fpg("name1.fpg");} // Loading of filesú
  {file2=load_fpg("name2.fpg");}ú
  ...

Generally, this loading of files realizes in the beginning of the program;
then, inside each process, only must be defined
the file used with the following statement (supposing that the process
uses the graphics contained in the file {name1.fpg}):

  {file=file1;} // Is used the first fileú

{/}

{Note:} Remember, there is no sense to define the local variable {file},
although if is assigned the {code of graphic} to the local variable
{#1126,graph}.

{/}See: {#1201,Local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1132,LOCAL xgraph}

{xgraph=0;} // OFFSET of the graphical board of the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {xgraph}.

This variable is of advanced level, therefore is required certain experience
to use it.

The local variable {xgraph} ({extended graphic}) sirves to use
{multiple graphics}. To define the graphic of one process as 
{aggregate of graphics} of which must be seen {the most corresponding to the angle of the
process} (specifying in the local variable {#1129,angle}).

It means, if defines the variable {xgraph}, {will be ignored the}local variable
{#1126,graph} which normally defines the graphic of the process and 
uses the graphic in the function of the variable {#1129,angle}.

Therefore, after change the angle of the process {will not yet appear the graphic 
of the rotated process}, but will use this angle as
selectioned of the graphic of the process (inside the defined aggregate).

By default the variable {xgraph} values {0} in all processes,
this indicates that they will not use {multiple graphics}.

{/}

The utility of multiple graphics is to realize games
in {perspective}, where the change of angle of the process doesn't implicate
a rotation of its graphic, but the change of the graphic for another painted with other
{perspective} (painted which other angle inside the same perspective).

{Form of use of the multiple graphics}{/}

1 - First must be realized the different pictures which will
represent the graphic of the process with different angules in the
perspective. These will be defined numbers of views of the graphic, as
can be {4}, {8}, {12}, etc., (or any other whole number major than {1}).

Remember that if are defined 4 views, will continue defining
a different view each 90 degrees, if define 8 views, each 45
degrees, etc.

2 - These graphics must be defined by their angles; first the graphic
which will correspond to the angle 0 (to the right) and, then,
the rest in the contrary sense of clock hand.

3 - Must be created a board, generally {#1006,GLOBAL}, initiated with the following values:

  {Number of views of the graphic},ú
  {Code of the graphic for the } angle {0r (first view)},ú
  {Code of the following angle (second view)},ú
  ...

{Note:} This board must contain simple data (of type {#1402,INT}, whole
of 32 bit with sign).

It is indifferent the name which is given to this board, for example,
if defines a multiple graphic with 4 views, which must be the graphics with the
code 10, 11, 12, y 13, the definition of the board could be:

  {GLOBAL}ú
      {board_graphic1[]=4, 10, 11, 12, 13;}ú
      ....

4 - Must be assigned the direccion of this board inside the
memory of the PC to the local variable {xgraph} of the process,
which will be done with the following statement (inside the process):

  {xgraph=OFFSET board_graphic1;}

The operator {#1085,OFFSET} sirves to obtain the direccion from the
memory of one data of the program.

{/}

When was defined the {multiple graphic}, the system will use in
each frame of the game the graphic corresponding to the angle {which
is the nearest to the angle of the process} (indicating it in its variable{#1129,angle}).

To disactivate the system of {multiple graphics} in one process,
you must once more put in {0} the variable {xgraph}.

{Important:} If inside of the board which defines the aggregate of the graphics
puts one code of graphic with {negative sign}, then with graphic will appear 
{reflected horizontal}, it means, if the graphic was looking to the right, it will appear looking to the left,
and vice versa.

{/}

{Note:} The system of multiple graphics often is used in the
{windows of mode 7}, because in the three-dimentional plane brought down the
graphics must be seen the distinct way by the angle from which are seen.

For more information about this technic see the function {#162,start_mode7()}
used to activate a {window of mode 7} in the program.

{/}See: {#1201,Local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1133,LOCAL height}

{height=0;} // Height of the graphic (in the mode 7){/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {height}.

The local variable {height} is used {exclusively} in the processes
which belong to {windows of mode 7}, it means, processes which have
their system of coordinates inside a three-dimetional window (its
local variable {#1122,ctype}={#1169,c_m7}).

Is used to define the height on which must be situated the graphics
of the processes in the three-dimentional plan. For it is not used
the variable {#1125,local z}, because it continues using to define
the plane of depth of the graphics (although it is usefull only
for processes situated in the same coordinates).

The height of the process can be defined as any whole number inside
the rank ({#1177,min_int} ... {#1178,max_int}), often are used the whole
positive numbers, because the height ({height})
of the floor is the {0} and the processes situate over it.

The value by default of the variable {height} is {0} for all
processes, that means that if is not specified other value,
the graphics of the processes will appear just on the floor of the
{mode 7} (over the three-dimentional plane brought down).

In the beginning will situate in the height indicated in {height} the {base
of the graphic} of the process, if defines the {#1136,point of
control} number {0}, this point will situate in this height.

{Note:} For more information about the {windows of mode 7} and how to situate
the graphics inside these windows, see the help about the function
{#162,start_mode7()} which is used to activate them in the program.

{/}

In the processes which are not of {mode 7} this variable can be used
with any other goal, because the system will ignore it completely.

{/}See: {#1201,local data} - {#162,start_mode7()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1134,LOCAL cnumber}

{cnumber=0;} // Number of windows of scroll or mode 7{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {cnumber}.

The local variable {cnumber} is used {exclusively} when in one game
appear different {windows of scroll} or different {windows of mode 7}
simultaneous in screen.

- For more information about the {windows of scroll}, see the
hepl about the function {#163,start_scroll()}, which is used to activate them in the program.

- For more information about the {windows of mode7}, see the
hepl about the function {#163,start_mode7()}, which is used to activate them in the program.

The utility of {cnumber} is to indicate {in which of these windows
must be seen the graphic of the process}. Evidentially, this variable must
be defined only in the processes visibles inside the {windows
of scroll} or the {windows of mode 7}; for the rest of processes
(the processes of screen or which doesn`t have the graphic) this variable has no sense.

{If the process must be seen in all windows}, then won't be 
necessary modify this variable, because the value by default of
{cnumber} (which is {0}) indicates exactly it.

Can be activated till {10} windows, of both types,
with the numbers from {0} to {9}. Exist ten predefined constants
which are used to define the value of {cnumber}; these are
{#1175,c_0, c_1, c_2, ..., c_9} and correspond directly with the
{10} possible windows of these types.

Must be assigned to {cnumber the sum of the constants} corresponding
to the {windows in which the process must be visible}.

For example, if in one program there is {4 windows of scroll} which are
the numbers {0}, {1}, {2} and {3}, and you want to define one determined process
must be visible only inside the windows {0} and {2}, for it must be used the following statement:

  {cnumber=c_0+c_2;}

The value of {cnumber} can be changed during the execution of the process always when it is necessary.

{/}

{Note:} Remember for the graphic to be seen in all
windows it is not necessary to do something, because this is the option by default.

{/}See: {#1201,local data} - {#1175,c_0...c_9}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1135,LOCAL resolution}

{resolution=0;} // Resolution of the coordinates of the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its proper value in its variable {resolution}.

Normaly, the coordinates of one process (indicated in the local variables
{#1123,x} and {#1124,y}) are defined in points (of screen).

The local variable {resolution} must be used when you want to define
the coordinates in {smaller unities} than the point.

It means, that this variable indicates the precision of the coordinates
of the process.

By default the variable values {0} and the coordinates specify in points.

As bigger is the value of {#1135,resolution}, smaller (and more necessary)
will be the unity in which interpret the coordinates; in continuation
are shown some examples:

{resolution=1;} - The coordinates specified in points (equal with the
{resolution=0}, which is the value by default).

{resolution=10;} - Specified in tenth of points.

{resolution=100;} - Specified in hunderdth of points.

{resolution=2;} - Specified in half of point.

...

For example, a process situated in {160}, {100} with equal {resolution} to
{0} (or {1}), will be in the same position as the process situated in
{1600}, {1000} and with equal {resolution} to {10}.

The value of {resolution} defines normally as a {whole 
positive number multiple of 10} (10, 100, 1000, ...).

{/}

In resume, when defines the value of {resolution}, the manager of
processes of DIV Games Studio {will divide} the coordinates of the processes
between {resolution} in time to paint their graphics in screen.

{/}

{Important:} Must be taken the precautions when in one program
exist different processes with different resolutions of coordinates,
because some functions, as {#117,get_dist()} (to obtain the
distance between two processes), will return {incorrect results}
when it is acceeding to two processes which use differente resolution of coordinates.

Often it is convenient all active processes in the game,
at least which interact between them (detect, modify or can collision) use the same resolution.

{/}See: {#1201,local data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1136,checkpoints}

{+141,0}The {checkpoints} are defined inside the {graphical editor}
which the bar of checkpoints, indicated with this iwith.{-}

To acceed to the {graphical editor} you must make "{doble-click}" with the mouse
(two pressions with the left button of the mouse)
on the graphic inside the environment (on the window of map).

The {checkpoints} are only points which can localize
inside one graphic, with different functions.

The {bar of checkpoints} permits situate till different {1000} points
inside the graphic, each one will be identified by its number (from {0} to {999}).

To situate one of these points, you must select the {number of
point} with the {icons left arrow} and {right arrow} and, then,
press on the graphic.

To {rub out} (diselect) a checkpoint, you must press once more on the graphic.

{/}

The only {checkpoint} which uses the system is the point of
control number {0} (the first); this is the point which defines which is
the {virtual center of the graphic} and which has multiple applications inside the language.

When is not defined the {checkpoint number 0}, the system
actuates as the virtual center of the graphic were {its real center}
(a point situated in the middle of the width and of the height of the graphic).

{/}

{Note:} When the checkpoints are defined, for they continue to have 
effect inside the program, must be saved the {archive MAP} (in the
archives PCX can't be saved the checkpoints) or return to
add the graphic to the {file FPG} pulling it to this file.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1150,modes of video}

constants: {m320x200} ... {m1024x768}
{/}

This constants sirve to indicate the mode of video in the function
{#157,set_mode()}. The complete list of constants is the following:

    m320x200ú
    m320x240ú
    m320x400ú
    m360x240ú
    m360x360ú
    m376x282ú
    m640x400ú
    m640x480ú
    m800x600ú
    m1024x768ú

each constant indicates the mode of video such way: first,
the letter {m} and, then, the horizontal and vertical resolution of the mode separated by one {x}.

The defined values for these constants are the following.

    m320x200  = 320200ú
    m320x240  = 320240ú
    m320x400  = 320400ú
    m360x240  = 360240ú
    m360x360  = 360360ú
    m376x282  = 376282ú
    m640x400  = 640400ú
    m640x480  = 640480ú
    m800x600  = 800600ú
    m1024x768 = 1024768ú

{/}

{Note:} Besides these standart modes of video, the global structure
{#1415,video_modes} contains a list of all modes compatible with the standard
VESA situated in the video adaptador of the system.

{/}See: {#1202,constants} - {#157,set_mode()} - {#1415,video_modes}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1151,true}

constant: {true}
{/}

This constant is used to indicate values {certains}, to initiate logical variables or
define logical parameters, it means, which must be evaluated as a condition.

Its value is {1}, and as in the language are interpreted as {certains} all
{odd} numbers, this constant will be evaluated as a condition which always fulfills ({certain}).

{/}

The constant {#1152,false} is the opposed to this one: is used for indicate {falses} logical values.

{/}See: {#1202,constants} - {#1152,false}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1152,false}

constant: {false}
{/}

This constant is used to indicate values {falses}, to initiate logical variables or
define logical parameters, it means, which must be evaluated as a condition.

Its value is {0}, and as in the language are interpreted as {false} all
{pair} numbers, this constant will be evaluated as a condition which always fulfills ({false}).

{/}

The constant {#1152,true} is the opposed to this one: is used for indicate {certains} logical values.

{/}See: {#1202,constants} - {#1151,true}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1153,s_kill}

constant: {s_kill}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {0}.

This signal transmits to the processes the imperative order {kill}.
Is used to undo processes in the program
(to make disappear certain objects of the game).

It means, after send it a signal {s_kill} to a process, it will be 
undone and will not appear in the following frames of the game.

A constant relationed directly with it is {#1157,s_kill_tree}, with the
only difference that after send this signal will be undone the indicated process and
its {sons}, which are the processes created by the first.

The complete list of the constants which are used as signals can be send
to the differentes processes of the program, is:

    {s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}See: {#1202,constants} - {#158,signal()} - {#1157,s_kill_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1154,s_wakeup}

constant: {s_wakeup}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {1}.

This signal transmits to the processes the imperative order {wakeup}
Is used to return to the normal state the processes
which were slept (with the signal {#1155,s_sleep}), or frozen
(with the signal {#1156,s_freeze}).

It means, after send a signal {s_wakeup} to the process, it will be 
re-activated in the following frames of the game (will be seen and working).

A constant relationed directly with it is {#1158,s_wakeup_tree}, with the
only difference that after send this signal will be awaken the indicated process and
its {sons}, which are the processes created by the first.

The complete list of the constants which are used as signals can be send
to the different processes of the program, is:

    {#1153,s_kill}ú
    {s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú


{/}See: {#1202,constants} - {#158,signal()} - {#1158,s_wakeup_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1155,s_sleep}

constant: {s_sleep}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {2}.

This signal transmits to the processes the imperative order {sleep}.
Is used to sleep a process. A  slept process
will not appear in the next frames of the game, but will not be 
undone, as with the signal {#1153,s_kill}, it can be {awaken}
in any moment with the signal {#1154,s_wakeup}.

It means, after one process to be sent this signal {s_sleep},it will not 
appear in the next frames of the game (untill it is awaken or undone).

A constant relationed directly with it is {#1159,s_sleep_tree}, with the
only difference that after send this signal will be slept the indicated process and
its {sons}, which are the processes created by the first.

The complete list of the constants which are used as signals can be send
to the differentes processes of the program, is:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}See: {#1202,constants} - {#158,signal()} - {#1159,s_sleep_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1156,s_freeze}

constant: {s_freeze}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {3}.

This signal transmits to the processes the imperative order {freeze}.
Is used to freez (inmovilize) a process.
A frozen process will continue to appear in the next frames
of the game, but will not be processed, will stay inmobilized.
This process can be {activated} any moment if is sent the signal {#1154,s_wakeup}.

It means, after send to this pprocess a signal {s_freeze} it will not be 
processed (interpret its statements) in the next frames
of the game (untill will be activated or undone with {#1153,s_kill}).

A constant relationed directly with it is {#1160,s_freeze_tree}, with the
only difference that after send this signal will be frozen the indicated process and
its {sons}, which are the processes created by the first.

The complete list of the constants which are used as signals can be send
to the different processes of the program, is:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}See: {#1202,constants} - {#158,signal()} - {#1160,s_freeze_tree}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1157,s_kill_tree}

constant: {s_kill_tree}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {100}.

This signal is used a process and all processes
created by the first to be {undone} sending with the imperative order
{kill}. Is the version of the signal {#1153,s_kill}, which 
undo the process, but not the processes which it created.

It means, with {s_kill_tree} {undos} the process and all it
descendents, so noone will never appear in the next frames of the game.

The complete list of the constants which are used as signals can be send
to the differentes processes of the program, is:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}See: {#1202,constants} - {#158,signal()} - {#1153,s_kill}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1158,s_wakeup_tree}

constant: {s_wakeup_tree}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {101}.

This signal is used a process and all processes
created by the first to be {awaken} sending with the imperative order
{wakeup}. Is the version of the signal {#1154,s_wakeup}, which 
wake up the process, but not the processes which it created.

It means, with {s_wakeup_tree} ill be {awaken} the process and its
descendens, returning all processes to their normal state in the next frames of the game.

Can  awake (re-activate) the processes which were {slept}
with the signal {#1159,s_sleep_tree} or {frozen} with the signal{#1160,s_freeze_tree}.

The complete list of the constants which are used as signals can be send
to the differentes processes of the program, is:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}See: {#1202,constants} - {#158,signal()} - {#1154,s_wakeup}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1159,s_sleep_tree}

constant: {s_sleep_tree}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {102}.

This signal is used a process and all processes
created by the first to be {slept} sending with the imperative order
{sleep}. Is the version of the signal {#1154,s_sleep}, which 
make the process to sleep, but not the processes which it created.

It means, with {s_sleep_tree} ill be {slept} the process and its
descendens, disappearing all processes in the next frames of the game (but without to be undone).

The {slept} process can be awaken (reactivated) with the signal {#1158,s_wakeup_tree}.

The complete list of the constants which are used as signals can be send
to the differentes processes of the program, is:

    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {s_sleep_tree}ú
    {#1160,s_freeze_tree}ú

{/}See: {#1202,constants} - {#158,signal()} - {#1155,s_sleep}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1160,s_freeze_tree}

constant: {s_freeze_tree}
{/}

This constant is used as parameter of the function
{#158,signal()} (to send signals to the processes).
Its value is {103}.

This signal is used a process and all processes
created by the first to be {frozen} (inmobilized) sending with the imperative order
{freeze}. Is the version of the signal {#1156,s_freeze}, which 
freeze the process, but not the processes which it created.

It means, with {s_freeze_tree} will be {frozen} the process and its
descendens, leaving to process these processes in the next frames of the game (will stay inmobilized
will not execute their statements).

The {frozen}processe can be re-frozen (re-activated) with the signal {#1158,s_wakeup_tree}.

The complete list of the constants which are used as signals can be send
to the different processes of the program, is:
    {#1153,s_kill}ú
    {#1154,s_wakeup}ú
    {#1155,s_sleep}ú
    {#1156,s_freeze}ú
    {#1157,s_kill_tree}ú
    {#1158,s_wakeup_tree}ú
    {#1159,s_sleep_tree}ú
    {s_freeze_tree}ú

{/}See: {#1202,constants} - {#158,signal()} - {#1156,s_freeze}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1161,all_text}

constant: {all_text}
{/}

This constant is used as parameter of the function {#107,delete_text()},
to undo {all} texts visualized in the program with the functions {#171,write()} and {#172,write_int()}.

It means, to make disappear all texts which appear in
screen must be executed the following statement:

  {delete_text(all_text);}

The value which has assigned this constant is {0}.

{/}See: {#1202,constants} - {#107,delete_text()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1162,all_sound}

constant: {all_sound}
{/}

This constant is used as parameter of the function {#167,stop_sound()},
to stop {all} sound effects activated before with the function {#159,sound()}.

It means, to stop all active channels of sound in the determined moment
must be executed the following statement:

  {stop_sound(all_sound);}

The value which has assigned this constant is{ -1}.

{/}See: {#1202,constants} - {#167,stop_sound()} - {#159,sound()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1163,g_width}

constant: {g_width}
{/}

This constant is used as parameter of the function {#126,graphic_info()},
to ask for the information about the {width} (in points) of the determined graphic.
Its value is {0}.

The constants which can be used as parameters of this function are:

    {g_width}ú
    {#1164,g_height}ú
    {#1165,g_x_center}ú
    {#1166,g_y_center}ú

{/}See: {#1202,constants} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1164,g_height}

constant: {g_height}
{/}

This constant is used as the parameter of the function {#126,graphic_info()},
to ask for the information about the{height} (in points) of the determined graphic.
Its value is {1}.

The constants which can be used as parameters of this function are:

    {#1163,g_width}ú
    {g_height}ú
    {#1165,g_x_center}ú
    {#1166,g_y_center}ú

{/}See: {#1202,constants} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1165,g_x_center}

constant: {g_x_center}
{/}

This constant is used as the parameter of the function {#126,graphic_info()},
to ask for the information about the{horizontal center} of the determined graphic.
Its value is {2}.

The {center horizontal} of one graphic will the half of width (in points),
if in tools of picture is not defined the {#1136,checkpoint}
number {0} (center of the graphic).

The constants which can be used as parameters of this function are:

    {#1163,g_width}ú
    {#1164,g_height}ú
    {g_x_center}ú
    {#1166,g_y_center}ú

{/}See: {#1202,constants} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1166,g_y_center}

constant: {g_y_center}
{/}

This constant is used as the parameter of the function {#126,graphic_info()},
to ask for the information about the{vertical center} of the determined graphic.
Its value is {3}.

The {center vertical} of one graphic will be the half of height (in points),
if in tools of picture is not defined the {#1136,checkpoint}
number {0} (center of the graphic).

The constants which can be used as parameters of this function are:
    {#1163,g_width}ú
    {#1164,g_height}ú
    {#1165,g_x_center}ú
    {g_y_center}ú

{/}See: {#1202,constants} - {#126,graphic_info()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1167,c_screen}

constant: {c_screen}
{/}

This constant is used to assign it to the local predefined variable
{#1122,ctype} which sirves to define the type of coordinates which will have the
process. Its value is {0}.

{This is the value by default of} {#1122,ctype}, is used for the
coordinates of the graphic of the process to be interpreted as refered
to the screen, where the superior left corner is the (0, 0).

Exist other constants used for other systems of coordinates,
the complete list is the following:

    {c_screen} - coordinates of screenú
    {#1168,c_scroll} - coordinates of scrollú
    {#1169,c_m7}     - coordinates of mode 7ú
    {#1412,c_m8}     - coordinates of mode 8ú

{/}See: {#1202,constants} - {#1122,ctype}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1168,c_scroll}

constant: {c_scroll}
{/}

This constant is used to assign it to the local predefined variable
{#1122,ctype} which sirves to define the type of coordinates which will have the
process. Its value is {1}.

This is the value assigned to {#1122,ctype} for the
coordinates of the graphics of the process to be interpreted as refered
to the window of scroll, to coordinates over the graphic of the first plan.

For more information about the {windows of scroll}, you can acceed
to the function {#163,start_scroll()} used to activate them.

Exist other constants used for other systems of coordinates,
the complete list is the following:

    {#1167,c_screen} - coordinates of screenú
    {c_scroll} - coordinates of scrollú
    {#1169,c_m7}     - coordinates of mode 7ú
    {#1412,c_m8}     - coordinates of mode 8ú

{/}See: {#1202,constants} - {#1122,ctype} - {#163,start_scroll()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1169,c_m7}

constant: {c_m7}
{/}

This constant is used to assign it to the local predefined variable
{#1122,ctype} which sirves to define the type of coordinates which will have the
process. Its value is {2}.

This is the value assigned to {#1122,ctype} for the
coordinates of the graphic of the process to be interpreted as refered
to the window of mode 7, to coordinates over the main graphic
brought down three-dimensional in this window.

For more information about the {windows of mode7}, you can acceed
to the function {#162,start_mode7()} used to activate them.

Exist other constants used for other systems of coordinates,
the complete list is the following:

    {#1167,c_screen} - coordinates of screenú
    {#1168,c_scroll} - coordinates of scrollú
    {c_m7}     - coordinates of mode 7ú
    {#1412,c_m8}     - coordinates of mode 8ú

{/}See: {#1202,constants} - {#1122,ctype} - {#162,start_mode7()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1170,partial_dump}

constant: {partial_dump}
{/}

This constant is used to asignar it to the global predefined variable
{#1114,dump_type} which sirves to define the type of dump which will be
on screen. Its value is {0}.

Is used in the following statement:

  {dump_type=partial_dump;}

This statement indicates to the manager of the processes of DIV Games
Studio that the following dumps will be {partial}.

Denomines {dump} the method to send the frames of the game
to the monitor (to the video memory of the graphical card).

There are two types of dumps:

{Partial}: In the screen will turn ony the graphics which actualize,
which were changed with respect to the last frame. This dump must be activated
{to win the speed} when is programing a game (or its section}
without a window of scroll or mode 7 which occupies all screen,
it means, when the game shows movements of the graphics on the
fixed background, or when all active windows of scroll or mode 7 are smaller than screen.

{Complete}: Will turn all screen, doesn't metter if the graphic was changed or not.
This is the dump by default and {is slower than the partial}
but it must be used when the
game has one window of scroll or mode 7 which occupies all screen.

{/}

The other constant which is used to design the type of the dump is
{#1171,complete_dump} which on the contrary defines a {complete} dump.

{/}See: {#1202,constants} - {#1114,dump_type} - {#1171,complete_dump}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1171,complete_dump}

constant: {complete_dump}
{/}

This constant is used to asign it to the global predefined variable
{#1114,dump_type} which sirves to define the type of dump which will be
on screen. Its value is {1}.

This is the {value by default} of the variable {#1114,dump_type}.
To establish this value must be used the following statement:

  {dump_type=complete_dump;}

This statement indicates to the manager of processes of DIV Games
Studio that the following dumps must be {complete}.

Denomines {dump} the method to send the frames of the game
to the monitor (to the video memory of the graphical card).

There are two types of dumps:

{Partial}: In the screen will turn ony the graphics which actualize,
which were changed with respect to the last frame. This dump must be activated
{to win the speed} when is programing a game (or its section}
without a window of scroll or mode 7 which occupies all screen,
it means, when the game shows movements of the graphics on the
fixed background, or when all active windows of scroll or mode 7 are smaller than screen.

{Complete}: Will turn all screen, doesn't metter if the graphic were changed or not.
This is the dump by default and {is slower than the partial}
but it must be used when the
game has one window of scroll or mode 7 which occupies all screen.

{/}

The other constant which is used to design the type of the dump is
{#1171,partial_dump} which on the contrary defines a {partial} dump.

{/}See: {#1202,constants} - {#1114,dump_type} - {#1170,partial_dump}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1172,no_restore}

constant: {no_restore}
{/}

This constant is used to asign it to the global predefined variable
{#1113,restore_type} which sirves to define the type of restore
which must be applied to the background of the screen after each frame of the game.
Its value is{ -1}.

Denomined {restore of the background} to rebuilt the zones of screen
in which were painted the graphics or written texts in the last frame,
it means, "{dispaint}" the graphics and "{diswrite}" the texts (rub out them).

To establish this value must be used the following statement:

  {restore_type=no_restore;}

The statement indicates to the manager of processes of DIV Games
Studio that after the following frames of the game {it is not necessary
to restore the background of screen}.

If doesn't restore the background, the execution will {win the speed} in the
game (will go more fluently in the slow PCs). This
modality of restore ({no_restore}) is applicable only
in their games or sections, in which {exist a window
of scroll or of mode 7 wich occupies the complete screen}.

The three applicable types of restore correspond to three constants:

{no_restore}       - The faster, doesn't restore the backgroundú
{#1173,partial_restore}  - Middle, restores partialú
{#1174,complete_restore} - The slower, complete restoreú

{/}See: {#1202,constants} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1173,partial_restore}

constant: {partial_restore}
{/}

This constant is used to asign it to the global predefined variable
{#1113,restore_type} which sirves to define the type of restore
which must be applied to the background of the screen after each frame of the game.
Its value is{ 0}.

Denomined {restore of the background} to rebuilt the zones of screen
in which were painted the graphics or written texts in the last frame,
it means, "{dispaint}" the graphics and "{diswrite}" the texts (rub out them).

To establish this value must be used the following statement:

  {restore_type=partial_restore;}

The statement indicates to the manager of processes of DIV Games
Studio that after the following frames of the game {must be restored
only zones of screen where were painted the graphics or written texts}.

This modality of restore ({partial_restore}) is faster than the
complete restore (option by default), but must be applied only in
their games, or sections, in which {doesn't exist a window
of scroll or of mode 7 which occupies the complete screen}.

The three applicable types of restore correspond to three constants:

{#1172,no_restore}       - The faster, doesn't restore the backgroundú
{partial_restore}  - Middle, restores partialú
{#1174,complete_restore} - The slower, complete restoreú

{/}See: {#1202,constants} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1174,complete_restore}

constant: {complete_restore}
{/}

This constant is used to asign it to the global predefined variable
{#1113,restore_type} which sirves to define the type of restore
which must be applied to the background of the screen after each frame of the game.
Its value is{ 1}.

Denomined {restore of the background} to rebuilt the zones of screen
in which were painted the graphics or written texts in the last frame,
it means, "{dispaint}" the graphics and "{diswrite}" the texts (rub out them).

This is the value by default of the variable} {#1113,restore_type} and,
of three modalities of restore, is the the{slowest}.
To establish this value must be used the following statement:

  {restore_type=complete_restore;}

This statement indicates to the manager of processes of DIV Games
Studio that after the following frames of the game {must be restored completely
the background of screen}.

This modality of restore ({complete_restore}) is the slowest
(and it is the option by default), therefore can be changed by another
to {win the speed} of execution in the game
(will go more fluent in the slow PCs).

In reality, this modality is usefull only in games, or their section,
which {don`t} have a window of scroll or of mode 7 which occupies all
screen, but which have a big quantity of graphics moving by the screen.

The three applicable types of restore correspond to three constants:

{#1172,no_restore}       - The faster, doesn't restore the backgroundú
{#1173,partial_restore}  - Middle, restores partialú
{complete_restore} - The slower, complete restoreú

{/}See: {#1202,constants} - {#1113,restore_type}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1175,Numbers of window}

constants: {c_0} ... {c_9}
{/}

These constants are used to assign them to the predefined local variable
{#1134,cnumber} which sirves to define the windows of scroll or mode 7
in which must appear the graphic of process.

This is necessary only when were activated many windows
of scroll or many windows of mode 7, and you don't want the graphic of the
process to be visualized in all of them}.

Can be defined till 10 windows of these types, with the numbers
from{0} to {9}, and which correspond directly to the constants
{c_0}, {c_1}, {c_2} ... {c_9}.

For the graphic to appear only in one of these three
windows, must be assigned the constant corresponding to its local variable
{#1134,cnumber}. For example, if you want the graphic of one
process to appear only in window number 3 (of scroll
or mode 7), in its code must be included the following statement:

  {cnumber=c_3;}

If you want this graphics to appear in many windows
of these windows, then the constants must be sumed.
For example, for the process to appear in the windows 0, 4, and 5
must be realized the following assignation:

  {cnumber=c_0+c_4+c_5;}

For the graphic to appear in all windows, must be assigned
a {0} to the variable {#1134,cnumber}. This is not necessary if
this variable wasn't modified, then it is its value by default.

The values to which are equivalent these constants correspond
with the following potentials of 2:

    {c_0} = 1   scroll / mode 7 number 0ú
    {c_1} = 2   scroll / mode 7 number 1ú
    {c_2} = 4   scroll / mode 7 number 2ú
    {c_3} = 8   scroll / mode 7 number 3ú
    {c_4} = 16  scroll / mode 7 number 4ú
    {c_5} = 32  scroll / mode 7 number 5ú
    {c_6} = 64  scroll / mode 7 number 6ú
    {c_7} = 128 scroll / mode 7 number 7ú
    {c_8} = 256 scroll / mode 7 number 8ú
    {c_9} = 512 scroll / mode 7 number 9ú

{/}See: {#1202,constants} - {#1134,cnumber}.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1176,Codes of the keys}

constants: {Codes of the keys}
{/}

These constants are normally used as parameter of the function
{#128,key()}, to indicate which key you want to know is pressed.

Also can be used to compare the global variable
{#1110,scan_code}, which contains the code of the last pressed key, with these values.

Normally, to design each constant often is used the character {_}
(underlined) followed by the name of the key, for example for the key [{A}],
the constant refered to its code will be {_a}.

The complete list of these constants, with their respective values,
is the following (by the standard key-board):

{_esc}         = 1   [ESC] or escapeú
{_f1}          = 59  [F1] or function 1ú
{_f2}          = 60  [F2] or function 2ú
{_f3}          = 61  [F3] or function 3ú
{_f4}          = 62  [F4] or function 4ú
{_f5}          = 63  [F5] or function 5ú
{_f6}          = 64  [F6] or function 6ú
{_f7}          = 65  [F7] or function 7ú
{_f8}          = 66  [F8] or function 8ú
{_f9}          = 67  [F9] or function 9ú
{_f10}         = 68  [F10] or function 10ú
{_f11}         = 87  [F11] or function 11ú
{_f12}         = 88  [F12] or function 12 (DEBUGGER)ú
{_prn_scr}     = 55  [IMPR PANT] or impression screenú
{_scroll_lock} = 70  [BLOQ DESPL] or block desplacementú

{_wave}        = 41  key [§] o [¦]ú
{_1}           = 2   key with the number "1"ú
{_2}           = 3   key with the number "2"ú
{_3}           = 4   key with the number "3"ú
{_4}           = 5   key with the number "4"ú
{_5}           = 6   key with the number "5"ú
{_6}           = 7   key with the number "6"ú
{_7}           = 8   key with the number "7"ú
{_8}           = 9   key with the number "8"ú
{_9}           = 10  key with the number "9"ú
{_0}           = 11  key with the number "0"ú
{_minus}       = 12  key with the symbol "?"ú
{_plus}        = 13  key with the symbol "¨"ú

{_backspace}   = 14  key of rubout ( <- )ú
{_tab}         = 15  key of tabulator [TAB]ú
{_q}           = 16  key with the letter "Q"ú
{_w}           = 17  key with the letter "W"ú
{_e}           = 18  key with the letter "E"ú
{_r}           = 19  key with the letter "R"ú
{_t}           = 20  key with the letter "T"ú
{_y}           = 21  key with the letter "Y"ú
{_u}           = 22  key with the letter "U"ú
{_i}           = 23  key with the letter "I"ú
{_o}           = 24  key with the letter "O"ú
{_p}           = 25  key with the letter "P"ú
{_l_brachet}   = 26  key [^] or [`]ú
{_r_brachet}   = 27  key [*] or [+]ú
{_enter}       = 28  [ENTER] (Intro or Return)ú

{_shift_lock}   = 58  [BLOQ MAYUS] or capital blockú
{_a}           = 30  key with the letter "A"ú
{_s}           = 31  key with the letter "S"ú
{_d}           = 32  key with the letter "D"ú
{_f}           = 33  key with the letter "F"ú
{_g}           = 34  key with the letter "G"ú
{_h}           = 35  key with the letter "H"ú
{_j}           = 36  key with the letter "J"ú
{_k}           = 37  key with the letter "K"ú
{_l}           = 38  key with the letter "L"ú
{_semicolon}   = 39  key with the letter "Ñ"ú
{_apostrophe}  = 40  key [{{}]ú
{_backsthesh}   = 43  key [{}}]ú

{_l_shift}     = 42  [SHIFT] or capital leftú
{_z}           = 44  key with the letter "Z"ú
{_x}           = 45  key with the letter "X"ú
{_c}           = 46  key with the letter "C"ú
{_v}           = 47  key with the letter "V"ú
{_b}           = 48  key with the letter "B"ú
{_n}           = 49  key with the letter "N"ú
{_m}           = 50  key with the letter "M"ú
{_comma}       = 51  key [;] or [,]ú
{_point}       = 51  key [:] or [.]ú
{_sthesh}       = 51  key [_] or [-]ú
{_r_shift}     = 54  [SHIFT] or capital rightú

{_control}     = 29  keys [control]ú
{_alt}         = 56  key [ALT] or [ALT GR]ú
{_space}       = 57  [SPACE] or space barú

{_ins}         = 82  [INSERT] or insertú
{_home}        = 71  [HOME] or beginning of pageú
{_pgup}        = 73  [PAGEUP] or page upú
{_del}         = 83  [DELETE] or deleteú
{_end}         = 79  [END] or end of pageú
{_pgdn}        = 81  [PAGEDOWN] or advance of pageú

{_up}          = 72  Cursor upú
{_down}        = 80  Cursor downú
{_left}        = 75  Cursor leftú
{_right}       = 77  Cursor rightú

{_num_lock}    = 69  [BLOQ NUM] or numerical blockú
{_c_backsthesh} = 53  Symbol [/] of the key-board numericalú
{_c_asterisk}  = 55  Symbol [*] of the key-board numericalú
{_c_minus}     = 74  Symbol [-] of the key-board numericalú
{_c_home}      = 71  [HOME] of the key-board numericalú
{_c_up}        = 72  Cursor up of the key-board numericalú
{_c_pgup}      = 73  [PGUP] of the key-board numericalú
{_c_left}      = 75  Cursor left of the key-board numericalú
{_c_center}    = 76  key [5] of the key-board numericalú
{_c_right}     = 77  Cursor right of the key-board numericalú
{_c_end}       = 79  [END] of the key-board numericalú
{_c_down}      = 80  Cursor down of the key-board numericalú
{_c_pgdn}      = 81  [PGDN] of the key-board numericalú
{_c_ins}       = 82  [INS] of the key-board numericalú
{_c_del}       = 83  [SUPR] of the key-board numericalú
{_c_plus}      = 78  Symbol [+] of the key-board numericalú
{_c_enter}     = 28  [ENTER] of the key-board numericalú

Results indifferent to use these constants or the numerical values
which are represented, it means, you can call the function {#128,key()},
to check if is pressed the key [{A}], as {key(_a)} or
as {key(30)} (you can check in the previous list that {30} is
the numerical value of the constant {_a}).

{/}

{Important:} Some of these codes can be different in certain
key-boards, if you have doubt you can execute the following program
example, which shows in screen a board, corresponding to the
function {#128,key()} (indicating the {codes of the keys which are pressed}
in each moment), besides the values of the variables
{#1110,scan_code}, {#1109,ascii} and {#1108,shift_state} (relationed
equal with the reading of the key-board).

{#9999,program example:}
PROGRAM Example_codes_of_key-board;

GLOBAL
    keys[128];

BEGIN
    write(0, 0, 0, 0, "Codes of pressed keys, by key()");
    FROM x=0 To 127;
        write_int(0, (x%16)*20, (x/16)*10+20, 0, OFFSET keys[x]);
    END
    write(0, 0, 160, 0, "Code of the last pressed key (scan_code):");
    write_int(0, 320, 160, 2, OFFSET scan_code);
    write(0, 0, 180, 0, "Code ASCII of the last key (ascii):");
    write_int(0, 320, 180, 2, OFFSET ascii);
    write(0, 0, 190, 0, "State of the special keys (shift_state):");
    write_int(0, 320, 190, 2, OFFSET shift_state);
    LOOP
        FROM x=1 To 127;
            IF (key(x))
                keys[x]=x;
            ELSE
                keys[x]=0;
            END
        END
        FRAME;
    END
END
{-}

This program can be used (pressing woth the mouse on the
text "{program example:}" and then the key [{F10}]) check
the code which has the concrete key.

Then this numerical code can be used as parameter of the
function {#128,key()}, to check in the game of this key is pressed in one determined moment.

{/}See: {#1202,constants} - {#128,key()} - {#1110,scan_code} - {#1109,ascii} - {#1108,shift_state}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1177,min_int}

constant: {min_int}
{/}

This constant defines the min value which can accumulate any 
data in this language. This value is{ -2147483648}.

All data are {whole} with sign of 32 bits in this language.
Therefore, must be used only whole numbers inside the rank
({ -2147483648} ...{ +2147483647} ).

When the result of arithmetical operation exceeds this rank,
the system will not advert any error, therefore must be taken the precautions for it not happens.

{/}See: {#1202,constants} - {#1178,max_int}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1178,max_int}

constant: {max_int}
{/}

This constant defines the max value which can accumulate any 
data in this language. This value is{ 2147483648}.

All data are {whole} with sign of 32 bits in this language.
Therefore, must be used only whole numbers inside the rank
({ -2147483648} ...{ +2147483647} ).

When the result of arithmetical operation exceeds this rank,
the system will not advert any error, therefore must be taken the precautions for it not happens.

{/}See: {#1202,constants} - {#1177,min_int}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1179,pi}

constant: {pi}
{/}

This constant defines the equivalence in {hunderdth of degree} of the
mathematical constant {pi} (aproximately {3.14159265} radianes).

Its value is {180000} hunderdth of degree (180 degrees), equivalente to
{pi radianes}.

Often is used to define angules; for example, can 
define {180 degrees} as {pi},{ -90 degrees} as{ -pi/2},
{45 degrees} as {pi/4}, etc.

{/}See: {#1202,constants} - {#1044,Use of angles in the language}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1200,global predefined data}

In continuation describes each one of the global predefined data.

{#1413,STRUCT dirinfo}         - List of archives of one directoryú
{#1414,STRUCT fileinfo}        - Information about the archiveú
{#1103,STRUCT joy}             - Parameters of the joystickú
{#1102,STRUCT m7[9]}           - Control of the windows of mode 7ú
{#1411,STRUCT m8[9]}           - Control of the windows of mode 8ú
{#1100,STRUCT mouse}           - Parameters of the mouseú
{#1410,STRUCT net}             - Parameters of the hardware of netú
{#1101,STRUCT scroll[9]}       - Control of the windows of scrollú
{#1104,STRUCT setup}           - Control of the sound cardú
{#1415,STRUCT video_modes[31]} - Modes of video disposedú

{#1409,argc}             - Number of argumentsú
{#1409,argv[]}           - Arguments of the programú
{#1109,ascii}            - Reading of codes ASCII of the key-boardú
{#1416,channel[31]       - Channels of soundú
{#1418,draw_z}           - Plane of depth of the drawingú
{#1114,dump_type}        - Type of dump of the screenú
{#1107,fading}           - Indicator of fading of screenú
{#1426,fps}              - Number of frames in secondú
{#1111,joy_filter}       - Filter applied to the joystickú
{#1112,joy_state}       - State of the joystickú
{#1115,max_process_time} - Max time of execution of one processú
{#1419,num_video_modes}  - Number of detected video modesú
{#1113,restore_type}     - Type of restore of screenú
{#1110,scan_code}        - Reading of codes of key-boardú
{#1108,shift_state}     - State of the special keysú
{#1106,text_z}           - Plane of depth of the textsú
{#1105,timer[9]}         - Counteres of timeú
{#1420,unit_size}        - Size of the unity of reading/writtingú
{#1417,vsync}            - Wait retrace verticalú

{/}See: {#1202,constants} - {#1201,local data} - {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1201,local predefined data}

In continuation is described each one of the local predefined data.

{#1116,STRUCT reserved} - Internal parameters of the processesú

{#1129,angle}           - Angle of the graphic of the processú
{#1120,bigbro}          - Identifier of the big brother of the processú
{#1134,cnumber}         - Numbers of windows of scroll or mode 7ú
{#1122,ctype}           - Type of coordinates used by the processú
{#1117,father}          - Identifier of father of the processú
{#1131,file}            - Code of file of the graphic of the processú
{#1127,flags}           - Indicators of reflection anf transparenceú
{#1126,graph}           - Code of graphic assigned to the processú
{#1133,height}          - Height of the process in windows of mode 7ú
{#1424,m8_nextsector}   - Sector where directs the processú
{#1423,m8_sector}       - Number of sector in which is the processú
{#1425,m8_step}         - Height which can rise the processú
{#1422,m8_wall}         - Wall of map opposite which it collisionsú
{#1121,priority}        - Priority of execution of the processú
{#1421,radius}          - Radius of the processes of mode 8ú
{#1130,region}          - Region of screen assigned to the processú
{#1135,resolution}      - Resolution of the coordinates of the processú
{#1128,size}            - Size of graphic of the processú
{#1119,smallbro}        - Identifier of small brother of the processú
{#1118,son}             - Identifier of the son of the processú
{#1132,xgraph}          - OFFSET of the graphical board of the processú
{#1123,x}               - Coordinate horizontal of the processú
{#1124,y}               - Coordinate vertical of the processú
{#1125,z}               - Plane of depth of the graphic of the processú

{/}See: {#1202,constants} - {#1200,global data} - {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1202,constants predefined}

In continuation is described each one of the predefined constants.

{#1176,_a, _b, _c, ...}       - Codes of key-boardú
{#1400,_case_sensitive}       - Distinguish capital and small lettersú
{#1400,_extended_conditions}  - Extended conditionsú
{#1400,_free_syntax}          - Free syntaxú
{#0231,_hidden}               - Hidden archiveú
{#1400,_ignore_errors}        - Ignore all errorsú
{#1400,_max_process}          - Max number of processesú
{#1400,_no_check}             - No check errors of executionú
{#1400,_no_id_check}          - No check the identifiersú
{#1400,_no_null_check}        - No check accesses to NULLú
{#1400,_no_optimization}      - No optimize the codesú
{#1400,_no_range_check}       - No check the rankú
{#1400,_no_strfix}            - No enlarge the strings of textú
{#0231,_normal}               - Archive normalú
{#1400,_simple_conditions}    - Simple conditionsú
{#0231,_subdir}               - Subdirectoryú
{#0231,_system}               - Archive of systemú
{#0231,_volid}                - Etiquette of volumeú
{#0250,all_drawing}           - Indicator of all drawingsú
{#1162,all_sound}             - Indicator of all soundsú
{#1161,all_text}              - Indicator of all textsú
{#1175,c_0 .. c_9}            - Indicators of windowsú
{#1169,c_m7}                  - Coordinates of window of mode7ú
{#1412,c_m8}                  - Coordinates of window of mode8ú
{#1167,c_screen}              - Coordinates of screenú
{#1168,c_scroll}              - Coordinates of window of scrollú
{#1171,complete_dump}         - Complete dump of backgroundú
{#1174,complete_restore}      - Complete restore of screenú
{#1152,false}                 - False valuesú
{#1104,fast_mixer}            - Fat mixerú
{#1164,g_height}              - Indicator of heightú
{#1163,g_width}               - Indicator of widthú
{#1165,g_x_center}            - Indicator of center horizontalú
{#1166,g_y_center}            - Indicator of center verticalú
{#1150,m320x200 .. m1024x768} - Video modesú
{#1178,max_int}               - Max value of dataú
{#1177,min_int}               - Min value of dataú
{#1172,no_restore}            - Restore of disactivated  screenú
{#1170,partial_dump}          - Partial dump of backgroundú
{#1173,partial_restore}       - Partial restore of screenú
{#1179,pi}                    - Mathematical value of piú
{#1104,quality_mixer}         - Quality mixerú
{#1160,s_freeze_tree}         - Freeze processes and sons signú
{#1156,s_freeze}              - Freeze processes signú
{#1157,s_kill_tree}           - Kill processes and sons signú
{#1153,s_kill}                - Kill processes signú
{#1159,s_sleep_tree}          - Sleep processes and sons signú
{#1155,s_sleep}               - Sleep processes signú
{#1158,s_wakeup_tree}         - Wakeup processes and son's signú
{#1154,s_wakeup}              - Wakeup processes signú
{#0227,seek_cur}              - Current position of the archiveú
{#0227,seek_end}              - Final position of the archiveú
{#0227,seek_set}              - Beginning of archiveú
{#1104,sound_bits_16}         - Examples of 16 bitú
{#1104,sound_bits_8}          - Examples of 8 bitú
{#1151,true}                  - True valueú

{/}See: {#1200,global data} - {#1201,local data} - {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1291,commands of the graphical environment}

{Commands in the graphical environment}

{/}

{ALT+X}         - Exit from the graphical environment to the operative system.ú
{ESC+control}   - Exit directly from the environment and from the programs.ú

{ALT+S}         - Execute a session of the operative system MS-DOS.ú

{ESC}           - To anulate or cancel a dialogue window.ú
{TAB}           - To choose the selected control of a window or picture.ú
{Enter}         - To activate the selected control.ú

{F1}            - Invoke the window of help.ú

{F2}            - Save the selected program.ú
{F4}            - Open the program.ú
{F10}           - Save and execute the selected program.ú
{F11}           - Compile the selected program.ú
{F12}           - Save and sketch the selected program.ú

{control+ALT+P} - Record a capture of graphical environment (DIV_*.PCX)ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1292,Common commands in the games}

{Common commands in the games}

{/}

{ALT+X}        - Exit from the game.ú
{ESC+control}  - Exit from the game.ú

{contro+ALT+P} - Record a capture of the game (SNAP*.PCX)ú
{F12}          - Invoke the debugger of programs.ú
{Pause}        - Stop the game immediately.ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1293,commands in the debugger of programs}

{Commands in the debugger of programs}

{/}

{Cursors}  - Movement by the list.ú
{PgUp}   - Previous page.ú
{PgDn.}   - Next page.ú

{F4}        - Execute till the selected line.ú
{F5}        - See the list of process.ú
{F6}        - Execute the current process.ú
{F7}        - See or edit data.ú
{F8}        - Sketch statement.ú
{F9}        - Fix a point of rupture.ú
{F10}       - Execute the following statement or call a process.ú
{F11}       - See the profiles of time of the program.ú
{F12}       - Invoke the debugger / Advance frames.ú

{F}             - Execute till the following frame.ú

{TAB}           - Select button.ú
{Enter}         - Activate button.ú
{ESC}           - Exit from the debugger.ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1294,commands in the editor of programs}

{Commands in the editor of programs}

{/}

{General commands}

{/}

{F5}        - Jump to the beginning of one process of the program.ú
{control+Z} - Enlarge the window of selected program.ú

{/}

{Basic commands of movement and edition}

{/}

{Cursors}                  - Basic movement of the cursor.ú
{Home}                    - Jump to the beginning of the line.ú
{End}                       - Jump to the end of the line.ú
{PgUp}                   - Next page.ú
{PgDn}                   - Last page.ú
{Insert}                  - Change the insert and overwriting.ú
{Suprimir}                  - Rub out the character of cursor.ú
{Del}                    - Rub out the last character of cursor.ú
{TAB}                       - Jump to the following tabulation.ú
{shift+TAB}            - Distabulate.ú
{control+Del, control+Y} - Rub out the current line.ú
{control+right}           - Next word.ú
{control+left}         - Last word.ú
{control+PgUp}           - Jump to the beginning of the program.ú
{control+PgDn}           - Jump to the end of the program.ú
{control+Home}            - Jump to the beginning of the page.ú
{control+End}               - Jump to the end of the page.ú

{/}

{Command of search and substitution}

{/}

{ALT+F, control+F}     - Search text.ú
{ALT+N, F3, control+L} - Repeat search.ú
{ALT+R, control+R}     - Substitute text.ú

{/}

{Commands of blockes type QEDIT}

{/}

{ALT+A}        - Mark the beginning or end of permanent block.ú
{ALT+U}        - Dismark the permanent block.ú
{ALT+C}        - Copy the block to the current position.ú
{ALT+M}        - Move the block to the current position.ú
{ALT+D, ALT+G} - Rub out the block.ú

{/}

{Commands of blockes type EDIT}

{/}

{shift+movement}    - Mark variable block (keys of movement:
{Cursors, control + right, control + left, PageUp, PageDown, Home, End}).ú

{shift+Insert} - Insert block.ú
{control+Insert}    - Copy block.ú
{shift+Delete} - Cut block.ú

{control+X}           - Cut block.ú
{control+C}           - Copy block.ú
{control+V}           - Insert block.ú

{Delete}            - Rub out block.ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1295,Commands in the graphical editor}

{Commands in the graphical editor}

{/}

{General commands}

{/}

{F1}                    - Invoke the window of help.ú

{ESC}                   - Exit from graphical editor.ú

{Cursors, OP/QA}       - Movement of the cursor.ú
{Space bar}     - Is equivalent to press with the left button of mouse.ú
{shift+movement} - Movement of 8 in 8 points.ú
{shift+LeftBut.} - Take color of screen.ú

{W, S}                  - Choose color in side the current palette.ú
{shift+W, S}       - Choose the current palette.ú
{control+Cursors}      - Choose color and palette.ú

{Rub out}                - Undo.ú
{shift+Rub out}     - Repeat action (re-make).ú

{0}                     - Select the transparente color.ú
{B}                     - Distinguish the transparente color.ú
{C}                     - Window of colores.ú
{M}                     - Window of mask.ú
{T}                     - Select paintbrush.ú
{U}                     - Select texture.ú
{X}                     - Visualize texture.ú
{Z}                     - Change level of enlargement.ú

{/}

{Commands of tools}

{/}

{F2}             - Pencil, to draw into any direction.ú
{F3}             - Straight lines.ú
{F4}             - Multiline, stringned lines.ú
{F5}             - Bezier Curves.ú
{F6}             - Multicurve, stringned curves.ú
{F7}             - Rectangles and boxes.ú
{F8}             - Circles and circunferencies.ú
{F9}             - Spray paint.ú
{F10}            - Fullfilling of zones.ú
{F11}            - Blocks edition.ú
{F12}            - Undo and re-do of actions.ú
{shift+F1}  - Write texts.ú
{shift+F2}  - Place checkpoints.ú
{shift+F3}  - Bar of plotting.ú

{/}

{Specific commands}

{/}

{control}  - Move selection (bar: select block).ú
{D}        - Difuminate (bars: pencil, lines, curves and spray).ú
{H}        - Hidden cursor (bar: move block).ú
{K}        - Copy window (bar: select block).ú
{ +, -}    - Change tension (bar: multicurve).ú
{ +, -}    - Change the checkpoint (bar: checkpoints).ú

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1300,Common questions about DIV}

{Where can I find the information about DIV?}

Exist many users which support the program with webpages in
Internet, you can acceed them from {WWW.DIVGAMES.CoM},
this is the official page of the product. Besides exist {lists of mail}
where are resolving problems, and channels of CHAT about the language of
programing (the channel{ #div} of IRC Hispano).

{How can I obtain help about ... ?}

All options accessible from any menu of options are described
exclusively in the {book of user} of DIV Games Studio 2.

{How can I resolve a problem of configuration?}

For the sound problems, incomplete installations, etc., see the chapter
of {#2003,resolution of problems} of this electronic help.

{Which are the improvements of this version?}

They are divided in two groups: the {#2001,news in the language}
(explained in this {help}), and the {#2002,news of environment} (explained in the {book of user}).

{Why I`m said "Can`t recognize the file type"?}

It is possible that is it intenting to load one archive with incorrect menu, it means,
the menu of palettes sirves only to load palettes, the menu of files only to load
files of graphics (groups of graphics), that of the programs to load
programs or text archives, etc.

Also it is possible that it is intenting to load the map PCX or BMP True Color,
this version of DIV can work only with 256 colors, so these types of 
archives are impossible to import. The graphics which you want to load
in DIV must be frist converted in 256 colores with other tool.

{How can I stretch one graphic?}

To stretch a graphic you must press the left button of mouse on the
window of the map, but not on the bar with its name, but on the proper graphic
contained in the window. Then move the mouse in the position
in which you want leave the graphic and let go of the left button of mouse
(you can stretch maps in files, to the trash, to the background, in other maps
or in fonts generator).

{How can I drag one graphic contained in another out?}

{+126,0}You must acceed to the bar of edition of blocks to select
the part of the graphic which you want to drag out. The section can be realized
different ways, as a rectangle, painting countours, etc.{-}

{+133,0}When you realized the selection will appear many new icons
in the bar of tools, between them the iwith {cut the window}.
After pressing on this iwith on the desk {creates a new window of map}
{and inserts the selected zone} in it.{-}

{How can I cut and copy the graphics?}

{+126,0}See also the last question. To cut and move graphics you must acceed
to the {bar of edition of blocks}, inside the program of picture,
selecting the iwith which shows cutters.

From the desk can be realized some operations, as copy
one graphic in other, this can be made stretching the first one
in the second. Also can be created a copy of one graphic if you stretch
it to the background (zone of the desk which doesn`t contain any window).

{What must I do if the system becomes unstable?}

DIV Games Studio is very complex program and, although it is rather stable
in its execution, can happen that one unit makes an error
after realize one determined action, or blocks the PC.

In these cases, to return the system to its original state, you must load
DIV from the line of commands of MSDOS indicating the
parameter{ /SAFE} (introducing the command D.EXE /SAFE from the directory
in which was installed the program), to enter in the "mode of falls check".

{What must I do to learn programing?}

The basic concepts are not explicated in this help, but in the book of user
of DIV Games Studio 2, in the chapters 4, 5 y 6.

Also you can learn very much from the Examples of the functions of the
language (See the list of functions in the help about the language)
and the tutorials, which are simple mini-games 
destined to simplify the learning of the language (these tutorials
you can find in the directory PRG\TUTOR of DIV Games Studio 2).

{How are loading the graphics in the games?}

In one game can be used the graphics contained in the map
(archives MAP or PCX), loading them from one to one the functions
{#174,load_map()} or {#174,load_pcx}, or put some graphics
in file FPG of graphics and load them latter with the function
{#132,load_fpg()}, this last option has an advantage because can be loaded many graphics
at the same time in the game.

Then often the graphics are used to assign them to the variable
{#1126,LOCAL graph} of the processes of the game.

{How to show a new graphic in the game?}

To create a new graphic or "sprite" in a game, first must be
created a new process ({#1016,PROCESS}) with the orders which will manage
its conduct in the game, then each time when you want
to create a process of this type, you must call to the process
(See how to make a {#1033,call to a process}).

{How to undo a process?}

To undo or "kill" a process of the game, you can execute
a statement {#1028,RETURN} from itself or, from other
process, sending a signal s_kill (See the function {#158,signal()},
which is used for it).

{Which are the functions to manage the mouse?}

The mouse is not controled by any function, but by the global structure
{#1100,mouse}, you can acceed to the help about {language} / {global data}
to see the rest of structures which control other important aspects of the games.

{Where are loading all archives DIV from?}

When in a program is called the function load_fpg( ... )
the internal manager of DIV intents to localize this archive following this
scheme (suposing that it intents to load the archive
"DIR\file.EXT"):

- First situates where is the executable (EXE) of the game,
or in the main directory of DIV (where is D.EXE) in case when the game
will be executed from the environment.

- Then intents to open from this directory the archive as was
specified in the function ("DIR\file.EXT").

- When it is impossible to load this file, will intent to load the
file inside a directory which has as name the extention
of the proper file, it means "EXT\DIR\file.EXT".

- If this one also is not found, will try to load the file
without indicate a route, it means "file.EXT".

- Finally, if was found the file in any of those
directories, will intent to find directly in the
directory which name coincides with the extention of the file, avoiding the
route of access which passed to the function, it means "EXT\file.EXT".

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1301,Help about the calculator}

{How it functions?}

The calculator included in the environment has a different functioning from the conventional
calculators, it is made for programmers,
and therefore functions as evaluator of expressiones.

Its use is very simple, you write the mathematical expression and press
the key {Enter}. Pressing {F1} you will acceed always to this page of help.

For example, you can push in the calculator the expression 2+2 and press {Enter};
will appear 4 in the window of results. To introduce a new expression
first must be rubed out the last, this can be made pressing the key {ESC}.

It is possible to introduce complex expressions, using parenthesis {( )} to indicate
the priorities in the calculations.

{/}

The {operators} which can be used in the expressions of the calculator are
the following (indicate all synonyms accepted in each operator):

{ + -}      Sum and Subtraction.ú
{ * /}      Multiplication and division.ú
{ % MOD}    Modul, or rest from the whole division.ú
{ < <<}     Binary rotation to the left.ú
{ > >>}     Rotation to the right.ú
{ ^ ^^ XOR} OR exclusive binary.ú
{ | || OR}  OR binary.ú
{ & && AND} AND binary.ú
{ ! NoT}    Binary negation.ú
{ SQRT}     Square root.ú

{/}

The calculator have two cells which can change their {mode of
functioning}. These options are the following:

{Int} - If this cell activates, all operations will realize
internally in whole variables, as in the language DIV. For example,
the result of division 8/3 will be 2.

{Hex} - When this cell is activated, the result will be shown in
the system hexadecimal. Also can be introduced in this system numbers
inside the expressiones preceded from '{0x}' (as in the language).

{/}

{Note:} In the desk can be opened so many calculators which are
necessary, can be visibles simultaneously many different expressions.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1400,options of compilation}

These options modify the form in which DIV interprets a program and the code
which generates for l. Normally will not be necessary to specify any option.

To add one or more of these options to the program must be specified as
its first statement  (comentaries to margin) the word
{COMPILER_OPTIONS} followed by the names of the included options.

If are included many options, they must appear separated by commas, adding
always a point and comma in the end (after the last option).

{/}

{disposed options of compilation:}

{_max_process=x}

Where x is a whole positive number. Defines the number of
max permited in execution simultaneous processes. This can be made
when a program is completed (when it is known how many 
processes it can have in one moment), to
ewithomize memory in execution. When this
value can`t be defined, will be reserved a min of 1 Mb (and a max of 2 Mb)
for the memory of the program.

{_extended_conditions}

Permits to use assignations inside one condition (as:
{IF(id2=get_id(...))...)}; it was permited by default in the
first version. This option can be necessary for many
programs of the first version to function in the second.

{_simple_conditions}

Interprets the symbol = as a comparison, when
appears inside one condition. This is the opposite case to the previous
(and incompatible with l), once this option is included it will be permited 
to make comparisons like {IF(x=0)...}, instead of interpret them
as an assignation of the value 0 to the variable x.

{_case_sensitive}

Difference in all names between capital and small letters.
In case of activate this option {Abc} and {abc} will be
two different names. It is important to know that, in this case,
all reserved words of the language ({program}, {loop},
{frame}, {if}, ...) must be put in small letters.

{_ignore_errors}

Forbids the appearance of the messages of error during the
execution of the program. The majority of errors will be ignored
(as errors of memory, if doesn`t find file,
divisions by zero, etc.) , we don`t advise to use this option
but, when you want it to be included, must be done only in the
yet finished programs, sufficiently checked, and without known
errors, before realize the installation (See the
final considerations).

{_free_syntax}

Permits to use free syntax. With this option will not be
necessary the symbols {;} (point and comma) in the end of the
statements and can be avoided the parenthesis of the conditions
in the statements like {IF}, {WHILE} or {UNTIL}. For example, in
this mode will be valid statements as: {IF a<0 a=0
END} (See before final considerations).

{_no_strfix}

Will not finish automatically the strings of text. When
you put one character in a data of type {#1406,STRING} generates
code for, when it inserts after the end of the string,
add white spaces till it and the character 
{NUL} (ascii 0) in the end of the string. This option disables this characteristic.

{_no_optimization}

Not optimize the generated code. By default optimizes the
programs, as in speed so in size. This option
can be included to disable these optimizations. It means,
if this option is specified, the programs will go slower
and will occupy more memory.

{_no_range_check}

Doesn`t check accesses out of the rank in boards and
structures. The compiler generates code to check during
the execution the expressiones used as indexes
of one board or structure to be in the permited limits,
to show an error when it acceeds out the rank. This option
forbids to generate this code.

{_no_id_check}

Not check the validity of the identification code. The
compiler also generates the code to check the validity of
identifier when it is used to acceed to the local variable
from other process (as in {id2.graph}). If this option specifies
in the beginning of the program, this checking will not be realized.

{_no_null_check}

Not check the accesses to null pointers ({NULL
POINTER}). Disables the checking of accesses to
memory with null pointers or not defined. Including this option
will not be generated the code to protect these accesses of
reading or writting in memory.

{_no_check}

Not realizes any of the checking of security.
This option unites the three previous, and forbids the compiler
to generate code to check any type of anomalous operation
during the execution. The programs can win 
speed, but it is not recommended to use these options
although the programs are yet finished and without errors.

{/}

To use these options, for example, the program can be begun with the following statement:

{COMPILER_OPTIONS _max_process=64,_no_id_check;}

In this case will be indicated to the compiler to reserve the memory for, in the 
execution of the program can be 64 processes simultaneous, will not be
checked the validity if the identifiers in the accesses to local variables of other
processes (it can be useful in the programs which often use these accesses,
always when the programmer has sufficient experience to sure what he makes).

{/}

{Important: considerations about some options.}

{1.} The new users of DIV or without big experience in the programing can
simplefy a little bit the conditions with the option {_simple_conditions}, so can be
compared two values with the symbol {=} (also with the symbol {==}). In contrary,
the users who yet was programing with the last version and have more
experience, probably will prefer to activate the option
{_extended_conditions} to be created complex conditions, which the
assignations inside of them.

{2.} The options {_ignore_error} and all variantes of {_no_check} must be used only
by programmers with big experience, and only in the final version of the
program. In contrary case we don`t recommend to use it, because can be produced big errors
of execution, and will be more difficult to find which was the general cause.

{3.} In general the programs are yet optimized (the generated code is {60%}
more fast than in the first version), any of these options will change significant the
speed of execution. Can be used
{profiles of time} of debugger to see the repercussion of each one.

{4.} The option {_ignore_errors} often is useless, always it is better to use
the function {#240,ignore_error()} to ignore selectively, in all cases, some determined errors.

{5.} The use of free syntax (with {_free_syntax}) also has many dangers. Because
there are no sense in different lines and white spaces, and in some cases can be
produced incorrect interpretations. For example, in the
statement: {IF right ++x END}, the compiler will interpret that the symbol{ ++} is the
postincrement of {right}, instead of the preincrement of {x} (although this symbol
is united with this last variable). Other similar case can happen using the pointers
in style C, with these two consecutive assignations:  {a=1 *ptr=2}, the compiler
will interpret them as: {a=(1*ptr)=2} (although they were in different lines).
But in general, if are not used preincrements or pointers in the style C, there will be
no problems with the free syntax (also can be used parenthensis or
points and comma in concrete cases, to resolve these small problems).

{6.} But the option {_max_process} (which is the only one which must be followed by the
the symbol {=} and the number) is recommended without any type of reserves. If it is known the
number of processes which the program can have in one moment,
for them can be reserved less memory (leaving this free for graphics, sounds, etc.).

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1401,types of data}

Apart from the yet known from the first version data (which now are known as
{#1402,INT}), exist data of the types {#1406,STRING} (strings of text), {#1403,WORD} (whole
positives of 16 bit), {#1404,BYTE} (whole positives of 8 bit) and {#1405,POINTER} (pointers, of all
these types). Also can be defined boards and structures (also of any
types) of 2 or 3 dimensions (see the {#1011,declaration of a board}).

{#1402,INT} - whole numerical data between -2147483648 and +2147483647 ({#1177,min_int} ... {#1178,max_int}).

{#1403,WORD} - whole numerical data between 0 and 65535 (whole of 16 bit without sign).

{#1404,BYTE} - whole numerical data between 0 and 255 (whole of 8 bit without sign).

{#1405,POINTER} - Pointers to data of any other type.

{#1406,STRING} - strings of text (boards of characters of 8 bit without sign, between 0 and 255)

{/}

{Note:} The reserved word {INT} can be omited, because all data will be of this type by default
(whole of 32 bit with sign).

{/}See: {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1402,data of type INT}

Whole numerical data between -2147483648 and +2147483647 (values defined
in the constants {#1177,min_int} ... {#1178,max_int}).

This is the data of basic type of the language, when is not specified the
{type of the data}, it will be {INT}.

{/}See: {#1401,types of data} - {#1009,Declaration of a data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1403,data of type WORD}

Numerical whole data between 0 and 65535 (whole of 16 bit without sign).

The boards of type {WORD} can signify a big saving of memory,
with respect to the boards of type {#1402,INT} (occupy {2 times more} memory). But
{faster will be the operations with data of type} {#1402,INT}.

See the {#1407,adjustment of data in memory}, where is shown the occupation
of memory of the different types of data.

{/}See: {#1401,types of data} - {#1009,Declaration of a data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1404,data of type BYTE}

Whelo numerical data between 0 and 255 (whole of 8 bit without sign).

The boards of type {#1404, BYTE} can signify a big saving of memory,
with respect to the boards of type {#1402,INT} (occupy {4 times more} memory). But
{faster will be the operations with data of type} {#1402,INT}.

See the {#1407,adjustment of data in memory}, where is shown the occupation
of memory of the different types of data.

{/}See: {#1401,types of data} - {#1009,Declaration of a data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1405,data of type POINTER}

Pointers of data of any other type ({#1402,INT}), {#1403,WORD},
{#1404,BYTE} and {#1406,STRING}).

The pointers in the language DIV have a different from
other languages of programing functioning, are more simple in use.

These pointers are used as they were mobile boards, it means, boards which can be said
where they must be situated, assigning them a {#1085,OFFSET} (of other data). 
So you can acceed to these data situated in this position from
{pointer[index]}, for reading and writting of the values.

{/}

{different data of type pointer:}

{INT POINTER} - Pointer to whole data. The word INT can be omited, declaring
a pointer to {INT} as {POINTER name;}.

{WORD POINTER} - Pointer to a list or board of data of type {WORD}.

{BYTE POINTER} - Pointer to a list or board of data of type {BYTE}.

{STRING POINTER} - Pointer to a string of text contained in a {STRING}.

{STRUCT POINTER} - Pointer to a structure, must be declared as {STRUCT
POINTER name_structure <name>;}. Where {<name>} will be the pointer.

{/}

For example, if in one program exist different boards of type {WORD} (declared as
{WORD t1[9], t2[9], t3[9];}), can be defined a denominated pointer {ptr}
which permits to acceed to any of them (as {WORD POINTER ptr};). To
refer to any of the boards must be assigned its direccion to the pointer
(as with {ptr = OFFSET t1;}). Beginning from this moment, you can acceed to the
values of the board with the pointer (you can acceed to {t1[n]} as {ptr[n]}).

The functioning of the pointers {#1402,INT}), {#1403,WORD} and {#1404,BYTE} are practically identical
(permit to acceed to a list of consecutive data).

The pointers {#1406,STRING} permit to acceed only to one string of text (to all
its characters).

In the declaration of the pointers {#1012,STRUCT} must be indicated the name of the structure
to which they will refer, because they can acceed to one type of structure. No
obstante, after assign to it the {#1085,OFFSET} of the structure (or of any register)
it will permit access to all fields and successive registers, as it were the conventional structure.

{Note:} To declare a pointer to a structure it is necessary to writte its before.
It`s enough the declaration in which are indicated differentes fields, it is not
necessary to define the number of registers of the structure.

{/}

{Limitation in the access of the pointers.}

You can`t acceed the written data before is established the
{OFFSET of the pointer}. This {OFFSET} can`t be assigned in the declaration of the pointer,
it must be done in one statement of the program, before reach this statement the pointer
will value 0 ({pointer zero}). The access to data with the pointer zero will provoke an
error of execution (see the {#1400,options of compilation}).

It is possible {to limitate the rank of access of one pointer}, indicating in its declaration the
max value from index permited for it. For it it must be only
indicated in brackets, after the name of the pointer. For example, the following
declaration:

{STRING POINTER s[32];}

Defines the pointer to one string of text, but it will stop to acceed
directly to its 33 (from 0 to 32) firsts characters. If it is intented
to acceed out of these limits, the program will advert it indicating an access
out of the rank.

{/}See: {#1401,types de data} - {#1009,Declaration of a data} - {#1085,OFFSET}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1406,data de type STRING}

The boards {STRING} are an excepcion, receive special relation as {strings of text}
and can have only {1 dimension}. If to them is not assigned a literal, the string
will stay initiated in {""} ({empty string}).

If a string is defined as {STRING s="abc";}, when it is acceeded by its
name ({s}) will refer to the contained string ({"abc"}). Also you can 
acceed to any character of the string as it were an element of the board
(for Example, the statement {s[3]="d";} would add one {"d"} to the string).

{Note:} It is not necessary to declare in brackets the length of the strings of
text (will be reserved the space to save till 256 characters).

{/}

{operations with strings of text.}

Inside one program, suposing the data {s} and {r} of type {STRING}, can be
realized operations as the following.

{1.} Can be used the data of type {STRING} in all functions which require
a text (as {#171,write}(0,0,0,0,s), {#132,load_fpg}(r), ...).

{2.} Also it is possible to assign literals to a string writting only
{s="any text...";} or assign one string to another, as {s=r;}.

{3.} Can be sumed the strings with statements as {s+="text to be added";} or
{s=r+"ho"+"the";}.

{4.} Also can be added one character to a string with statements as {s+=ascii;}
or {r+="a";}.

{5.} Can be deleted one character of the string (from the end) with {s--;}, {s-=1;} or {r=s-1;}.

{6.} Can be compared strings with conditiones as {(s=="hola")}, {(s>=r)},
{(s<"0"+r)}, etc.

{7.} And, finally, exist great number of functions of text management (See the {#1032,list of functions of the language}).

{/}

{Literals of many lines.}

It is possible to define literals in many lines, for it you must only divide the
text in many texts, and put them one after another (without any separation with symbol). 
For example, a constant can be defined as:

{greetings="­Ho"}ú
{       "the!";}

This can be also used to initiate the data of type {STRING}. There is no limit
in the number of lines. Between two following literals can appear only {#1002,commentaries}.

{/}See: {#1401,types of data} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1407,Adjustment of data in memory}

It is important to stress that all data in this language will be adjusted to {4
bytes} (size of the data of type {INT}. This means that the {OFFSET} of all data will be always situated in 
one direccion of absolut memory {multiple of picture}.

It has direct implications in the data of types {WORD} and {BYTE}. Because
they occupy respectively {2 bytes} and {1 byte}. therefore, if defines a variable of
type {WORD}, so, won`t be used 2 bytes of memory, and if defines a variable of type
{BYTE} won`t be used 3 bytes (because the following data will also be adjusted to 4).

Therefore, to use better the PC memory, we recommend to use
these two types of data as boards (see the {#1011,declaration of a board}), because the different elements of a board
always save the following, and don`t adjust in memory.

{/}

{Examples of occupation of memory:}

{BYTE b1;} - required memory 1, occupied memory 4.

{WORD w1;} - required memory 2, occupied memory 4.

{INT i1;} - required memory 4, occupied memory 4.

{BYTE b2[7];} - required memory 8, occupied memory 8.

{WORD w2[2];} - required memory 6, occupied memory 8.

{BYTE b3[2];} - required memory 3, occupied memory 4.

{WORD w3[3]} - required memory 8, occupied memory 8.

{/}

As you can see, the occupied memory (in bytes) by one data always
will be a value multiple to 4.

You must also remember it in the fields of the {#1012,structures of data} because
for example; two consecutive variables of type {WORD} will occupy {8 bytes},
while a board {WORD} with two elements occupies only {4 bytes}.

{/}See: {#1401,types of data} - {#1009,Declaration of data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1408,The blocks FUNCTION}

The new blocks {FUNCTION} behave the same way as the functions of
other languages of programing, execute sequencially (not in paralel
as the blocks {#1016,PROCESS}), not returning before they are no t finished.

{FUNCTION} {#1001,<name>} {(} {#1018,<parameters>} {)}ú
{#1008,<Declaration of private data>}ú
{#1086,BEGIN}ú
    {#1017,<statement>} {;}ú
    ...ú
{#1091,END}

These blocks will continue to function the similar way as the normal processes,
but with one important difference: will stop the calling process before finish,
it means, that these functions will sleep the process which called them, until these
functions will return or their process will be finished.

If the function doesn`t use the statements {#1029,FRAME}, it will behave as
the normal process, but if one function executes the statement {#1029,FRAME}, it will not return
to the block which it called (as it would do the normal process).

Therefore, a function always can return a value with {#1028,RETURN}{(}<expression>{)},
including after giving one or many {#1029,FRAME}.

{/}

{successive programing.}

It is not recommended to program only with functions and the successive way, but to know how it is possible
to simplify the understanding of the programing DIV for programmers of other languages.

It is posssible to make a program in the traditional programing style using
exclusively blocks {FUNCTION}, this way each moment in the execution will be only one process.

After programing this way, the statement {#1029,FRAME} converts in the exact order
of {covert to video}. Logically, if there is only one process executing, when it executes this order
the system will show the following frame of the program.

But, programing this way, could be shown different graphics in screen?.

The respond is yes, because can be created some kind of mini-processes which will function as
one instruction of such style "paint the graphic for the following frame" (with difference to
the functions as {#146,put()}, which paint a graphic forever).

To show a graphic in the following frame must be constructed a process which receives
the necessary visual parameters and executes the only statement {#1029,FRAME}, for example:

{PROCESS paint_graphic(x,y,graph)}ú
{BEGIN}ú
{    FRAME;}ú
{END}ú

After calling to this process {will be created one temporal process which will be painted
in the next frame} and then will disappear. Can be contained another parameters
(besides {#1123,x}, {#1124,y}, {#1125,z}), as {#1131,file}, {#1128,size},
{#1129,angle}, {#1125,z}, ... (See the {#1201,predefined local data}).

It is clear that, after programing this way, must be created (normaly in one
global {#1012,structure}) a board of sprites such way that the program could manage
all graphics. This, that can seem difficult, is the natural form to
program the games in any other language which is not DIV.

{/}

{Applications in the main program.}

The statements which appear between the words {#1086,BEGIN} and {#1091,END} of the main program 
(after the declarations of data), control the {#1015,main process of the program}. 
It is encharged to initiate the program, realize the presentations, control the
loops of menu, the loops of game (creating necessary processes), and finish the program.

In the main program, can be very usefull to call the blocks {FUNCTION}. Because this way
the main program will be stoped while it is executing that part which controls this function.

For example, the sequence of presentation can be made in one function, the menu of
options in other, etc. Also, remember that functions can always, after finish,
return a value with {#1028,RETURN}{(}<expression>{)}, this can be also usefull,
for example the menu, returns the number of option which was selected.

{Note:} The end of execution of the main code doesn`t implicate to finish the execution of
program, so it will be continued if there stay alive processes; if you want to force the 
end of the program after this code is finished, you can use, for example, the
function {#129,let_me_alone()} just before the {#1091,END} of the {#1015,main code}, or also the function
{#109,exit()} (in any point of the program).

{/}See: {#1016,Los blocks PROCESS} - {#1000,syntax}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1409,GLOBAL argv[], GLOBAL argc}

{argv[];} // Arguments of the programú
{argc;}   // Number of arguments{/}

You can acceed to last parameters of the program (normally after
execute it from mode MSDOS), in the style of language C, in the global predefined data {argc} and {argv[]}.

The variable {argc} will contain, after execute the program, the number of parameters.
Being {1} the min number, because always counts as parameter the name of proper executable of the game.

The board {argv[]} is a board of {strings of text}, and it will have defined so many positions
as it indicates the variable {argc}, and in {argv[0]} will be always the name of the program.

{/}

{Note:} When one program executes from the windows environment of DIV, it will not receive no more 
parameters, only the proper name of executable. Therefore these variables will be usefull
only in the versions yet installed in the programs.

{/}See: {#1200,global data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1410,GLOBAL STRUCT net}

{STRUCT net;}ú
    {device;}      // Mechanism of connectionú
    {com;}         // Port of comunicationsú
    {speed;}       // Speed of connectionú
    {number;}      // Telephone numberú
    {init;}        // Modem initiation stringú
    {mode;}        // Mode (press or tone)ú
    {server;}      // Indicates if it is serverú
    {max_players;} // Max number of playersú
    {num_players;} // Current number of playersú
{END}

This structure of data is very advanced level and requires rather big
experience in programing to know how to create a game oriented to the
net connection (you can find more information in the {user`s book}).

It contains the data about net hardware, must be used in aggregate
with the functions {#180,net_join_game()} and {#181,net_get_games()}.

The structure {net} has the only register. In its different fields
are established the parameters which define the type of connection.

{/}

{device} - Mechanism with which will be established the connection,
it can contain one of these three values:

 {1} - Connection in one {local net}, with protocol IPX.

 {2} - Connection by cable (only two crews).

 {3} - Modem connection (only two crews).

In function of the mechanism must be initiated ones and others fields of the
structure {net}, because many of these parameters are specific for one concrete mechanism.

{/}

{com} - port of comunications to use for the connection, it means, the
number of mechanism COM (from COM1 to COM4), indicating it as numerical value between {1} and {4}.

This field must be defined only for connections by cable or modem.

{/}

{speed} - speed in bauds (number of bits in second), till 115000.
This speed must correspond to the used cable or modem possibilities,
and to the volume of data which requires the communication of the program.

This field must be defined only for cable or modem connections.

{/}

{number} - Telephone number, of course this field is necessary only for
modem connections.

For example, the telephone number which to be dealed must be assigned with a statement
like the following: {net.number="912345678";}.

{/}

{init} - Initiation string, it is also exclusive field for modem connections; for example a statement like: {net.init="ATZ";}.

{/}

{mode} - mode in which must be established the modem connection (also only for this mechanism), the values can be the following:

 {0} - Presses.

 {1} - Tones.

{/}

{server} - indicates if one crew is the server. It means one informative data
(this field is only for reading, can`t be modified).

In one connection, only one crew will have the field {net.server} in {1}, this
crew will be the server of game, and exactly it must centralize the most important actiones
of the program.

{/}

{max_players} - The max numbers of players which is permited in one game,
from {2} to {16}. This field is usefull only in connections by local net,
because in cable or modem connections the max number of players is always {2}.

This number must coincide with the max number of registers with has the global
structure used as communication parcel between the different crews.

{/}

{num_players} - The current number of players connected in the game,
from {1} to {net.max_players}. This is dinamical value, which is changing during
are producing the connections (the players are connecting and disconnecting each moment).

The game programing must determined if player can dinamically enter and exit
from the game, or all of them must be connected before the game starts.

{/}See: {#1200,global data} - {#180,net_join_game()} - {#181,net_get_games()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1411,GLOBAL STRUCT m8}

{STRUCT m8[9];}ú
    {z;}      // Priority of impressionú
    {camera;} // Camera identifierú
    {height;} // Camera heightú
    {angle;}  // Vertical angleú
{END}ú

This structure of {10} registers contains certain fields relationed
with the modificable parameters of the {windows of mode 8}. The ten
registers have the same names of fields, but each one of them
modifies the parameters of the window of mode 8 different
(because can be activated till 10 windows of such type).

One {window of mode 8} can be defined as a region of screen which shows three-dimentional
the map of sectors.

For one register (from {0} to {9}) of the {structure m8} has sense,
first must be activated this {window of mode 8} (from {0} to {9}) with the
function {#190,start_mode8()} (see this function for more information about the
windows of mode 8}.

The fields of this structure are complementary to the parameters of
call of this last function. To see the practical example
of one mode 8, you can acceed to the help about the function {#189,load_wld()} or about {#190,start_mode8()}.

{/}

{Use form of structure m8:}

To acceed to these fields must be preceeded the name of field
by the word {m8}, the register number in brackets and the symbol {#1063,. (point)}.

For example, if are initiated two windows of mode 8, the number 0 and the
number 1, you can acceed to the variable {camera} of both windows as
{m8[0].camera} and {m8[1].camera}, respectively. When you acceed to the
window number 0 of mode 8 you can also omit the number of
windows in brackets, it means, that the variable {m8.camera} and the variable
{m8[0].camera} are, in all aspects, the same for the language.

{/}

{In continuation is shown detailed description of each field}

{z} - priority of impresion of the mode 8, here is indicated in what plane of depth
must be painted this window, with respect to the rest of processes. By default, this
variable will value {256} that means, as the processes by default
have their {#1125,local z} variable in {0}, the window of mode 8 will be painted in the plan
of major depth, more to the background, visualizing the graphics of the processes
over the window. To change this situacion you can modify the
variable {z} of the window (for example put it in{ -1}) or the variable {z} of
processes (for example put it in {257}).

{/}

{camera} - {#1039,Identification code of the process} in which is situated the camara. To move
the camera which controls the vision of the mode 8, only must be created a process
of mode 8, a process which has its local variable {#1122,ctype} {=} {#1412,c_m8}, and put its
{#1039,identification code} in the variable {camera} of this structure.
After it, must be only modified the local variables {#1123,x}, {#1124,y}, {#1125,z} and {#1129,angle} of
this process and, for example, used the function {#101,advance()} to move forward the camera.

{/}

{height} - camera height with respect to the process, by default this field
is initiated in {32}. The process of mode 8 will situate vertical in
its coordinate {z}, its local variable {height} determines the height of the proper
process, and this field ({m8.height}) determines the height of the camera (of the
{eyes} of the process with respect to its base).

{/}

{angle} - vertical angle of the camera, the value of this angle is between { -128} and {128}.
It defines if the camera looks up or down. When {m8.angle} values {0},
what is value by default, the camera will look to the center.

The horizontal angle will be the local variable {angle} of the proper process
which is used as camera of the window (which identifier is in {m8.camera}).

{/}

See also the {local variables} relationed with the {mode 8}.

  {#1421,LOCAL radius}ú
  {#1422,LOCAL m8_wall}ú
  {#1423,LOCAL m8_sector}ú
  {#1424,LOCAL m8_nextsector}ú
  {#1425,LOCAL m8_step}ú

{/}See: {#1200,global data} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1412,c_m8}

constant: {c_m8}
{/}

This constant is used to assign it to the predefined local variable
{#1122,ctype} which sirves to define the type of coordinates which will have a process. Its value is {3}.

This is the value assigned to {#1122,ctype} for
the coordinates of the graphic of the process to be interpreted as refered
to a window of mode 8, to coordinates about the three-dimentional sector map
which is shown in it.

For more information about the {windows of mode 8}, you can acceed
to the function {#190,start_mode8()}, used to activate them.

Exist other constants used for another systems of coordinates,
the complete list is the following:

    {#1167,c_screen} - coordinates of screenú
    {#1168,c_scroll} - coordinates of scrollú
    {#1169,c_m7}     - coordinates of mode 7ú
    {c_m8}     - coordinates of mode 8ú

{/}See: {#1202,constants} - {#1122,ctype} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1413,GLOBAL STRUCT dirinfo}

{STRUCT dirinfo;}ú
    {files;}      // Number of files in listú
    {name[1024];} // Archive namesú
{END}ú

Thie global predefined structure is used as return of the function
{#231,get_dirinfo()}, to contain the list of archives of one directory (or folder).

It is meant one register structure, which groups one variable
{files} and one board of pointers in {strings of text} ({name[]}).

{/}

{In continuation is shown detailed description of each field}

{name[]} - The function {#231,get_dirinfo()} only returns the {total number} of archive list;
names of these archives are saved in this global structure,
in its board {name[]}(the first name of archive is saved in
{dirinfo.name[0]}, the second in {dirinfo.name[1]}, etc.).

{/}

{files} - The {total number} of archive lists which returns this function saves
also this field (it means, in {dirinfo.files}).

{/}

The list of archive names always are saved in alfabetical order, no
obstante can be used the function {#213,qsort()} to order the
structure by other criterion.

{/}See: {#1200,global data} - {#231,get_dirinfo()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1414,GLOBAL STRUCT fileinfo}

{STRUCT fileinfo;}ú
    {string fullpath[254];} // Full nameú
    {drive;}                // Disk unityú
    {string dir[254];}      // Directoryú
    {string name[7];}       // Nameú
    {string ext[3];}        // Extensionú
    {size;}                 // Size (in bytes)ú
    {day;}                  // Dayú
    {month;}                // Monthú
    {year;}                 // Yearú
    {hour;}                 // Hourú
    {min;}                  // Minuteú
    {sec;}                  // Secondú
    {attrib;}               // Attributesú
{END}ú

This global predefined structure is used as return of the function
{#232,get_fileinfo()}, to contain the attributes of one archive (or subdirectory).

It is meant one register structure, which groups different
strings of text (data of type {#1406,STRING}) and numerical variables (data
of type {#1402,INT}).

{/}

{In continuation is shown detailed description of each field}

{fullpath} - Full name (including the route). The route of access to archive can be specified completely (beginning with
the root directory of the unity, as "C:\WINDoWS\...") or relative to the current directory
(beginning with from where executes the game, as "MAP\MIOS\...").
In any case, in {fileinfo.fullpath} always returns the full route
from the root directory, including the letter of the unity.

{/}

{drive} - Drive disk in which is situated the archive which information was solicited.
The drive disk is returned not as the corresponding letter,
but as number, establishing the following correspondence: {1} for {A:}, {2} for {B}:, {3} for {C:}, etc.

{/}

{dir} - Directory where is situated the archive. In this string returns not only
the name of folder where contains the archive, but
is specified the full route, beggining with the root directory going through
all directories (for example "\DIV\MAP\"). Always it is returned 
with inverted bar (\) in the beginning and in the end.

{/}

{name} - Archive name, this field ({fileinfo.name}), returns the
name of the archive, without extension, maximum of {8 characters}.

{/}

{ext} - Extension of the archive. As last part of the name is returned
in this field the extension of the archive, in one string which includes the point
which separates its name.

{/}

{size} - Archive size, this value will be {0} if is solicited information
about one directory. The size returns as number of simple data, it
means, as the number of data like {#1402,INT} which get in the archive
(number of bytes between four). It is possible to change this relation modifying
the global variable {#1420,unit_size}).

{/}

{day} - Day of month of the last actualization of the archive.

{month} - Month of the last actualization of the archive.

{year} - Year of the last actualization of the archive.

{hour} - Hour of the last actualization (from {0} to {23}).

{min} - Minute of the hour.

{sec} - Second of the minute.

{/}

{attrib} - Atrributes of the archive, they indicate the characteristics of the
archive, if it is system archive, only for reading, occult,
etc. This value is the sum of the following constants:

  {0} - Normal archive.ú
  {1} - Archive only for reading.ú
  {2} - Archive occult.ú
  {4} - System archive.ú
  {8} - Label of volume.ú
 {16} - Subdirectory.ú
 {32} - Archive speed.ú

For example, for one system and occult archive, the value of {fileinfo.attrib}
would be {6} (2 occult + 4 system).

{/}See: {#1200,global data} - {#232,get_fileinfo()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1415,GLOBAL STRUCT video_modes}

{STRUCT video_modes[31];}ú
    {width;}  // Width of modeú
    {height;} // Height of modeú
    {mode;}   // Number of modeú
{END}ú

In the global predefined structure {video_modes} is situated, in the beginning of 
all programs, the {list of modes vesa} supported by the
video adaptador of the PC (all of them of {256 colours}),
till {maximum of 32} (from [0] to [31]).

The number of found modes is saved in the global variable {#1419,num_video_modes}.

This information is generated by the system automatically, you don`t need
to call any function. For all found modes is registered the following information:

{width} - Number of pixels in horizontal of the video mode.

{height} - Number of pixels in vertical of the video mode.

{mode} - Number of mode. This value can be used directly as parameter for the function {#157,set_mode()}.

Once is selected the {width} and {height} of the video mode which you want to activate,
and therefore there is the {number of register} of its structure, you must 
activate it calling to the function as:

  {set_mode(video_modes[}<number of register>{].mode);}

{/}

{Note:} Besides registered modes in this structure, exists a list
of standard video modes, which numbers are situated in the constants
{#1150,m320x200 ... m1024x768}.

{/}See: {#1200,global data} - {#1419,num_video_modes} - {#157,set_mode()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1416,GLOBAL channel[]}

{channel[31];} // Use of sound channels{/}

The global board {channel} maintains information about the use
of different sound channels (till 32) of the audio system.

Each time when you touch one sound with the function {#159,sound()}, it is send 
to one of these channels. And when is initiated the reproduction of one
musical modul with the function {#216,song()}, for it are reserved a determined number
of channels (till 24).

In this board, each position represents one of these sound channels,
and the system puts in {1} each position when is used its respective channel.

The function {#256,change_channel()} permits to modify the parameters of
each one of these channels.

{/}

{Note:} The system will never put in {0} the positions of the board {channel},
it must be the program which rubs out the board, and this way to determine
when once more is used one channel.

{/}See: {#1200,global data} - {#256,change_channel()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1417,GLOBAL vsync}

{vsync=0;} // Wait the vertical retrace{/}

The global predefined variable {vsync} defines a logical value (0 or 1) which
indicates if it is necessary to wait the {retrace vertical} before to convert the following
frame to video (when all processes execute the statement {#1029,FRAME}).

By default this variable will be always in {0}, it means, is not waited the
vertical retrace before convert each frame to video.

To indicate to the system it must wait the retrace vertical you must put
this variable in {1} (with the statement {vsync=1;}).

{/}

{Note:} Wait the retrace vertical can proportion in programs bigger softness of
movements (this effect is most of all visible in the
panoramic effects, see {#163,start_scroll()}), but wait the
retrace will also slow the programs in the great majority of cases.

{/}See: {#1200,global data}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1418,GLOBAL draw_z}

{draw_z=-255;} // plane of depth of the graphical primitives{/}

The {graphical primitives} are straight lines, rectangles, circles,
etc., which are printed with the function {#249,draw()}.

In this global variable indicates the plane of depth in which must appear
the graphical primitives in screen, this means what must appear over and down.

The plans of depth can be of any whole number inside the
rank ({#1177,min_int} ... {#1178,max_int}) and, as bigger is the number,
more to the background will be situated the frame.

The graphics of the processes have their {#1125,local z} variable in {0} by
default, the texts {#1106,text_z} in{ -256} and the pointer of the mouse has
{#1100,mouse.z} in{ -512} by default.

This means, that by default, if these values are not modified,
the graphical primitives will appear over the processes, but down the pointer of the mouse
and the texts.

{/}

{Note 1:} The variable {draw_z} is {#1006,GLOBAL} for all graphical primitives, it means, 
they can not be represented in different plans.

{/}See: {#1200,global data} - {#249,draw()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1419,GLOBAL num_video_modes}

{num_video_modes;} // Number of detected video modes{/}

The global variable {num_video_modes} contains the number of video modes
VESA which were detected in the graphical adaptor of the system.

The parameters of each one of these modes are registered in the global structure
{#1415,video_modes}, therefore the variable {num_video_modes}
defines the number of registers defined in this structure.

{/}

{Note:} Besides the modes registered in this structure, exists a list
of {10 standard video modes}, which numbers are in the constants {#1150,m320x200 ... m1024x768}.

{/}See: {#1200,global data} - {#1415,STRUCT video_modes} - {#157,set_mode()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1420,GLOBAL unit_size}

{unit_size=4;} // Minimum unit of reading/writting{/}

The global predefined variable {unit_size} indicates which is the size of the minimum
unit of reading and writting of the functions of archives based in {handles}.

By default it always values {4}, because 4 bytes is the size 
of the standard data {#1402,INT} (whole of 32 bit), and all data
asign in memory each 4 bytes (see the {#1407,asignation of data in memory}).

The functions which count up the unit size indicating it in {unit_size} are the following:

  {#225,fread()}ú
  {#226,fwrite()}ú
  {#227,fseek()}ú
  {#228,ftell()}ú
  {#229,filelength()}ú

And also the field {size} of the global structure {#1414,fileinfo}.

{/}

The minumum size of 4 implicates that it is impossible to write or to read any archives
with the length is not multiple to this number.

This size can be changed; for example assigning {1} to {unit_size} (with the
statement {unit_size=1;}). This way, all {lengthes} of the
previous functions will be indicated in bytes (and not in data).

However, after change the unit size, you must remember the following:

- {#1094,SIZEOF()} will continue to return the length of data (of 4 bytes).
For example, to save a board in disk it will be not enough to indicate {sizeof(}<board>{)}
as length, but you need multiplicate it in 4 (if it is defined {unit_size} as {1}).

- The functions of archives {#155,save()} and {#130,load()} (which are not the functions
based on {handles}) will continue to indicate the length in data.

- The functions of dynamic memory {#257,malloc()} and {#258,free()} also
will continue to work with the length in data, therefore must be made
adjustments in case of working with both groups of functions.

{/}See: {#1200,global data} - {#1407,Alignment of data in memory}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1421,LOCAL radius}

{radius;} // Radius (width) of the processes of mode 8{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have their proper value in its variable {radius}.

This local variable is used exclusively in the processes of one
mode 8 (which have assigned {#1412,c_m8} to {#1122,ctype}).

In {radius} indicates the radius, or size in horizontal, of the process.
The system requires this value to calculate the collisions with the
limits of the sectores of three-dimentional map.

As smaller is the value of {radius} for a process, it can be nearer to its walls 
and, therefore, bigger will be the points (or texel) of its textures.

{/}

{Note:} For more information about the mode 8, see the global structure
{#1411,m8} and the function {#190,start_mode8()}, which is used to initiate regions of this type.

{/}See: {#1201,local data} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1422,LOCAL m8_wall}

{m8_wall;} // Wall number of the map of sectors{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its own value in its variable {m8_wall}.

This local variable is used exclusively in the processes of
mode 8 (which have assigned {#1412,c_m8} to {#1122,ctype}).

In {m8_wall} the system saves, automatically, the number of wall
opposite which collisioned the process.

This information can be usefull to detect distinct active zones
inside a map of sectors (as ports, interruptors, etc.).

{/}

{Note:} For more information about the mode 8, see the global structure
{#1411,m8} and the function {#190,start_mode8()}, which is used to
initiate regions of this type.

{/}See: {#1201,local data} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1423,LOCAL m8_sector}

{m8_sector;} // Number of sector in which is the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its own value in its variable {m8_sector}.

This local variable is used exclusively in the processes of
mode 8 (which have assigned {#1412,c_m8} to {#1122,ctype}).

In {m8_sector} the system saves automatically, the number of
sector over which is situated the process, inside the map.

The information about the sector number can be usefull to program events
in function of the sector in which enters a process.

{/}

{Note:} For more information about mode 8, see the global structure
{#1411,m8} and the function {#190,start_mode8()}, which is used to
initiate regions of this type.

{/}See: {#1201,local data} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1424,LOCAL m8_nextsector}

{m8_nextsector;} // Sector to which is directed the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process has itw own value in its variable {m8_nextsector}.

This local variable is used exclusively in the processes of
mode 8 (which have assigned {#1412,c_m8} to {#1122,ctype}).

In {m8_nextsector} the system saves automatically, to which 
sector directs a process. It means, when the
process collisions with one wall of map, the system checks if
after it exists any other sector and, in this case, will indicate 
in this variable its number.

This information can be usefull , for example, to obtain the
heights on which is situated this sector (See {#193,get_sector_height()})
and, this way, check if the process must go up or down, and how much,
to acceed to the named sector.

{/}


{Note:} For more information about mode 8, see the global structure
{#1411,m8} and the function {#190,start_mode8()}, which is used to
initiate regions of this type.

{/}See: {#1201,local data} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1425,LOCAL m8_step}

{m8_step;} // height to which can lift the process{/}

This predefined variable is {#1007,LOCAL}, that means that each
process will have its own value in its variable {m8_step}.

This local variable is used exclusively in the processes of
mode 8 (which have assigned {#1412,c_m8} to {#1122,ctype}).

In {m8_step} indicates which is the max height to which the process can
lift to reach contiguous sector, as "the height of step" which can lift this process.

When a process achieves other more elevated sector, the system
checks with help of this variable if the process can acceed directly
to the same, in positive case will be checked the new height of the process
automatically and, in contrary case, the process will stop (it
will collision with the wall which separates both sectors).

{/}

{Note:} For more information about mode 8, see the global structure
{#1411,m8} and the function {#190,start_mode8()}, which is used to
initiate regions of this type.

{/}See: {#1201,local data} - {#190,start_mode8()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.1426,GLOBAL fps}

{fps;} // Number of frames per second{/}

The global predefined variable {fps} (frames per second) maintains the
number of frames per second which shows the program.

This variable is actualized by the manager of processes of DIV Games
Studio automatically. It doesn`t maintain the instant value, but
average of the last seconds, therefore is necessary certain time
of execution to establish the value of {fps}.

The function {#156,set_fps()} permits to establish the number of frames
per second of the program, but this way establishes the ideal number
of frames and not the real (which is written in {fps}).

It means, that this variable serves as counter to know how many frames
are converted to video per second, in average.

{/}

{Note:} The variable {fps} maintains data only for reading, won`t be archieved any 
effect modifying its contained from the program.

{/}See: {#1200,global data} - {#156,set_fps()}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2000,­Wellcome to DIV 2!}{+1,1}{-}

This text shows the basic concepts to introduce you in the managing of this environment of developing.

Using this electronic help you can acceed to large information about
this environment, even so, the learning of the language of programing and 
program options are described only in the {User`s book}.

{/}

{Note:} If you use this programing environment of videogames for the first time,
you must know, to exit from all programs
executed from DIV, you can always use the combination of keys {ALT}+{X}.

{/}

  {News with respect to the previous version}

  - {#2001,News in the language}ú
  - {#2002,News in the environment}ú

  {Relation of the subjects of introduction}

  - {#1,How to use the help system}ú
  - {#1300,Frequently asked questions (FAQ)}ú
  - {#2003,Resolution of configuration problems}ú

  - {#2004,What is DIV Games Studio?}ú
  - {#2005,Working with windows}ú
  - {#2006,Types of windows}ú
  - {#2010,Fixing a video mode}ú
  - {#2011,The window of configuration}ú
  - {#2012,First contact with the language}ú
  - {#2013,Trazing the programs}ú

{/}

DIV Games Studio appeared in the market in December of 1998 as the first environment of developing
with the programing language made exclusively for the game programing.

In the beginning, our wish as investigators was not the creation of the
professional environment, but more to create a simple and interesting environment which
could sirve as introduction to the fascinating world of game developing;
something like a "game to do games" in which any person could learn to program.

The very good acceptance lead us to make this second version of environment,
in which is maintained the same philosophy.

A great number of received opinions, criticism and wishes permited us to create 
the new DIV a little bit better in all aspects. We intented to make better, although a little,
all sides of environment. In this sense there are big differences with the previous version,
(and they are very practical).

Anyway, we would like to thank all persons who supported our idea and this product.
In the moment of presentation of this second version we still don`t know if exists one
alternative to this environment, that seems to be as unbelievable so sad, while is supossed it gives us pleasure.

We know there are a lot of steps to be made, and you once more have the opportunity
to follow use.

{The crew of DIV Games Studio.}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2001,News of the language in the version 2.0}{+6,1}{-}

{More language.} Was enlarged the programing language, including
multiple new characteristics and internal functions, in continuation are shown in details
the main news of the {language DIV} in its {version 2.0}.

{/}

{+150,0}The {options of compilation} are the new characteristic of this version, 
this way it permits to adapt the process of compilation to the necessities of
each project (see {#1400,Compiler_options}).{-}

{+150,0}Besides yet known from the first version data (which now are known as
{#1402,INT}), exist data of the types {#1406,STRING} (strings of text), {#1403,WORD} (whole
positives of 16 bit), {#1404,BYTE} (whole positives of 8 bit) and {#1405,POINTER} (pointers, of all
these types).{-}

{+150,0}Also can be defined {boards} and {structures} (also of any of these
types) of {2} or {3 dimensions} (see the {#1011,declaration of a board}), and
the structures can be initiated globally (see the {#1012,declaration of a structure}).{-}

{+150,0}The new {#1408,blocks FUNCTION} behave the similar way to the functions of
other languages of programing, execute secuencially (and not paralel as the processes),
not returning till they are not finished.{-}

{+171,0}Became better different aspects of the {debugger of programs}, with new functions and
support of new types of data. Between the news distinguish the {profiles of time},
which you can acceed with {F11} from the debugger, where you can observe the consumed
for the execution time and painting of each process.{-}

{+152,0}Became better the {system of error control} of the programs, therefore
are creating more stable and good executable, also now exist the possibility
to annul certain errors of execution (see the function {#240,ignore_error()}.{-}

{+157,0}Was added bog quantity of {new functions of archive management},
much more flexible and potential; see for example {#223,fopen()}, {#227,fseek()},
{#231,get_dirinfo()}, {#235,chdir()}, {#237,remove()}) or {#238,disk_free()}.{-}

{+158,0}Besides the support of CD-Audio music and digital effects, now exist
different functions for the reproduccion of musical moduls {MOD}, {S3M} and {XM}
(see {#214,load_song()}, {#216,song()} or {#218,set_song_pos()}).{-}

{+163,0}{Generator of optimized code.} The code generated for the programs is better and
faster (min of 60%) with respect to the previous version. Also the created programs {EXE}
are much smaller.{-}

{+164,0}{Functions for games in net.} Now it is possible to create with DIV Games Studio
games to play by {cable}, {modem} and {local net IPX}. With the system very
simple controled by the functions {#180,net_join_game()} and {#181,net_get_games()}.{-}

{+165,0}Other news is the integration in the language of the potential
manager of strings of text, with the data of type {#1406,STRING}, multiple
functions (as for example {#203,strcat()}, {#206,strchr()}, {#209,upper()}
or {#211,strdel()}) and adapted syntax to work with expressiones of strings
directly in the language.{-}

{+166,0}{Support of dinamic memory}. It is possible to ask and to make free memory
dinamically in the programs, thanks to the functions {#257,malloc()} and
{#258,free()} (it is complemented with the new data of type {#1405,POINTER}).
Also the function {#239,memory_free()} permits to determine the free disposed memory in the system.{-}

{+167,0}Also was added the possibility of {order} and {disorder},
with the simple but potential denomined function {#213,qsort()} which permits to order
and disorder structures of data, taking any field as its index.{-}

{+168,0}Another very solicited news is the {search of ways}. It means
different functions (see {#185,path_find()}) which permit to localize free routes (named by
somebody "stagnation of artificial intelligence").{-}

{+169,0}{Compresion of data.} Everything is more compact; the
executables and installed data (can be created {compact and protected installations}).
Also are included functions of compression in the language (see {#262,compress_file()}).{-}

{+170,0}{New mode 8.} A new mode with till 10 regions
of screen, which permits to visualize maps of three-dimentional sectors. With
an integrated editor in the environment and multiple functions (see for example
{#190,start_mode8()}, {#192,set_sector_height()}, or {#196,set_fog()}).{-}

{/}

{+176,0}{And much more.} The news of the language don`t stop here,
exist many other improvements and functions (besides the errors of the first version
which were fixed). In continuation we work out in details other
news of the language DIV.{-}

- A new function, denomined {#266,force_pal()}, permits all{graphics
loaded in a program to adapt automatically to a palette}
in time of execution.

- Exist functions of encriptation of data, as in memory so of
archives, such as {#259,encode()}, {#260,encode_file()} and {#261,decode_file()}.

- The {declaration of libraries} realizes now in the headline of the program,
after the statement {PROGRAM} (see {#1014,IMPORT}).

- Now it is possible to create programs in {much more video modes}, because can
be detected the disposed modes vesa (See {#1415,video_modes}).

- In this new version are prohibited the {assignations inside one
condition}, to simplify the programing for not advanced users.
However this can be changed (see {#1400,_extended_conditions and
_simple_conditions}).

- Now it is possible to define the {max number of processes} which can be in
the program in the moment of execution (see {#1400,_max_process}).

- It is possible to define {literals in many lines}, for it the text must be only divided 
in different, and put them successively (see the {#1047,limitation symbols of literals}).

- The {sound system} is completely new, and now is permited the reproduccion
of {archives WAV of better quality} in the programs (See {#134,load_wav()} and
new fields of the structure {#1104,setup}). Also were added sound functions
as {#256,change_channel()} or {#221,is_playing_sound()}.

- Also is permited now to use directly {frames of format PCX} in the
programs (See {#174,load_pcx()}), and to save these archives (See {#241,save_map/pcx()}).

- Exist functions to fix {a color of palette} ({#179,set_color()}) and also
to localize colors ({#264,find_color()}).

- Different {mathematical functions} as {#242,sin()}, {#243,cos()}, {#244,tan()},
{#245,asin()}, ...

- Were included {primitives to paint} distinct graphicals in screen:
lines, rectangles and boxes, circles, ... (See {#249,draw()}).

- Were added {other functions} which enlarge the existent possibilities
in the creation of programs, as {#212,screen_copy()}, {#253,write_in_map()},
{#254,calculate()}, {#265,load_screen()}, {#183,xadvance()}, {#188,new_map()}, ...

- Also you can count the {frames per second} (See {#1426,fps}), obtain the {parameters of the program} (See
{#1409,argv[]}), wait {retrace vertical} (See {#1417,vsync}), control better the
mouse in the programs (See {#1100,mouse.cursor} and {#1100,mouse.speed}), etc.

{/}

And also, all functions, data and possibilities which yet had the first
version of DIV Games Studio, ­stay here! {:)}

{/}{See also:} {#2002,News of graphical environment}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2002,News of the environment in the version 2.0}{+6,1}{-}

{More flexibility and simplicity in use.} The environment of developing of DIV Games
Studio evolved in multiple small aspects, and together they form
even more intuitive structure than in last version.

{/}

{+151,0}{A new help.} The help was actualized, was structured
better, and of course contemplates all news of the language DIV. The
format of the window includes a new bar of navegation.{-}

{+154,0}{Multiple sizes of paintbrushes.} In the graphical editor can be
selected now paintbrushes of multiple sizes and forms, monocroms or
in gray scale. With the key {T} you acceed to the new dialogue; can be added new
paintbrushes, adding them to the file {BRUSH.FPG} of the directory {SYSTEM}.{-}

{+155,0}{Picture with coat or textures.} In the graphical editor you acceed with the
key {U} to the new dialogue in which you can select any
of the maps from the desk as texture to paint (with the key {X} you can see
and dislocate this texture). Became better the tool
of {aerosol}, the bar of {checkpoints}, and also were added {new
commands of key-board} (as {K} to copy a graphic in window, or{ +/-} to
change checkpoint).{-}

{+156,0}{Graphical visualizers.} Almost all windows to open archives
dispose of a denomined square {Frames} which permit to visualize the contained
of these archives before they are loaded. Also it is possible {to load different
archives only once} marking them with the mouse while is maintained the key
{control} pressed (the key {Shift} permits to mark different consecutives).{-}

{+157,0}{Developed system of files.} In this version became better the internal managament
of the FPG; were eliminated errors, can be visualized reduccions of the contained maps,
printed the lists, transfered one complete FPG in map and vice versa.{-}

{+159,0}{Editor of sound effects.} The audio is completely new,
permiting much more operations, formats and including {mixer} and
{editor of effects} of sound. You can acceed to this editor from the sounds menu.{-}

{+160,0}{Evaluation of expressions.} Now you can acceed to the new windows
{calculators} (from the system menu) to evaluate numerical expressions
while it is programing, without exit from environment.{-}

{+161,0}{Generator of sprites.} The generator of characters is also a new characteristic of this version.
It was made to propose a base on which are realized the realistic pictures of humans and
animations. Latter these fotograms can be used in the
graphical editor to realize with them any type of modification.{-}

{+162,0}{Three-dimentional editor of maps.} The menu of maps 3D, as their editor
and all functions relationed with them of the language of programing,
are the new characteristic of this version of DIV Games Studio.{-}

{+171,0}{profiles of time.} From the debugger of programs you can acceed, pressing F11, to the profiles of
time of the program. These statistics indicate the consumption of time
of process during the executing of the program, and permit the manual optimization of the
speed of the programs.{-}

{+153,0}{New examples.} Are included multiple games and programs
developed by the users with the previous version of DIV Games Studio.
Also, in the CD-RoM you can find multiple shareware utilities
or of free use which has this environment of developing.{-}

{+172,0}{Facility of impression.} This version of DIV Games Studio permits to print,
besides the list of the programs, the lists of graphics contained in FPG
and the pages of electronic help.{-}

{+173,0}{Controls of volume.} Between the improvements included in the audio system,
now exists the better control of the levels of volume, as in
the environment so in the programs. In the reproductor of CD appears a small button
which gives an access to the mixer.{-}

{+174,0}{Library of graphics.} Was enlarged and better structured the library
of graphics included in the program. Also now can be imported maps of any number of
colors in formats BMP, PCX or JPG.{-}

{+175,0}{New system of installation.} The system of installation of the programs
was completely re-made, generating more compact and protected installations against
modifications, using an {more intuitive and graphical adaptable interface}.{-}

{/}

{+176,0}{And much more.} Exist much more small improvements in the environment,
many of them will be imperceptible, but they will make the use more
potential and easy. In continuation you can see in detailes those which can be more relevant.{-}

- Was {optimized the process of enter and exit} from the environment, the same
the execution of programs from it, now the loadings are faster
and the waiting time is shorter.

- The editor of programs shows now the {colored lists}, underlining
the key-words of the language, also you can configurate better defining,
for example, the tabulation size.

- Now, after entering in the environment, you can select if you want {continue the previous
session} or {begin the new one}.

- It is possible to select {more modes of visualization} for the environment, depending on the modes
supported by the installed video-card and adaptator VESA.

- An {editor of pallete of colors} simplifies the generation of explosions (which
now can be aborted) and the preparation of the background (now is shown 
its previsualization).

- Can be configurated the {speed of the pointer of the mouse} as the small bar
presented in the window of configuration of the system menu.

- In the fonts windows {appears an example of letters}, besides to
indicate which aggregates of characters are defined.

- It is possible to generate fonts of {letters with antidentate}, simply creating them with
the rebord of 1 point of the color of background.

{/}{See also:} {#2001,News of the language of programing}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2003,Resolution of problems of configuration}

{General resolution of audio problems.}

If the audio system couldn`t be initiated, it is because of the
conflict with its sound card. This problem is often produced by one of these motives:

- The card is using at the same time by {other program}. It can not
initiate the dispositive if exists any other program reading or writting
data in the card (as reproductor of MP3 or sound capturator).

- Can be produced a problem with the {autodeteccion} of the card parameters.
You must execute the program of configuration of sound or define
these values in the variable BLASTER or ULTRASND of the environment of system (you can find
more information in the user`s book of DIV Games Studio 2).

- Because of the {incompatibility} of the card. If it is not a card of
mark GRAVIS (tm) or SOUND BLASTER (tm), can be incompatible
with DIV Games Studio. The majority of clinical cards are compatible
with the cards SOUND BLASTER, can not be compatible in 100% and
present some problems.

If your particular problem doesn`t recognize any of these three cases,
first you must execute the program of configuration of the sound. This can be
made from DIV pressing {F4}, loading the program {SETUP.PRG} from the
directory {SETUP}, and execute it with {F10}.

In this program must be introduced the parameters of your sound card.
To obtain these parameters with Windows is probable to consult
its user`s book, but normally you can acceed to them the following
way: pressing with the right button in "My Pc", activating Properties \
Administrator of dispositives \ Dispositives of sound, video and games,
selecting your audio card (normally one compatible with "Sound
Blaster" or "SB") and pressing in Properties. Then will appear the dialogue
with the characteristics of your sound card where, in the Resources you`ll find:

{1.} The number of IRQ of your card as "petition of interruption".

{2.} The number of DMA and of DMA2 (also denomined as HDMA or DMA16)
as two "direct accesses to memory".

{3.} The number of port as the initial value of the first "interval of enter/exit".

Also you can try to configurate the sound system indicating in the program
of configuration a smaller card (previous to yours). For example, if you
have a card compatible with a {Sound Blaster AWE 64} or {128} and can not
initiate the sound system; try to configurate the system with
one {Sound Blaster 16}, or {Sound Blaster Pro}.

As the last recourse, if it is not possible to configurate the sound in your system,
you must disactivate it. For it you must execute the program of configuration
and select {<Without sound>} in the field which defines the type of card.
Then press the button {<Save>} to establish this configuration and disactivate
the sound in DIV Games Studio 2.

If even so you don`t reach to hear in your PC the sound effects of the
program, probably you have sound card which is not in 100%
compatible with the family Sound Blaster or Gravis Ultrasound. consult, for it, the deliveer of your system.

{Note:} The reproduccion of CD-Audio is independent from the digital sound system
which configuration was discribed here; therefore the CD music will be reproducted
although the sound system wasn`t initiated correctly.

{/}

{Problems of video.}

If one moment DIV enters in one invisible resolution, the first thing which must be done
is to exit from the environment pressing the combination {ESC+control} (or {ALT+X} and {Enter} in
continuation) and, then, return to enter in the mode of falls check. For it you must,
from the line of commands of {MSDOS} and in the directory (FOLDER) in which was
installed the program, execute the following command:

{  D /SAFE}ú

This way you will enter in the environment in a low resolution (in 320x200, the most compatible mode)
beginning from this mode you can intent to put others which will be
compatible with your card and with your monitor.

In those PCs in which the video system is not compatible with the standard
VESA must be user driver vesa. For it, you must contact with your deliveer or
technical service of your hardware (driver is a small program which must be
installed in the PC to give a support to some dispositives as, in this case,
your video card).

{/}

{Problems with the mouse.}

If the mouse dislocates jumping on the screen, instead of point to point, it is because
you`re using incorrect or old dispositive of mouse (driver of mouse is not
actualized). You can resolve this problema one of these ways:

{1.} Contact with the deliveer of your PC to obtain the dispositive of actualized mouse.

{2.} Change the resolution of the program (with the option {system\video mode})
by another in which is not produced this problem.

{3.} (MS-DOS, only for advanced users). Comment the line of your file
autoexec.bat in which is loaded the dispositive of mouse. This can be from the
proper DIV, load with F4 this file (situating in the root directory of your hard disk)
and add the word REM in the begining the line which loads the dispositive
of mouse (a line which normaly finishes with ...mouse.com). Then press
F2 to save newly the file, close it (pressing on the upper left corner
of the text window), exit from DIV (ALT+X) and re-start your PC. If
then you have problems with other program which requires this dispositive,
return to edit the same file and rub out the word REM which was added.

{/}

{Solution of possible problems in the installation.}

If you find any problem, check the minimum requirements of the
program indicated in the program. If you have doubts about one of the
elements consult the technical service of your PC or the deliveer of your PC.

The most probable is the problem of reading from the CD-
ROM with your reading unity; for it, clean the surface of the CD of DIV Games Studio
carefull with clean and dry duster, and intent the installation of the program once more.

{Manual installation}

If you couldn`t install correctly the program and have a lot of free space on the 
hard disk of your PC (suficiente to realize a maximum installation)
so you can try to realize a manual installation of the
program, for it follow these steps:

{MS-DOS users} - Supposing that your CD-ROM disk is D:, put the disk
of CD-ROM with the following command:

{  D:}

And press Enter. Then introduce the following commands (supposing that your hard disk is C):

{  XCOPY DATA\*.* C:\DIV\*.* /S}ú
{  C:}ú
{  CD \DIV}ú
{  DEL INSTALL*.*}ú

Pressing Enter after each one of these commands. If you have suficiente space the
program will be installed without any problem, introduce this command to execute it latter:

{  D /SAFE}ú

For the next executiones of the program, follow the convencional instructions.

{Users of Windows 95/98} - Open the session of MS-DOS (pressing twice on its with, or from
start menu \ programs \ ms-dos) and follow the instructions for MS-
DOS users. For the next executions of the program you can use the instructions of the
operative system, remembering that the program will be installed in the folder
DIV of your hard disk.

{/}

If you don`t archieve the program to function correctly with these advises, then contact
your technical service of Hammer, its tel. is (91) 304 06 22, and time of attention is
Thuesday and Thursday from 16:00 to 18:00.

Remember that, because DIV Games Studio is the product of massive selling and
with limited technical support, first try to follow carefully all
instructions before make a call to this service.

{Important:} In this technical service cann`t be realized any consulting about
the language of programing, because for it we don`t give more support that this
{hipertext of help} and the {user`s book} of the program. With them you can find a solution for all doubts you have.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2004,What is DIV Games Studio?}{+1,1}{-}

We can said it is one graphical environment which integrate a new language of
programing for videogames together with other utilities as program of
painting, tools to create fonts of letters, palettes, etc.

The language of programing was made exclusively for the creation
of games and, as you can see, permits to obtain very good results with
very short and simple programs.

It is not necessary you know to program to use it, DIV was made
to learn to program with it. It has the sense to make you loose the fear of the word "programing" ...

{/}See: {#2005,Working with windows} - {#2000,Introduction to 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2005,Working with windows}

The windows, can be dislocated in any position on screen if you press
on the bar of title with the mouse and strech to the new position.

{Title bar.} - Is the superior zone of the windows, where is shown the name
in white color on the blue background. When the name of the window appears in gray scale,
it is because the window is not selected (because is selected another of the same
category), to select it press on it.

{Strech.} - This term is applied inside the graphical environment to the action of press 
with the mouse on one object, dislocate it on the new position, and finally leave the button
of the mouse.

To ask the system to put the window automatically, you must press twice
with the mouse on the title bar of the window. If the system
finds better position for the window, will dislocate it there.

The windows can be in {different modes}, and therefore their functions and operations will
be distinct. In continuation are described these modes:

{1. Active windows:} Are those which, normaly, have if is changed the
configuration of colors, the iluminated title bar, in white letters on blue background
and are situated above all in the desk.

{2. Inactive windows:} This type of windows have dark title bar, in black
letters on the dark grey background. To activate one of these windows you must press on them.

{3. Windows of second plan:} Are windows which are obscured; this is because
at least parcial, covered by other windows. With these
windows you can`t interact before they come in a first plane pressing with the mouse on them.

{4. Icons:} The icons are the minimized windows, it means, which were
reduced temporally. The icons don`t have any picture, only a button
with the sign "+" followed by the title of window.

{Note:} To strech the graphics (to a file, to the desk, etc.) don`t press
on the title bar of the window (with this you`ll strech to it),
but on the contain of the window. It means, you must press in the
middle of the window and, without leaving the button of mouse, dislocate it in the new position.

{/}See: {#2006,Types of windows} - {#2000,Introduction a DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2006,Types of windows}

The windows can be classified by the function, realizing the following groups:

{1. Interactive dialogues:} These are windows which are used to solicit
information to the user; exists huge variaty of them, you`ll see them in 
respective options.

{2. Windows of error:} Are the dialogues in which the title bar appears in white
on the red and inform about the problem which was produced.

{3. Menus of options:} The menus are the list of options which call other
menus, windows or dialogues after press on them. All the menus beginn from the
main menu. Some menu have certain disactivated options (is
shown a pointer with the prohibited symbol if you put mouse on it); this is because
these options interact with the concrete type of windows, and there is no
active window of this type (before it must be created or loaded).

{4. Programs:} In these windows are created the programs and are windows
of edition of text. To edit a program its window must be activated (only
one of loaded programs can be activated). The edition of text is
similar to other editors of text (supports the standard EDIT).

To ask for help in a program about one word of the language you must put the
blinking cursor of edition (not the pointer of mouse) on it and, then,
press the key {F1}. These windows can change the size pressing on the
their inferior right button and streching with the mouse or pressing {control}+{Z}.

{5. Maps or graphics:} These windows are those which contain a map (bitmap) or
graphic and are controled with help of menu of maps.
They can be loaded from archive MAP (proper format), imported from
archive PCX, BMP or JPG. To edit the graphics must be realized a
doble pression with the button of mouse in the center of these windows entering, this way,
in the graphical editor (described in the {user`s book}). These graphics can
be streched to the background (to make a copy), to other graphic (to
insert them), to file of graphics (to include them) or to the trush (to
rub out them), for it you must strech from the center of the windows, in place of the title bar.

{6. Maps 3D:} These are vector maps created in the editor of maps 3D,
in their window is shown how one aggregate of closed polygons
representing the vertical section of a plan. Its creation is not trivial, and is shown in
the {user`s book}. These maps are saved on disk in the archives with extension WLD.

{7. FPG or files for graphics:} These windows show the contained of one
file of the disk. Are libraries or colections of graphics used in the
games; its utility consist in any necessity to load in a game separately a big quantity of
maps. They have two basical modes of function, activated
with help of quanter denomined "Info" in its inferior part. When this quanter
is not activated (by default) can be marked and dismarked a serie of graphics
with which is pretended to realize an operation, or strech the graphics out
the file (to the background, other files, maps or the trush). When this quanter
is activated can be edited the codes of the graphics and their
descriptions. These FPG are controled always from the menu of files.

The windows of the FPG are always the direct reflection of the "file for graphics"
contained in the hard disk of the PC, therefore can be closed anytime,
without the necessity to save them before. Their contained will never be lost.
The option {Files \ Save} permits to make a copy of the FPG with other
name (as temporal or security copy).

{8. Fonts of letters:} The fonts or types of letter are the small windows which
represent concrete typography. You must press on them to see an
example of the font in real size. They correspond to the archives FNT (proper format)
and are controled by the menu of fonts, fron which you can acceed
to generator of fonts which is the tool used to create new fonts
of letters. The fonts of letters are used inside the program of painting and in the
programs to write texts.

{9. Sound effects:} Represent on screen a file PCM (press code
modulation) or WAV with a sound effect. They are controlled with the sounds menu, so 
you can create new effects (with the sound recorder) or edit them. You can find a 
library of sound effects already prepared to being used in the games. To hear those
sound effects you must have a compatible sound card withe the Gravis Ultrasound or
Sound Blaster family, correctly configurated and to press over one of these windows.

{10. Musical modes:} Can be loaded songs in the formats MOD, S3M and
XM. They are represented in one small window which permits to activate or stop its
reproduction. It is impossible to compose these moduls from the proper environment.

{11. Window of help:} It is controled mainly with the mouse, also you can use
cursors, the keys of PageUp and PageDown and BackSpace
to return to the previous page. In the windows of help are shown in white the texts which make reference to
other pages of help. You must press on these references to acceed to these pages.
In the windows of help also are shown example programs
which can be pulled out pressing on their title, executed with the key
F10 and rubed out pressing ALT+X.

{12. Calculators:} The windows of the calculators function as evaluators of
mathematical expressions, in style of expressions presented in the programs.
Their functioning is very simple, because you need only introduce an expression and
press Enter to see the result. You can use parenthesis to indicate subexpressions.

{Note:} The window of the trush must be activated first from the 
system menu, with the corresponding option ({System \ Trush}).

{/}See: {#2010,Fixing the video mode} - {#2000,Introduction to DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2007,Demo Session}{+1,1}{-}

This is the copy of DIV Games Studio 2 exclusive fot its evaluation, and is limited  
with 31 executions of the program.

This demo version is completely functional, and was created with the goal
you could evaluate the possibilities of the program and the
compatibility with your system, before to add the registered copy.

There are only two restricted functions in this version:

- The {size of the programs} which can be compiled is limited by the
maximum number of objects.

- The programs which can be installed (after create a EXE independent from DIV with the option
{Programs} \ {Create installation}) will be marked by the informative message.

These restrictions don`t exist in the comercial version of the program, but also remember
that this one contains {User`s book} which is neccesary
to acceed to all functions of the program and to learn the language of programing of DIV 2.

{/}

{Note:} The information contained in the User`s book of DIV Games Studio 2
(about the news of the environment, the options of the program, the tutorial of the new
language, ...) can`t be found in this electronic help.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2008,conflict with the sound dispositive}

The audio system of DIV Games Studio was initiated because of
a conflict with your sound card. This problem is often produced because of these motives:

- The card is using at the same time by {other program}. It can not
initiate the dispositive if exists any other program reading or writting
data in the card (as reproductor of MP3 or sound capturator).

- Can be produced a problem with the {autodeteccion} of the card parameters.
You must execute the program of configuration of sound or define
these values in the variable BLASTER or ULTRASND of the environment of system (you can find
more information in the user`s book of DIV Games Studio 2).

- Because of the {incompatibility} of the card. If it is not a card of
mark GRAVIS (tm) or SOUND BLASTER (tm), can be incompatible
with DIV Games Studio. The majority of clinical cards are compatible
with the cards SOUND BLASTER, can not be compatible in 100% and
present some problems.

{/}

{General solution of the audio problems.}

If your particular problem doesn`t not recognize any of these three cases,
first you must execute the program of configuration of the sound. This can be
made from DIV pressing {F4}, loading the program {SETUP.PRG} from the
directory {SETUP}, and execute it with {F10}.

In the first chapter of the {user`s book} you can find the infromation 
how to obtain the parameters of your sound card.

Also you can try the configurate the sound system indicating in the program
of configuration a smaller card (previous to yours). For example, if you
have a compatible card with a {Sound Blaster AWE 64} or {128} and can not
initiate the sound system; try to configurate the system with
 {Sound Blaster 16}, or {Sound Blaster Pro}.

As the last resourse, if it wasn`t possible to configurate the sound in your system,
you must disactivate it. For it execute the program of configuration
and select {<Without sound>} in the field which defines the type of card.
Then press the button {<Save>} to establish this configuration and disactivate
the sound in DIV Games Studio 2.

{/}

{Note:} The reproduction of CD-Audio is independent from the digital sound system
which configuration was described here; therefore will continue to reproduce
CD music although the sound system is not initiated.

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2009,The sound dispositive is not finished}

Can not be reproduced digital sounds inside DIV Games Studio 2 if the sound dispositive is disactivated.

Probably was selected in the program of configuration {<Without
sound>}, instead of indicate the type of card installed in your PC (or one compatible with it).

{/}See: {#2008,conflicts with the sound dispositive}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2010,Fixing a video mode}

The option {System \ Video mode} gives an access to the dialogue window which permits
to modify the resolution used by the graphical environment of DIV Games Studio 2.

The video resolutions are indicated as the number of existent points in horizontal and
vertical in screen in this mode and are between 320x200 (low
resolution) and the max resolution which permits your video card. To select
a new resolution you must press on the list which appears in the window and then
in the button {Accept}.

{Note:} Some of these video modes can be visualized incorrectly
(for example, a resolution which is permited by your video card but not by your
monitor); in this cases you must wait {15 seconds} for the environment
restores the previous resolution. Don`t press any key, don`t realize any
action, only wait.

{Selection of the font of system.}

Two square permit to select the font used by the system, exist two
possibilities which not only have the difference in the size of letters but, in general, in the
size of all windows of the environment.

{1. Small font (and small windows).} In this mode all windows,
menus and pictures are seen in small size, being convenient for modes
of low resolution or PC with big monitor.

{2. Big font (and big windows).} This mode can be activated
only in the resolutions beginning from 640x480 and is convenient for small monitors.

{Note:} The font of letters used in the programs and in the window of help is
independent from the selected for the system, and is defined in the window of
configuration, also accesible from this system menu.

{/}See: {#2011,The window of configuration} - {#2000,Introduction to DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2011,The window of configuration}

With help of the option {System\Configuration} you can acceed to the dialogue window
divided in sections, which are shown in continuation.

{Colors of windows}

This first section establishes the colors used by the environment; can be indicated
the colores for background of the windows, the color of letters and the color of the title bar.
To change these colors press on the boxes. The system not
only uses these three colors but, beginning from them, generates a gama of colors
for texts, cursors, buttons, etc.

{Editor of programs}

It establishes the aparience of the windows of edition of programs. Can be
selected different colors for different object (words or symbols)
presented in the programs.

{1.} Background of the window of edition.ú
{2.} General color of letters.ú
{3.} Cursor of edition.ú
{4.} Explication commentaries of the programs.ú
{5.} Symbols and operators of expressions.ú
{6.} Reserved words of the language.ú
{7.} Numbers inside the program.ú
{8.} Literals, or texts in inverted commas.ú

The text blocks marked inside the editor are seen with the interchanged colors of paint
and background.

A box of text permits to define the size (n number of spaces) of tabulator in the
editor of programs, as the number between 1 and 16. By default tabulates each 4 columes.

Also is possible to select here the size of the letters of the programs and the help,
from 6x8 to 9x16 points. All fonts of letters for edition are of fixed keys.

{Program of painting}

Defines the quatity of reserved memory to undo options in the graphical editor,
the speed of the pointer of mouse and its representation.

The quantity of "memory of undo" is specified in Kbytes, by default is
1088Kb (more than one mega), and it not necessary to modify this value although
can`t be realized an operation in the graphical editor because of absense of memory of
undo (in this case the program will advert it). As bigger is the reserved memory of
undo, less memory will be disposed in the system for the rest of actions.

The speed of the pointer of the mouse is defined with the small horizontal bar (faster
to the left and slower to the right), and affects to all environment of windows,
not only the program of painting.

{Global options of the environment}

{1. Emergent windows.} Indicate all movements of windows to be
visualized, when are opening, closing, minimizing, etc. If this option is disactivated,
the environment will loose the effects but will win the speed of respond.

{2. Move complete windows.} Indicates after streching the windows to the new
position to be seen in each moment the final result. Can be convenient
to disactivate this option in the slow PCs.

{3. Always save session.} Indicates that after exit from DIV Games Studio must be saved
the state of desk and all its objects (programs, maps, sounds,
etc.). If this option is disactivated the enter and exit from the environment will be faster,
but there is a risk to loose the works which were not saved.

{4. Color the lists.} Indicates that, when is editing one archive with
extenssion PRG, must be applied all colors selected before
for the editor. In contrary case will be paplied only the colors of background,
paint and cursor. The same when is editing one archive which is not PRG.

{Note:} If you close the window of configuration or press the key ESC willbe lost
all changes realized in it, restoring the values of the last configuration.

{/}See: {#2012,First contact with the language} - {#2000,Introduction to DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2012,First contact with the language}

In this section is explained how to execute the games Example of DIV Games Studio and
fast instructions to start its investigations,
receiving the first notions about this language of programing.

{General instructions}

All included games are simple examples, they don`t pretend
to compete with the comercial games which can be created with this tool.
Although we`re talking about complete games, the majority are very simple or very short.

The goal was to show the technics which are used and how are
realized the programs, proposing the button of example, instead of
huge lists in which the user looses.

{Note:} These games can never show the real possibilities of this environment, 
because practically noone game use them. The big majority of the new
and potential capacities of this version of DIV Games Studio weren`t used
in any example, giving you the possibility to be the first persons who
intent, or may be reach, to find out them in maximum.

To execute any of these examples you must, first, load the program with the
option {Programs\Open program}, will appear a window with the list
of the loaded program.

{The system of help}

One of the best options is investigate, examining the programs and intenting
to realize some change in them; after situating on any reserved word, constant, variable, function,
etc., of the language you can press the key F1 to see a page of help about this object.

If, after pressing F1, doesn`t appear the help about the object (but appears the general index)
is because this is not the proper name of the language DIV, we`re talking about
any data or process exclusive from the game (the processes are a kind of functions
which control the behavier of the graphics, or 'sprites', in the games).

{Note:} We recommend to begin to examine with simple games, as tutorials or, most of all,
the examples included in the electronic help; to acceed to them you must press
the button denomined Functions of the window of help and, from this page, go
acceeding to the different explications of the functions of the language of
programing, from where can be pulled out small examples pressing on their headline or title.

The texts which begin with the symbol // (doble bar) are explication commentaries,
they don`t form part of the program, but only consist in "explaining notes"
about the internal functioning of the program. These commentaries often are a big
help to understand the functioning of the programs. Also
can appear the commentaries between the symbols /* and */ (along many lines of the program).

To go to one of the processes of the program (one of the blocks which have the
programs to control a graphic or sprite of the game) you must press the key F5 and
select the name of the process with help of the mouse.

{Execution of the examples}

To execute one of the loaded programs, press with the mouse on its
window and then the key F10 (which action also can be realized with the option programs \ execute).

The instructions of the games are different, but the majority permits to exit
pressing the key ESC and are managed with the keys of the cursors and
the key control (See the {#1292,general commands in the games}).

The key Pause can be used in all games to stop the execution
immediately. All programs can be aborted in any point,
independent from their programing, if is pressed the combination of keys ALT+X.

{/}See: {#2013,Sketching the programs} - {#2000,Introduction to DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2013,Sketching the programs}

The most active persons can be curious in the games pressing the key F12
(from the proper game, during its execution), that permits to acceed to the debugger
of programs, it is made to execute  the games step by step.
You can observe all processes and modify their data (if you have convenient data,
can be changed all parameters of the game, the number of fase, the lifes, ...).

In the upper part of these window appears a list with the active processes in
each moment (as toys or graphics which are used by
program). They can be selected with the mouse and, pressing the button {see data},
will be seen all variables, counteres, etc. which is using the process.

In the lower part of the screen appears the list of the program, which basically
are the orders which the PC must realize during the game is functioning. It
normally is divided in small blocks which begin with the word
{PROCESS} (one of the reserved words of the language of programing). In each
one of these blocks are specified the orders for concrete element of the
game (for example, for the shot, an enemy or a explosion).

{General functioning of the programs}

In the outline, the games are always the sequence of frames. To
compose each frame participate different elements (or processes) in function of the type
of game. All these elementos must realize a series of operations or calculations
(normally very simple) to determine which must be their aparience in the following
frame (which picture or graphics it must show, in which position, of which size, etc.)

The PC is realizing the orders specified for each process until it
finds the order {FRAME} (frame or fotogram). This order indicates that one
process is yet prepared to be shown in the the following frame, it means, yet were
defined all parameters which will define its aparience in the following frame.

{Note:} To the orders specified in a program them denomine statements. Each one of these
statements indicates an operation or calculations which the PC must realize.

This way, the PC goes realizing all these operations and calculations
which it indicate the orders of each process, untill all active processes
give the order {FRAME}. In this moment, the PC stop to
execute orders and will dedicate only to compose the following frame which must
appear in the monitor.

Then in the games are always changing these two tasks, first are executed the orders,
and then are composed and shown the frames.

{Basical controls of the debugger}

This can be visualized from the debugger of the programs, with help of different buttons
which permit the actions of the program or game to go realizing
step by step, visible way. These main buttons are the following:

{1. Step.} Indicates to the PC to execute the following order of the next process. The
next process appears in white color in the superior list of the
debugger, and the following order to be realized (by this process) appears in the list of the
program in the same color.

{2. Exec.process.} This button is used the PC executes all
instructions of the following process until reachs the order FRAME, it means, it must
realize all necessary operations for the next process can be
visualized in the following frame.

{3. Foll.Frame.} This button is used to advance the game frame by frame.
Each time when it is pressed, will be executed all necessary orders of all
active processes, will be composed the new frame, and finally will be converted in
video (is denomined "convert to video" to the action of movement one frame
which is yet composed to the video card, such way that it will be visualized in the
monitor of the PC).

When is realized a program, all imaginable aspects can be
controled: the order in which are excuted the orders of the different processes, the
order in which the graphics are put in screen, the reactions of the processes
on the overput (when they "are touching" one another), when must be made sound effects,
the reactions of each process on the key-board, mouse, ...

{/}See: {#2000,Introduction to DIV 2}

# ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

{.2047,The last possible term inside this hipertext}
